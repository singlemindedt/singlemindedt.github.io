{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Smtsec","url":"https://singlemindedt.github.io","root":"/"},"pages":[{"title":"迷路了404","date":"2019-08-31T01:24:31.422Z","updated":"2019-08-31T01:24:18.825Z","comments":true,"path":"404.html","permalink":"https://singlemindedt.github.io/404.html","excerpt":"","text":""},{"title":"about me","date":"2019-08-31T01:12:58.000Z","updated":"2019-08-31T01:17:42.190Z","comments":true,"path":"about/index.html","permalink":"https://singlemindedt.github.io/about/index.html","excerpt":"","text":"是不是我魅力太大，hahaha~"}],"posts":[{"title":"网络安全复习","slug":"网络安全复习","date":"2019-12-09T07:19:00.000Z","updated":"2019-12-09T17:33:44.282Z","comments":true,"path":"2019/12/09/网络安全复习/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/网络安全复习/","excerpt":"","text":"网络安全概述1.网络安全的威胁来源（分类）信息泄露、信息破坏、拒绝服务 2.CIA三元组与网络安全基本需求网络安全的基本属性（CIA三元组）：机密性、完整性、可用性五个属性：CIA+可靠性+不可抵赖性八个属性：五+隐私性+可说明性+可审计性 3.网络攻击类型（主动/被动）1.阻断攻击（DoS）2.截取攻击3.篡改攻击4.伪造攻击5.重放攻击 4.OSI安全体系（安全服务与安全机制）安全策略指在一个特定的环境里（安全区域），为保证提供一定级别的安全保护所必须遵守的一系列条列、规则。 安全服务指用于提高网络中信息传输、存储和处理过程安全的服务。5个安全服务：认证：提供对通信中对等实体和数据来源的鉴别访问控制：防止对资源的非授权使用机密性：对数据提供保护，防止被非授权泄露完整性：保证信息精确的从起点到终点，不受真实性、完整性和顺序性的攻击不可否认：提供源发证明和交付证明，是通信双方均不可抵赖 安全机制是一种技术或措施，一种软件或者实施一个或多个安全服务的过程。8个安全机制：加密、数字签名、访问控制、信息完整性、鉴别交换、业务量填充、路由控制、公证 5.等级保护制度对不同对象、事件，分等级响应、处置。五级：用户自主保护级-&gt;系统审计保护级-安全标记保护级-结构化保护级-访问验证保护级每级安全技术要求：5个：物理安全、网络安全、主机系统安全、应用安全、数据安全 黑客攻击流程&amp;渗透测试6.黑客攻击流程踩点-&gt;扫描-&gt;查点-&gt;访问（获取访问权限失败-&gt;拒绝服务）-&gt;提权-&gt;窃取信息-&gt;掩盖踪迹-&gt;创建后门 收集信息阶段：踩点、扫描、查点 7.踩点找出感兴趣的目标，并收集与目标相关的信息的过程；途径：1.公开信息源搜索2.WHOIS查询3.DNS查询:dig、nslookup、fierce4.网络侦察：利用Unix/Linux下系统提供的traceroute程序、Windows下tracert探查网络拓补结构; 8.渗透测试步骤1.前期交互2.情报收集3.威胁建模4.漏洞分析5.渗透攻击（MSF）6.后渗透攻击7.报告 9.常用命令与工具ping,nslookup,host,hostnew,traceroute(tracert),nmap,telnet,net,dig,whois ping:（1）用来检测网络的连通情况和分析网络速度； （2）根据域名得到服务器IP； （3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。 我们通常会用它来直接ping IP地址，来测试网络的连通情况。 nslookup:用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题 host:把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名。hostnew 命令是 host 命令的 5.2 版. traceroute(tracert):Traceroute是Linux和Mac OS等系统默认提供的路由追踪小程序，Tracert是Windows系统默认提供的路由追踪小程序。二者的功能相同，都能探测数据包从源地址到目的地址经过的路由器的IP地址。 nmap:一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。 Telnet:用于远程登录到网络中的计算机,并以命令行的方式远程管理计算机。需要注意的是,远程机器必须启动telnet服务器,否则无法打开telnet命令。 net:https://blog.csdn.net/zhailihua/article/details/75561963 dig:dig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常 whois:是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。 网络扫描与查点技术10.扫描的基本步骤一个完整的扫描过程通常包括三个阶段：（1）确定目标系统是否存活（2）确定存活系统上运行的服务（端口扫描技术）（3）探查目标系统运行的操作系统类型（旗标抓取技术+协议指纹识别技术） 11.端口扫描的类型（7种）：原理与NMAP实现1.TCP连接扫描（TCP Connect()扫描） nmap -sT完成一次完整的三次握手过程；2.TCP SYN扫描（半开扫描） nmap -sS隐蔽性好，不完成完整的连接；3.TCP FIN扫描(秘密扫描) nmap -sF向主机发送FIN数据包；变体：(1)TCP圣诞树(TCP Xmas-Tree)：将FIN、PSH、VRG标志位置1(2)TCP 空(TCP NULL)：将所有标志位置04.TCP ACK扫描 nmap -sA测试防火墙的规则集；5.TCP窗口扫描 nmap -sW返回值为正–端口开放返回值为0–端口关闭6.TCP Maimon扫描 nmap -sM7.UDP扫描 nmap -sU向目标端口发送UDP数据包；若返回“ICMP port unreachzble”表名端口关闭，否则开放；不可靠，速度慢； 12.扫描的防御端口扫描其实就是通过对计算机每个常用端口发送数据包，通过返回的数据包来分析其弱点加以攻击。如何进行防范呢？其实最简单的办法就是关闭不用的端口，减低端口扫描风险，然后在对开启的端口做好防范措施（防火墙）。 口令破解与防御13.常用的口令破解方法1.暴力破解(穷举)(彩虹表)2.字典攻击(穷举预设字典中的口令组合)3.组合攻击(在字典口令的基础上在末尾+数字或字母)4.社会工程学 14.Windows，Linux口令安全原理Windows：安全账号管理器SAM机制；Win口令文件：%systemroot%\\system32\\config\\SAM LM-Hash将用户口令转为大写，不足14位用0填充，超过截尾14位，分为两组7位分别加密为两个DES加密密钥，再分别加密预定义的魔术字符串，获得两个8位密文值，连接起来即为LM-Hash值；不区分大小写，安全强调降低淘汰 NT-Hash将口令转为Unicode字符串，然后进行MD4单向Hash计算，产生128bit的Hash值； Windowa的登录与身份验证交互式登录、网络登录 NTLM采用挑战/响应机制进行身份验证；6步：三方交互：客户端：K 服务器：F 账号数据库：DB1.认证请求(K-&gt;F)2.挑战(F-&gt;K)3.响应(F-&gt;K)4.验证请求(F-&gt;DB)5.验证响应(DB-&gt;F)6.服务器响应(F-&gt;K) Linux用户名与ID关系文件：/etc/passwd口令字段：/etc/shadow过去：使用单向加密函数加密口令现在：系统根据日期选择salt值，并转为2个字符的字符串，与加密后的口令一起保存； 15.Linux常用命令（chmod,ls,ps,passwd,su,sudo等）chmod：使用权限 : 所有使用者使用方式 : chmod [-cfvR] [–help] [–version] mode file…说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。ls:功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）ls用法：ls [参数] [目录名]（如过要显示当前目录的文件可不加目录名）ps:使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等passwd:用来更改使用者的密码su:用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。使用权限：所有使用者。sudo:以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。使用权限：在 /etc/sudoers 中有出现的使用者。 16.口令破解与防御口令破解Win：利用漏洞获取管理员权限，利用Pwdump等工具获取NT在注册表中存储的SAM口令散列，口令破解；Linux：获取root用户权限，获取shadow口令散列，口令破解； 口令破解防御1.强口令2.口令策略3.防御口令泄露、删除和修改 欺骗技术与防御17.IP欺骗*伪造某台主机IP地址的技术(被伪装的主机往往具有某种特权或者被另外的主机所信任) 简单的IP欺骗1.伪装主机从而进行反红攻击以达到拒绝服务的目的；2.监听被伪装者与受害者之间的返回数据流TCP协议：主机间无法完成正常3握手，即无法进行数据传输UDP协议：面向无连接的协议，攻击者发送的数据包可以被发送给目标主机；导致拒绝服务； 源路由攻击攻击者在IP欺骗数据包中的源路由字段填入攻击者的IP地址，则返回的数据包就必须经过攻击者； TCP会话劫持接管现存动态会话的过程，攻击者冒充一方用户，同时监听并掌握会话内容； 过程：1.发现攻击目标(必须能检测到目标主机的通信流)2.确认会话状态3.猜测序列号4.使客户主机下线(DoS攻击)5.接管会话，在服务器上创建后门 防御1.放弃以地址为基础的验证2.进行包过滤入口过滤：不允许任何从外网进入内网的数据包使用内网的IP地址作为源地址出口地址：来自内网的地址使用了不属于内网的源地址，内网用户发起的欺骗攻击 3.加密通信时要求加密传输和验证 4.使用随机的初始序列号5.禁用路由器的源路由18.ARP欺骗*攻击者处于局域网内部，基于ARP协议的缺陷发送虚假的ARP请求或响应，就是ARP欺骗；(Windows arp -a) ARP缺陷1.不验证自己是否发过对应的ARP请求2.不验证该回应包是否可信3.直接用应答包替换ARP缓存表中的原有信息(主机和网关维护一张IP-MAC地址映射表，攻击者可向目标主机发送虚假的ARO回应包(将MAC地址设为自己的MAC地址)，成为”中间人”,使所有的数据包都会流经攻击者的网卡) ARP欺骗检测网络频繁掉线、变卡、arp -a查看映射表发现网关MAC地址与真实不符、使用嗅探工具发现网络中有大量的ARP响应包(Ettercap)… ARP欺骗防御1.静态绑定a.MAC地址绑定b.使用静态ARP缓存2.ARP防火墙3.使用ARP服务器(确保服务器不被欺骗)4.及时隔离被欺骗的主机 19.DNS欺骗又称DNS域名重定向或域名劫持，是通过拦截域名解析请求或篡改域名服务器上的数据，使得用户在访问相关域名时返回虚假IP地址或使用户的请求失败的攻击方式。 DNS欺骗一般过程(如果能获得DNS服务器的控制权再好不过，直接伪造一条记录就好，但是很难。尝试控制DNS服务器所在网络下的一台主机，监听网络通信，利用ARP、IP欺骗取得信任后，攻击者嗅探目标主机发送的DNS请求数据包，分析ID和端口号，构造DNS应答包，若发送的应答包ID和端口正确，则把返回的数据包中的域名和IP地址存进DNS缓存表，真实的DNS应答包被丢弃) DNS欺骗防御1.DNS服务器软件安装补丁2.限制DNS动态更新3.限制区域传送4.关闭DNS服务器的递归查询 20.电子邮件欺骗与邮件安全（PGP）攻击主要表现1.电子邮件炸弹、”滚雪球”、垃圾邮件2.自称管理员，假冒，附件木马 基本方法1.相似的电子邮件地址2.冒充回复地址3.利用附件欺骗4.远程登录到SMTP端口25发送邮件 防御1.树立风险意识2.对邮件加密签名 Web攻击与防御21.SQL注入原理、分类、攻击过程（程序分析能力）*原理利用Web应用对后台数据库查询语句处理存在安全漏洞，攻击者提供构造的数据库查询代码，根据返回结果得到目的数据。受影响系统 ：对输入参数不进行检查和过滤就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 分类22.XSS原理、分类、攻击过程（程序分析能力）*23.其他Web攻击类型*24.Web攻击的防御*缓冲区溢出攻击与防御25.缓冲区溢出原理26.栈溢出（程序分析能力）*27.其他溢出的工作原理28.缓冲区溢出的防御措施拒绝服务攻击29.拒绝服务攻击的概念、分类30.拒绝服务攻击的实例31.DDoS的工作原理32.拒绝服务攻击的防御身份认证33.AAA34.常用身份认证技术35.Kerberos协议36.PKI原理37.挑战相应机制访问控制38.访问控制的概念39.常见的访问控制的模型40.访问控制机制41.计算机安全形式化模型防火墙与入侵检测42.防火墙的基本原理43.防火墙技术分类44.防火墙的配置方案45.入侵检测的分类及工作原理VPN46.VPN的概念47.IPSec VPN：功能体系结构组成工作模式工作过程的3个阶段数据包封装IKE安全关联","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Bug","slug":"Bug","date":"2019-12-09T01:18:21.000Z","updated":"2019-12-09T02:00:55.672Z","comments":true,"path":"2019/12/09/Bug/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Bug/","excerpt":"","text":"给出一个登录页面;首先随便注册一个用户；登录；发现只有Manage是不能普通用户使用的；最后发现还有个Finpwd，找回密码之前应该会验证身份，应该是突破口；先以smtsec找回密码，发现直接给了一个newpwd输入框；应该是需要抓包修改用户身份；修改为admin，提示修改成功； 以admin身份登录成功；但是Manage还是不能使用提示IP not allowed!应该要改为本地登录；在请求头中加入X-Forwarded-For: 127.0.0.1进行ip伪造；得到如下页面；查看源码，看到提示：看到filemanage想到可能do为upload(文件管理无非上传、下载、查看、删除)；关于文件上传：https://blog.csdn.net/qq_42636435/article/details/88096844根据提示Just image？因该是上传image然后改后缀；构造： 123&lt;？php phpinfo();？&gt; 上传发现，过滤了;不是php文件又不能进行解析得到响应；非php文件下提示要上传php文件；It is not a really php file这里尝试使用php的脚本表达形式 123&lt;script language='php'&gt;phpinfo();&lt;/script&gt; 将jpg后缀改为php4/php5;(否则不能解析)就得到响应flag了.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"NaNNaNNaNNaN-Batman","slug":"NaNNaNNaNNaN-Batman","date":"2019-12-09T01:08:23.000Z","updated":"2019-12-09T03:17:13.953Z","comments":true,"path":"2019/12/09/NaNNaNNaNNaN-Batman/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/NaNNaNNaNNaN-Batman/","excerpt":"","text":"NaNNaNNaNNaN-Batman下载附件，得到web100的文本，打开是乱码，大概看了下，将后缀改为HTML，在浏览器里打开，得到一个OK输入框；但是输入没有任何响应；回头再看看代码；可以很明显看到,’’是一个变量，而它的内容就是后面一长串字符(三行绿色部分即’’中间部分)；最后eval()函数执行_;**eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。**此处，eval()并未执行$()函数，而是执行了字符串，导致乱码?:).为了能看到正常源码，将eval()改为alert()；**alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。alert是HTML DOM 中用到的一种脚本语言，它的中文意思是“提醒”。它是JavaScript或VBscript脚本语言中窗口window对象的一个常用方法；其主要用法就是在你自己定义了一定的函数以后，通过执行相应的操作，所弹出对话框的语言。并且alert对话框通常用于一些对用户的提示信息。|alert(message)| ||:——–:|:————-:||参数 |描述||message |要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本）|**即： 1234567891011121314151617181920212223function $()&#123; var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null) &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ **match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(应该是从var后的几个值中挑选几个，组合得到flag)**方法一：审计，变量e需要满足五个条件。长度为16；^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求；所以可以构造出：e==be0f233ac7be98aa在OK输入框中输入可以得到flag；方法二：由于程序已经固定只是在输入时需要检测是否匹配，那么可以直接省去输入匹配部分，直接执行关键组合flag部分；提取如下代码，在控制台执行： 123456789101112131415161718function $()&#123; var e=document.getElementById(\"c\").value; &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Training-WWW-Robots","slug":"Training-WWW-Robots","date":"2019-12-09T01:03:58.000Z","updated":"2019-12-09T03:23:26.042Z","comments":true,"path":"2019/12/09/Training-WWW-Robots/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Training-WWW-Robots/","excerpt":"","text":"Training-WWW-Robotsrobots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。(摘自百度百科)访问robots.txt，发现不允许访问fl0g.php尝试访问/fl0g.php，得到flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Mfw","slug":"Mfw","date":"2019-12-09T00:58:05.000Z","updated":"2019-12-09T03:09:04.472Z","comments":true,"path":"2019/12/09/Mfw/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Mfw/","excerpt":"","text":"Mfw打开链接，几个目录都看了下，发现：可能存在git源码泄露，尝试访问.git目录：利用Githack得到网站源码(直接将GitHack.py拖入cmd,输入执行命令)：在GitHack目录下可以看到网站源码文件夹：在flag.php中只有如下内容： 1234&lt;?php// TODO// $FLAG = '';?&gt; 是将flag.php中的内容注释了，不显在网页上。在index.php中发现关键代码： 12345678910111213&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; **assert()这个函数在php语言中是用来判断一个表达式是否成立。返回true or false;/PHP官方文档是怎么解释的： assert — 检查一个断言是否为 FALSE PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。*/die() 函数输出一条消息，并退出当前脚本；strpos(string,find,start)查找find在字符串string中第一次出现的位置;file_exists() 函数检查文件或目录是否存在。如果指定的文件或目录存在则返回 TRUE，否则返回 FALSE。*如此这般，可以利用assert()函数执行命令，类似sql注入，在数据库中查找，构造url为page=abc’) or system(“cat templates/flag.php”);//{用lww’)闭合前半部分，得到false；之后执行system();//注释掉后面的代码；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Lottery!","slug":"Lottery","date":"2019-12-09T00:49:07.000Z","updated":"2019-12-09T03:14:03.621Z","comments":true,"path":"2019/12/09/Lottery/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Lottery/","excerpt":"","text":"Lottery！随便输入7个数字得到以下结果，并且每次的winning numbers都是不同的，应该为随机数；根据Claim Your Prize中的提示，需要花费$9990000才能买到flag，如果一直猜数字获得余额不太现实，用burpsuite对输入彩票数字验证过程抓包，得到api.php;不过还是不太清楚怎么搞，看了下wp，说是git源码泄露：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。尝试访问：可以利用Githack提取下载源码；(但其实本题直接在附件里给出了网站源码、滑稽.gif)打开之前下载好的源文件：打开api.php文件，可以看到以下验证彩票数字代码： 123456789101112131415161718192021222324252627282930$win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; 可以看到，代码将用户输入的7个数与7个随机数比较，并且用的==(弱类型比较),因为json支持bool数据，所以我们可以直接用true来使==成立；改包：发现已经获得$200000;多提交几余额就够了，buy-&gt;flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-04","slug":"ics-04","date":"2019-12-09T00:28:33.000Z","updated":"2019-12-09T02:18:26.771Z","comments":true,"path":"2019/12/09/ics-04/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/ics-04/","excerpt":"","text":"ics-04本题和之前几题使用了相同的页面，根据提示漏洞位置应该在登录和注册上，随便注册都能成功，但是登录时提示“普通用户登录成功，没什么用”；尝试sql注入，这两个地方并没有什么注入点，看到还有个“忘记密码？”，可以正常使用找回密码，尝试sql注入；利用sqlmap检测，发现存在漏洞；构造命令猜解数据库名：–dbs 枚举数据库管理系统数据库sqlmap -u “http://111.198.29.45:33931/findpwd.php&quot; –data=”username=1” –dbs得到库名结果；库名对每个数据库进行表名猜解；sqlmap -u “http://111.198.29.45:33931/findpwd.php&quot; –data=”username=1” -D cetc004 –tables 对数据库cetc004中表user猜解列名；–columns 枚举DBMS数据库表列sqlmap -u “http://111.198.29.45:33931/findpwd.php&quot; –data=”username=1” -D cetc004 -T user –columns对username和password进行内容查询；–dump 转储数据库管理系统的数据库中的表项sqlmap -u “http://111.198.29.45:33931/findpwd.php&quot; –data=”username=1” -D cetc004 -T user -C “username,password” –dump 由于可以重复注册，于是使用c3tlwDmln23注册，注册成功，登陆后得到flag； 此时对username查询可得到两条结果；第一行为原来的，第二行为刚才注册的，所以漏洞原因为未对用户名重复问题加以过滤，造成数据库查表错误；注：如果觉得打开Kali虚拟机麻烦，可以在Windows上安装一个sqlmap，具体步骤网上都有教程；如果遇到“不是内部或外部命令，也不是可运行的程序 或批处理文件。”时，看一下自己的“起始位置”的路径，是不是没有指定清楚，如果填写的是C:\\Python27\\sqlmap；那么请查看sqlmap下到sqlmap python File是否还有间接文件夹，若有直接加上\\name；或者直接复制改名为sqlmap放在Python27下；删除原来的文件；关于sqlmap使用：https://blog.csdn.net/qq_33530840/article/details/82144515","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"sqli-labs环境搭建","slug":"sqli-labs环境搭建","date":"2019-12-02T02:01:08.000Z","updated":"2019-12-09T05:27:12.083Z","comments":true,"path":"2019/12/02/sqli-labs环境搭建/","link":"","permalink":"https://singlemindedt.github.io/2019/12/02/sqli-labs环境搭建/","excerpt":"","text":"##1.由于版本支持等问题，此次环境安装建议下载Phpstudy2018版本，解压安装(可自定义安装目录)； ##2.下载sqli-labs文件，Github下载解压至Phpstudy2018\\PHPTutorial\\WWW目录下； ##3.更改数据库密码，E:\\PhpStudy2018\\PHPTutorial\\WWW\\sqli-labs-master\\sqli-labs-master\\sql-connections\\db-creds,自己任意设置； ##4.开启Phpstudy2018的Apache和MySql服务; ##5.基本配置完成，打开http://127.0.0.1/sqli-labs-master/，若出现如下页面则搭建成功；[//]: # () ##6.点击Setup/reset Database for labs建立数据库连接，若出现如下页面则搭建完成；[^_^]: # () ##7.访问http://127.0.0.1/sqli-labs-master/ 时，若出现You don’t have permission to access /sqli-labs-master/ on this server.；则打开Phpstudy2018的“其他选项菜单\\打开配置文件\\httpd.conf”;配置为如下情况；[^_^]: # ()同时将“phpstudy设置”设置为“允许目录列表”；至此，sqli-labs环境搭建完成！","categories":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"凯撒密码","slug":"凯撒密码","date":"2019-11-16T14:18:05.000Z","updated":"2019-12-09T00:08:38.858Z","comments":true,"path":"2019/11/16/凯撒密码/","link":"","permalink":"https://singlemindedt.github.io/2019/11/16/凯撒密码/","excerpt":"","text":"凯撒密码 在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。 代码实现 (已知密钥情况下) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int model);//加密函数void Decryption(string M,int key,int model);//解密函数int main()&#123; string C; int key; int model; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Model:\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cin&gt;&gt;model; if(model==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,model); &#125; else if(model==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,model); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int model)&#123; if(model==1) &#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int model)&#123; if(model==2) &#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; 完整版（就是穷举了key） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int mode);//加密函数void Decryption(string M,int key,int mode);//解密函数int main()&#123; string C; int key;//偏移位 int mode; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Mode:(Please enter selection mode！！！)\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cout&lt;&lt;\"3:Keyless Decryption\"&lt;&lt;endl; cin&gt;&gt;mode; if(mode==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,mode); &#125; else if(mode==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,mode); &#125; else if(mode==3) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; for(int k=1;k&lt;26;k++) Decryption(C,k,mode); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int mode)&#123; //if(mode==1) //&#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; //&#125; //else //cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int mode)&#123; //if(mode==2) //&#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; cout&lt;&lt;endl; //&#125; // else // cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125;","categories":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/tags/密码学/"}]},{"title":"初探栈溢出","slug":"初探栈溢出","date":"2019-10-10T14:09:17.000Z","updated":"2019-10-10T15:56:49.921Z","comments":true,"path":"2019/10/10/初探栈溢出/","link":"","permalink":"https://singlemindedt.github.io/2019/10/10/初探栈溢出/","excerpt":"","text":"这里给出一个简单的exe文件，实现的功能为：让用户键入密码，程序将之与固定密码(1234567)进行比较，如果错误继续键入，成功则提示“Congratulation! You have passed the verification!” 将程序拖入IDA，在左边窗口有函数名称列表，找到_main函数双击，可以看到其程序流程图：伪代码： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+0h] [ebp-8h]//变量v4 while ( 1 ) &#123; sub_4010A7(aPleaseInputPas, v4);//函数sub_4010A7需要调用两个参数aPleaseInputPas, v4 scanf(aS, &amp;v4);//输入v4 if ( !sub_401000(&amp;v4) )//若sub_401000(&amp;v4)==0调用 sub_4010A7(aIncorrectPassw, v4) break; sub_4010A7(aIncorrectPassw, v4); &#125; return sub_4010A7(aCongratulation, v4);&#125; 我们接下来查看 判断函数sub_401000： 1234567891011121314int __cdecl sub_401000(const char *a1)&#123; return strcmp(a1, a1234567);&#125;/*比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。*/ 查看sub_4010A7： 12345678910int __cdecl sub_4010A7(int a1, int a2)&#123; int v2; // edi int v3; // ebx v2 = _stbuf(&amp;stru_4080E0); v3 = sub_401E34(&amp;stru_4080E0, a1, (int)&amp;a2); _ftbuf(v2, &amp;stru_4080E0); return v3;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"re","slug":"re","permalink":"https://singlemindedt.github.io/tags/re/"}]},{"title":"ics-05","slug":"ics-05","date":"2019-10-05T02:53:52.000Z","updated":"2019-12-09T03:04:08.085Z","comments":true,"path":"2019/10/05/ics-05/","link":"","permalink":"https://singlemindedt.github.io/2019/10/05/ics-05/","excerpt":"","text":"ics-05题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统点击链接进入“工控云管理系统”，根据题目要求只能点击“设备维护中心”；得到如下页面：除了index.php页面，没有其他有效信息，查看源码：可以看到?page=indedx;由于出现page这个get参数，我们可以尝试一下是否存在文件包含源码漏洞； **本地文件包含漏洞（LFI漏洞）的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞:主要涉及到的函数：include(),require()、include_once(),require_once()magic_quotes_gpc()、allow_url_fopen()、allow_url_include()、move_uploaded_file() 、readfile() file()、and file_get_contents()、upload_tmp_dir()、post_max_size()、and max_input_time()等典型漏洞代码：&lt;!–?php include($_GET[‘pages’].‘.php’); ?–&gt;参考文章：https://blog.csdn.net/qq_29419013/article/details/81202358**尝试读取index.php的页面源码，通过php内置协议直接读取代码：?page=php://filter/read=convert.base64-encode/resource=index.php得到很长一串base64编码，解码得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;设备维护中心&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;设备列表&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"开|关\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: '设备名', templet: '#nameTpl' &#125;, &#123; field: 'area', title: '区域' &#125;, &#123; field: 'status', title: '维护状态', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: '设备开关', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块 //监听导航点击 element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 源码审计，得到如下可能存在问题的关键部分： 123456789101112131415161718192021&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 可以看到preg_replace函数（执行一个正则表达式的搜索和替换），可以利用preg_replace函数的命令执行漏洞在—/e模式下（即参数pattern输入为/e时）将replacement参数当作PHP代码执行（php5.5版本后已经废弃）；**关于preg_replace：https://www.php.net/manual/zh/function.preg-replace.php**先来测试一下，看能不能输出关于PHP配置的信息；构造payload：/index.php?pat=/lww/e&amp;rep=phpinfo()&amp;sub=lww同时还得伪造X_FORWARDED_FOR=== ‘127.0.0.1’；构造：验证成功！接下来尝试读取文件目录，利用system（）函数；构造payload：/index.php?pat=/lww/e&amp;rep=system（“ls”）&amp;sub=lwwcd查看s3chahahaDir文件system(“cd%20s3chahahaDir%26%26ls”):**%20url解释为空格、%26为&amp;** 得到flag文件，cd查看flag文件：得到flag.php，使用cat查看内容：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-10-04T06:34:42.000Z","updated":"2019-10-04T07:18:57.002Z","comments":true,"path":"2019/10/04/正则表达式/","link":"","permalink":"https://singlemindedt.github.io/2019/10/04/正则表达式/","excerpt":"","text":"https://c.runoob.com/front-end/854","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://singlemindedt.github.io/tags/正则表达式/"}]},{"title":"PHP学习","slug":"PHP学习","date":"2019-09-30T14:44:09.000Z","updated":"2019-10-03T13:33:07.472Z","comments":true,"path":"2019/09/30/PHP学习/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/PHP学习/","excerpt":"","text":"文章内容主要来自W3School，仅作为学习记录使用。 在 PHP 创建用户定义函数用户定义的函数声明以单词 “function” 开头： 语法123function functionName() &#123; 被执行的代码;&#125; 注释：函数名能够以字母或下划线开头（而非数字）。注释：函数名对大小写不敏感。提示：函数名应该能够反映函数所执行的任务。* 获得数组的长度 - count() 函数count() 函数用于返回数组的长度（元素数） 1234&lt;?php$cars=array(\"porsche\",\"BMW\",\"Volvo\");echo count($cars);?&gt; PHP 关联数组关联数组是使用您分配给数组的指定键的数组。有两种创建关联数组的方法： 12345$age=array(\"Bill\"=&gt;\"35\",\"Steve\"=&gt;\"37\",\"Elon\"=&gt;\"43\");或者：$age['Bill']=\"63\";$age['Steve']=\"56\";$age['Elon']=\"47\"; 随后可以在脚本中使用指定键： 123456&lt;?php$age=array(\"Bill\"=&gt;\"63\",\"Steve\"=&gt;\"56\",\"Elon\"=&gt;\"47\");echo \"Elon is \" . $age['Elon'] . \" years old.\";?&gt;Elon is 47 years old. PHP - 数组的排序函数在本节中，我们将学习如下 PHP 数组排序函数： 123456sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 GET vs. POSTGET 和 POST 都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, key3 =&gt; value3, …)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。GET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。$_GET 是通过 URL 参数传递到当前脚本的变量数组。$_POST 是通过 HTTP POST 传递到当前脚本的变量数组。 何时使用 GET？通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大约 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。GET 可用于发送非敏感的数据。注释：绝不能使用 GET 来发送密码或其他敏感信息！ 何时使用 POST？通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。提示：开发者偏爱 POST 来发送表单数据。 表单元素表单的 HTML 代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; 当提交此表单时，通过 method=”post” 发送表单数据。什么是 $_SERVER[“PHP_SELF”] 变量？$_SERVER[“PHP_SELF”] 是一种超全局变量，它返回当前执行脚本的文件名。因此，$_SERVER[“PHP_SELF”] 将表单数据发送到页面本身，而不是跳转到另一张页面。这样，用户就能够在表单页面获得错误提示信息。 什么是 htmlspecialchars() 函数？htmlspecialchars() 函数把特殊字符转换为 HTML 实体。这意味着 &lt; 和 &gt; 之类的 HTML 字符会被替换为 &lt; 和 &gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。 关于 PHP 表单安全性的重要提示$_SERVER[“PHP_SELF”] 变量能够被黑客利用！如果您的页面使用了 PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。提示：跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。假设我们的一张名为 “test_form.php” 的页面中有如下表单： 1&lt;form method=\"post\" action=\"&lt;?php echo $_SERVER[\"PHP_SELF\"];?&gt;\"&gt; 现在，如果用户进入的是地址栏中正常的 URL：”http://www.example.com/test_form.php&quot;，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"&gt; 到目前，一切正常。不过，如果用户在地址栏中键入了如下 URL： 1http://www.example.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E 在这种情况下，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"/&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 这段代码加入了一段脚本和一个提示命令。并且当此页面加载后，就会执行 JavaScript 代码（用户会看到一个提示框）。这仅仅是一个关于 PHP_SELF 变量如何被利用的简单无害案例。您应该意识到 标签内能够添加任何 JavaScript 代码！黑客能够把用户重定向到另一台服务器上的某个文件，该文件中的恶意代码能够更改全局变量或将表单提交到其他地址以保存用户数据，等等。如果避免 $_SERVER[\"PHP_SELF\"] 被利用？通过使用 htmlspecialchars() 函数能够避免 $_SERVER[\"PHP_SELF\"] 被利用。表单代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; htmlspecialchars() 函数把特殊字符转换为 HTML 实体。现在，如果用户试图利用 PHP_SELF 变量，会导致如下输出： 1&lt;form method=\"post\" action=\"test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;\"&gt; 无法利用，没有危害！ 通过 PHP 验证表单数据我们要做的第一件事是通过 PHP 的 htmlspecialchars() 函数传递所有变量。在我们使用 htmlspecialchars() 函数后，如果用户试图在文本字段中提交以下内容： 123&lt;script&gt;location.href('http://www.hacked.com')&lt;/script&gt;- 代码不会执行，因为会被保存为转义代码，就像这样：&amp;lt;script&amp;gt;location.href('http://www.hacked.com')&amp;lt;/script&amp;gt; 现在这条代码显示在页面上或 e-mail 中是安全的。在用户提交该表单时，我们还要做两件事：（通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行）（通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\\）接下来我们创建一个检查函数（相比一遍遍地写代码，这样效率更好）。我们把函数命名为 test_input()。现在，我们能够通过 test_input() 函数检查每个 $_POST 变量，脚本是这样的： 1234567891011121314151617181920实例&lt;?php// 定义变量并设置为空值$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; $name = test_input($_POST[\"name\"]); $email = test_input($_POST[\"email\"]); $website = test_input($_POST[\"website\"]); $comment = test_input($_POST[\"comment\"]); $gender = test_input($_POST[\"gender\"]);&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt; 请注意在脚本开头，我们检查了表单是否使用 $_SERVER[\"REQUEST_METHOD\"] 进行提交。如果 REQUEST_METHOD 是 POST，那么表单已被提交 - 并且应该对其进行验证。如果未提交，则跳过验证并显示一个空白表单。不过，在上面的例子中，所有输入字段都是可选的。即使用户未输入任何数据，脚本也能正常工作。下一步是制作必填输入字段，并创建需要时使用的错误消息。 关于正则表达式：记-正则表达式 PHP 表单验证 - 验证 E-mail 和 URLPHP - 验证名字以下代码展示的简单方法检查 name 字段是否包含字母和空格。如果 name 字段无效，则存储一条错误消息： 1234$name = test_input($_POST[\"name\"]);if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"只允许字母和空格！\"; &#125; 注释：preg_match() 函数检索字符串的模式，如果模式存在则返回 true，否则返回 false。 PHP - 验证 E-mail以下代码展示的简单方法检查 e-mail 1234$email = test_input($_POST[\"email\"]);if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"无效的 email 格式！\"; &#125; PHP - 验证 URL以下代码展示的方法检查 URL 地址语法是否有效（这条正则表达式同时允许 URL 中的斜杠）。如果 URL 地址语法无效，则存储一条错误消息： 12345$website = test_input($_POST[\"website\"]);if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i\",$website)) &#123; $websiteErr = \"无效的 URL\"; &#125; PHP - 验证 Name、E-mail、以及 URL现在，脚本是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051实例&lt;?php// 定义变量并设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = \"\";$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; if (empty($_POST[\"name\"])) &#123; $nameErr = \"Name is required\"; &#125; else &#123; $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"Only letters and white space allowed\"; &#125; &#125; if (empty($_POST[\"email\"])) &#123; $emailErr = \"Email is required\"; &#125; else &#123; $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"Invalid email format\"; &#125; &#125; if (empty($_POST[\"website\"])) &#123; $website = \"\"; &#125; else &#123; $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/% =~_|]/i\",$website)) &#123; $websiteErr = \"Invalid URL\"; &#125; &#125; if (empty($_POST[\"comment\"])) &#123; $comment = \"\"; &#125; else &#123; $comment = test_input($_POST[\"comment\"]); &#125; if (empty($_POST[\"gender\"])) &#123; $genderErr = \"Gender is required\"; &#125; else &#123; $gender = test_input($_POST[\"gender\"]); &#125;&#125;?&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"CumtCTF2019华为杯","slug":"CumtCTF2019华为杯","date":"2019-09-30T07:38:23.000Z","updated":"2019-10-04T16:49:46.497Z","comments":true,"path":"2019/09/30/CumtCTF2019华为杯/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/CumtCTF2019华为杯/","excerpt":"","text":"Web签到题点开链接为seed和hash参数的提交框，尝试admin，admin，返回Fail…;查看响应，发现有payload，提示访问index.php?source=1发现php代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpfunction gen_secured_random() &#123; // cause random is the way $a = rand(1337,2600)*42; $b = rand(1879,1955)*42; $a &lt; $b ? $a ^= $b ^= $a ^= $b : $a = $b; return $a+$b;&#125;function secured_hash_function($plain) &#123; // cause md5 is the best hash ever $secured_plain = sanitize_user_input($plain); return md5($secured_plain);&#125;function sanitize_user_input($input) &#123; // cause someone told me to never trust user input $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除不是a-zA-Z0-9） return $secured_input;&#125;/*&lt;?php // cause someone told me to never trust user input $input='&lt;&lt;&lt;&gt;&gt;&gt;.AZ.,,assddf23232????'; $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除非a-zA-Z0-9） echo $secured_input; ?&gt; run:AZassddf23232*/if (isset($_GET['source'])) &#123; show_source(__FILE__); die();&#125;require_once \"secret.php\";if (isset($_POST['s']) &amp;&amp; isset($_POST['h'])) &#123;//输入s,h //isset在php中用来判断变量是否声明，该函数返回布尔类型的值，即true/false。 //isset只能用于变量，因为传递任何其它参数都将造成解析错误 $s = sanitize_user_input($_POST['s']);//s=输入s $h = secured_hash_function($_POST['h']);//h=MD5（h） $r = gen_secured_random();//r=随机数 if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) //弱类型比较 &#123;//连接s和r，即：用户输入s+随机数==用户输入h //*****此处利用0e漏洞，即0e+r==(填写hash为0开头字符) print \"Well done! Here is your flag: \".$flag; &#125; else &#123; print \"Fail...\"; &#125; &#125; else &#123; print \"&lt;p&gt;Hum ...&lt;/p&gt;\"; &#125;&#125;?&gt; 1s=0e1&amp;h=QNKCDZO&amp;submit=Check Misc两岁半的猪打开压缩包为三只猪png，利用stegsolve发下有二维码； 寻找你的Key得到压缩包，解压发现需要密码，用binwalk文件分离，得到另外一个压缩包0.zip和kEy.exe将kEy.exe放进winhex,得到逆序图片base64编码逆序编码，转图片，得到二维码 委屈的兔兔将图片拖入winhex，得到Unicode 编码，直接百度解码得到 flag 302？还有其他？看到302，抓包，发现存在1ndex.php,访问1ndex.php发现RAW中有key和base64编码后的png图片，转图片，没有什么发现，直接站长工具解密带隐藏信息的图片，输入密码，得到flag；（此处做一补充，当时利用binwalk -e分离文件得到一个空文本文件和一个zlib文件，利用脚本解密zlib文件应该也能成功，不过当时未跑出来）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"}]},{"title":"暴跳老板+Flag在哪？","slug":"暴跳老板","date":"2019-09-25T14:49:02.000Z","updated":"2019-12-09T05:27:34.710Z","comments":true,"path":"2019/09/25/暴跳老板/","link":"","permalink":"https://singlemindedt.github.io/2019/09/25/暴跳老板/","excerpt":"","text":"暴跳老板随便输入内容，得到弹窗要以POST方式用Dear发邮件，抓包：[^_^]: # ()直接在postText后添加Dear=MyBoss，发包得到flag Flag在哪？burpsuit抓包，发现有五个跳转页面，但是都没有flag:)/where_is_flag.php/flag.php/I_have_a_frog.php/I_have_a_flag.php/no_flag.php看看大佬们骚操作，要组合一下 orz ，flagfrog.php,发包得到flag。 美味的饼干点击链接得到一个登录页面，尝试admin，111提示“登录成功，欢迎admin！”，但是并没有什么有用的信息。查看源代码，提示“只有admin才有flag”。检查请求头，有可疑Cookie： 1login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D base64解码： 1ee11cbb19052e40b07aac0ca060c23ee MD5解码：user 那么意思基本就清楚了，应该是要Cookie信息为admin，才能够得到flag adminMD5： 121232f297a57a5a743894a0e4a801fc3 base64: 1MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM= 更改Cookie，重发，在响应里看到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"最大子段和","slug":"最大子段和","date":"2019-09-24T14:18:31.000Z","updated":"2019-09-24T14:22:04.803Z","comments":true,"path":"2019/09/24/最大子段和/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最大子段和/","excerpt":"","text":"问题D：最大子段和题目描述给定n 个整体组成的序列a1，a2，… an，求子段和a i + a i + 1 + … + a j（子段可为空集）的替代。 输入包含多组测试数据。第一行为一个整数T（1 &lt;= T &lt;= 20），代表测试数据个数。 每组测试数据第一行为一个整数n ，代表有n 个整数（1 &lt;= n &lt;= 10000）。 接下来一行有n 个数x（-1000 &lt;= x &lt;= 1000）。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int maxsum(int b[],int n)&#123; int tempsum=0; int Maxsum=0; for(int i=0;i&lt;n;i++) &#123; tempsum=(tempsum+b[i])&gt;b[i]?(tempsum+b[i]):b[i]; if(tempsum&gt;Maxsum) Maxsum=tempsum; &#125; return Maxsum;&#125;int main()&#123; int T; int n; while(cin&gt;&gt;T&gt;&gt;n) &#123; int a[10000]=&#123;0&#125;; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int SUM=maxsum(a,n); cout&lt;&lt;SUM&lt;&lt;endl; return 0; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"汽水瓶","slug":"汽水瓶","date":"2019-09-24T09:41:42.000Z","updated":"2019-09-24T14:16:32.134Z","comments":true,"path":"2019/09/24/汽水瓶/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/汽水瓶/","excerpt":"","text":"问题 E: 汽水瓶【25】题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0 样例输入1234310810 样例输出1231540 代码：```C++ #includeusing namespace std;int main(){ int n=0; while(cin&gt;&gt;n) { int m=0;//最多可喝 if(n==0) { continue; } if(n==2)//第一次忘了这个初次n=2的情况 { cout&lt;&lt;1&lt;&lt;endl; continue;//此处若无会多输出 0 } else while(n&gt;2) { int bn=n; n=n/3+n%3; m+=bn/3; if(n==2) { m++; break; } } cout&lt;&lt;m&lt;&lt;endl; } return 0;}/*由规律可得如下方法： #includeusing namespace std;int main(){int num = 0; while (cin&gt;&gt;num) if (num == 0) continue; else cout&lt;&lt;num/2&lt;&lt;endl;//都是整除结果 return 0;}*/","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2019-09-24T08:02:54.000Z","updated":"2019-09-24T08:07:31.137Z","comments":true,"path":"2019/09/24/最长公共子序列/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最长公共子序列/","excerpt":"","text":"问题 A: 最长公共子序列时间限制: 1 Sec 内存限制: 32 MB 题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string x; string z; int dp[105][105] =&#123;0&#125;; while(cin&gt;&gt;x&gt;&gt;z) &#123; int len1 = x.size();//8 int len2 = z.size();//9 for(int i =1; i &lt;= len1; i++) for(int j =1; j &lt;=len2; j++) if(x[i-1]==z[j-1])//i,j&gt;0,xi=zj dp[i][j] =dp[i - 1][j - 1] + 1; else dp[i][j]= max(dp[i][j-1], dp[i-1][j]);//i,j&gt;0,xi!=yj cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-09-23T16:13:50.000Z","updated":"2019-09-23T16:23:38.411Z","comments":true,"path":"2019/09/24/文件包含漏洞/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/文件包含漏洞/","excerpt":"","text":"php://filter（本地磁盘文件进行读取）元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。 用法： 123?filename=php://filter/convert.base64-encode/resource=xxx.php ?filename=php://filter/read=convert.base64-encode/resource=xxx.php 一样。 条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include； MOCTF上这道文件包含题，直接 1?file=php://filter/convert.base64-encode/resource=flag.php 得到一串base64编码解码得到flag 关于文件包含漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"}]},{"title":"NewsCenter","slug":"攻防世界之Web高手进阶-NewsCenter","date":"2019-09-10T15:45:00.000Z","updated":"2019-09-27T15:42:02.629Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-NewsCenter/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-NewsCenter/","excerpt":"","text":"打开链接，出现如下页面： 尝试是否为sql注入：抓包：利用sqlmap,","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-06","slug":"攻防世界之Web高手进阶-ics-06","date":"2019-09-10T09:00:00.000Z","updated":"2019-09-10T15:45:13.006Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-ics-06/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-ics-06/","excerpt":"","text":"题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。进入页面只有报表中心可以点击，有一个输入框，各种fuzzing，没成功，后来才知道直接爆破就行。。。 关于爆破","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Cat","slug":"攻防世界之Web高手进阶-cat","date":"2019-09-09T16:00:00.000Z","updated":"2019-09-10T14:49:06.470Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-cat/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-cat/","excerpt":"","text":"仅给出了这样一个页面： 输入cat，得到： 123456PING cat.ad-world-198302431-4658.rancher.internal (10.42.197.21) 56(84) bytes of data.64 bytes from b4fccc7cf554 (10.42.197.21): icmp_seq=1 ttl=64 time=0.045 ms--- cat.ad-world-198302431-4658.rancher.internal ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms 并在URL中如此传参： 1http://111.198.29.45:35113/index.php?url=cat 输入127.0.0.1： 123456PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.061 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.061/0.061/0.061/0.000 ms 尝试使用命令连接符/管道命令，均被屏蔽；目前仅知道，输入框通过用户输入进行GET方式传参；(此处请跳转文末 orz)那么只能从url入手了，看看有没有可能爆出一些有用的信息；测试发现超过ASCll可打印字符之外的url编码都会报错，比如键入http://111.198.29.45:35113/index.php?url=%8c ：给出报错信息：可以明显看到使用的是Django框架； 查看配置文件信息：settings.py在报错信息中搜索database，发现的到有关数据库内容：参考：通过http://111.198.29.45:35113/index.php?url=@/opt/api/database.sqlite3 得到数据库内容：查找ctf关键字： 源码里就是GET啊，那这个又是啥？？？！orz orz orz","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Win10安装pygame","slug":"pygame_install","date":"2019-09-09T15:37:45.000Z","updated":"2019-09-10T08:33:21.440Z","comments":true,"path":"2019/09/09/pygame_install/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/pygame_install/","excerpt":"","text":"检查pip是否安装，查看Python安装版本； 2. 1pip install wheel 3. 1pip install Pygame==1.9.6","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://singlemindedt.github.io/tags/tools/"}]},{"title":"Byte CTF 字节跳动网络安全攻防大赛","slug":"Byte_CTF","date":"2019-09-09T08:36:00.000Z","updated":"2019-09-09T08:42:09.927Z","comments":true,"path":"2019/09/09/Byte_CTF/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/Byte_CTF/","excerpt":"","text":"betgame给了提示，nc 112.125.25.81 9999 知识补充：nc即netcat，被誉为网络安全界的“瑞士军刀”。透过使用TCP或UDP协议的网络连接去读写数据。它被设计成一个稳定的后门(back-end)工具，能够直接由其它程序和脚本轻松驱动。同时，它也是一个功能强大的网络调试和探测工具，能够建立你需要的几乎所有类型的网络连接. 使用之前首先我们要弄明白netcat的工作原理,其实netcat的原理很简单,它就是从网络的一端读入数据,然后输出到网络的另一端,它可以使用tcp 和udp协议.之所以叫做netcat,因为它是网络上的cat,想象一下cat的功能,读出一个文件的内容,然后输出到屏幕上(默认的stdout是屏幕,当然可以重定向到其他地方).netcat也是如此,它读取一端的输入,然后传送到网络的另一端。ncat/nc 既是一个端口扫描工具，也是一款安全工具，还能是一款监测工具，甚至可以做为一个简单的 TCP 代理。细节 实际操作：可以将nc作为聊天工具利用，本地server1上传nc 122.125.25.81 9999Server2启动监听9999端口：nc -lp 9999至此就可以简单交互，本题提示要30次全赢，找规律，对应输入即可； Linux nc命令详解","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://singlemindedt.github.io/tags/Misc/"}]},{"title":"CTF中常见编码","slug":"CTF中常见编码总结","date":"2019-09-08T01:05:00.000Z","updated":"2019-09-08T11:03:39.953Z","comments":true,"path":"2019/09/08/CTF中常见编码总结/","link":"","permalink":"https://singlemindedt.github.io/2019/09/08/CTF中常见编码总结/","excerpt":"","text":"ASCII码表 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 编码方法 因为1位二进制数可以表示（2^1=）2种状态：0、1；而2位二进制数可以表示（2^2）=4种状态：00、01、10、11；依次类推，7位二进制数可以表示（2^7=）128种状态，每种状态都唯一地编为一个7位的二进制码，对应一个字符（或控制码），这些码可以排列成一个十进制序号0～127。所以，7位ASCII码是用七位二进制数进行编码的，可以表示128个字符。 第0～32号及第127号(共34个)是控制字符或通讯专用字符，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等； ASCII码大致可以分作三部分组成：第一部分是：ASCII非打印控制字符第二部分是：ASCII打印字符第三部分是：扩展ASCII打印字符 第一部分：ASCII非打印控制字符表ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31） 第二部分：ASCII打印字符数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表 DELETE 命令。（参详ASCII码表中32-127） 第三部分：扩展ASCII打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。 特征特点：用1个字节的8位数来编码英文字符集，即所有字母数字等英文符号可以用二进制数、十进制、十六进制来表示。 Unicode编码Unicode是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 UTF-8UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：|Unicode编码(十六进制)|UTF-8 字节流(二进制)||:——–:|:————-:|| 000000-00007F | 0xxxxxxx || 000080-0007FF | 110xxxxx 10xxxxxx || 000800-00FFFF | 1110xxxx 10xxxxxx 10xxxxxx|| 010000-10FFFF | 11110xxx10xxxxxx10xxxxxx10xxxxxx|UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。 [UTF-8\\UTF-32]UTF-8\\UTF-32 Unicode一般有四种表示形式 &amp;#x [Hex] &#x0054;&#x0068;&#x0065; &amp;# [Decimal] &#00084;&#00104;&#00101; \\U [Hex] \\U0054\\U0068\\U0065 \\U+ [Hex] \\U+0054\\U+0068\\U+0065 特征特点：国际标准字符，将全球的各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台文本信息的转换，当编码和解码的字符集出现不一致的时候就会出现乱码。 URL编码url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。不管哪种情况，在服务器端的表单输入格式样子象这样：theName=Ichabod+Crane&amp;gender=male&amp;status=missing&amp; ;headless=yesURL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%后跟两位十六进制数来替换非ASCII字符。 编码规则URL编码遵循下列规则： 每对name/value由&amp;；符分开；每对来自表单的name/value由=符分开。如果用户没有输入值给这个name，那么这个name还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位ASCII，如汉字）将以百分符%用十六进制编码，当然也包括象 =,&amp;；，和 % 这些特殊的字符。其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如： “\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。 空格字符，ascii 码是 32，对应16 进制是‘20’，那么 urlencode 编码结果是:%20。 URL编码平时是用不到的，因为IE会自动将输入到地址栏的非数字字母转换为url编码。曾有人提出数据库名字里带上“#”以防止被下载，因为IE遇到#就会忽略后面的字母。破解方法很简单——用url编码%23替换掉#。 特征特点：字符ASCII码的十六进制，并在前面加上% URL原理、URL编码、URL特殊字符 base64编码Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。 Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。 Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。 Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 特征：密文由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个 规则 把3个字节变成4个字节。 每76个字符加一个换行符。 最后的结束符也要处理。 字符串转为2进制，每3个8位二进制转化为4个6位二进制，六位二进制转化为十进制，根据十进制数值在base64编码表中获取字符。Base64编码将串起来的二进制以6位进行分割.所以分切之前的二进制位数应该是24的倍数(即6,8的最小公倍数).如果不足24位,则在编码后数据后面添加”=”(=为填充字符)例子1转换前 11111111, 11111111, 11111111 （二进制）转换后 00111111, 00111111, 00111111, 00111111 （二进制）上面的三个字节是原文，下面的四个字节是转换后的Base64编码，其前两位均为0。转换后，我们用一个码表来得到我们想要的字符串（也就是最终的Base64编码），这个表是这样的：（摘自RFC2045）转换表： 例子2转换前 10101101,10111010,01110110转换后 00101011, 00011011 ,00101001 ,00110110十进制 43 27 41 54对应码表中的值 r b p 2所以上面的24位编码，编码后的Base64值为 rbp2解码同理，把 rbq2 的二进制位连接上再重组得到三个8位值，得出原码。 base32编码Base32使用了ASCII编码中可打印的32个字符(大写字母AZ和数字27)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组,由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位,则在编码后数据补充”=”,一个”=”相当于一个组(5个二进制位),编码后的数据是原先的8\\5倍. 特征：密文由32个字符（A-Z,2-7)组成，末尾可能会有‘=’，但最多有6个 base16 base16是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过base16编码后会变为2个字符，长度增加一倍。 将数据转换为二进制数，不足8比特位高位补0.然后将所有的二进制全部串起来,4个二进制位为一组,转化成对应十进制数,根据十进制数值找到Base16编码表里面对应的字符.Base16是4个比特位表示一个字符,所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符,现在转化成两个字符.数据量是原先的2倍,不需要补’=’ 特征：密文由16个字符（0-9,A-F）组成 数值 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 字符 0 1 2 3 4 5 6 7 8 9 A B C D E F","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://singlemindedt.github.io/tags/编码/"}]},{"title":"攻防世界之Web新手（7-12）","slug":"攻防世界之Web新手（7-12）","date":"2019-09-05T13:09:03.000Z","updated":"2019-09-05T14:09:35.321Z","comments":true,"path":"2019/09/05/攻防世界之Web新手（7-12）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/05/攻防世界之Web新手（7-12）/","excerpt":"","text":"simple_js题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。打开链接如图： X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123得到下图提示：再加一条Referer:https://www.google.com 得到flag。由于每次添加都要重新输入，这里可以利用Repeater功能：得到：可以在左边直接编辑Request—&gt;右侧得到Response：Response—&gt;Flag! 自己编辑的时候注意Target的格式：去掉请求协议http:// URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。根据弹窗的提示，用户名必须是admin将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) —————————-正常解法———————-用Burp Suite对它进行密码爆破，可以先试着输入username=admin和password=11111,以确定爆破位置。Action—&gt;send to Intruder基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。2、由于username规定用admin；简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。开始爆破：可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。上传木马拿webshell的方法汇总图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件）就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功：选择双击：看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;*实际操作： 试着使用命令连接符，查看目录发现有home目录，看看里面有啥：发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下：得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值尝试post传值：得到flag: simple_php##题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。打开链接：很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url:","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Images","slug":"images","date":"2019-09-04T09:37:45.000Z","updated":"2019-09-05T14:33:05.157Z","comments":true,"path":"2019/09/04/images/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/images/","excerpt":"","text":"Inset demo …","categories":[],"tags":[]},{"title":"攻防世界之Web新手（1-6）","slug":"攻防世界之Web新手（1-6）","date":"2019-09-04T07:11:48.415Z","updated":"2019-09-04T09:49:49.710Z","comments":true,"path":"2019/09/04/攻防世界之Web新手（1-6）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/攻防世界之Web新手（1-6）/","excerpt":"","text":"view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下：试试右键的确不管用了，直接F12，找到flag 另外还可以通过view-source：url查看源代码： 其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？知识补充： 两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc实际操作：打开网址，得到如下要求&lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白；在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txtf1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充：Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php”根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"代码审计","slug":"代码审计ONE","date":"2019-09-03T14:35:18.000Z","updated":"2019-09-04T08:46:22.694Z","comments":true,"path":"2019/09/03/代码审计ONE/","link":"","permalink":"https://singlemindedt.github.io/2019/09/03/代码审计ONE/","excerpt":"","text":"PHP大法（来源：实验吧 解题链接： http://ctf5.shiyanbar.com/DUTCTF/index.php）点开链接只有如上一句话。根据提示 直接访问： index.php.txt （即：http://ctf5.shiyanbar.com/DUTCTF/index.php.txt）得到如下页面：分析代码： 1234567891011121314151617 &lt;?php if(eregi(\"hackerDJ\",$_GET[id])) &#123; //对id进行字符串匹配，若$_GET[id]中有hacker DJ则 //出not allowed!并终止正在执行的进程; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); //urldecode对字符串进行URL解码;将解码后的//$_GET[id]赋值给$_GET[id]; if($_GET[id] == \"hackerDJ\") //若$_GET[id]的值等于hackerDJ，输出Access granted! //并给出flag: *****************&#125; &#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\"; &#125; ?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 12345678$_GET说明通过 URL 参数传递给当前脚本的变量的数组Example #1$_GET范例 &lt;?php echo 'Hello ' . htmlspecialchars($_GET[\"name\"]) . '!'; ?&gt;假设用户访问的是 http://example.com/?name=Hannes以上例程的输出类似于： Hello Hannes! 解题思路：有$_GET[id] 所以应该是可以用 ?id= 来构造URLid变量是一个url解码函数前不包含hackerDJ，url解码函数后为hackerDJ的变量，即id在进入url解码函数前必须是hackerDJ的url编码形式 注意：由于在浏览器输入url后会进行一次decode，这段代码中又进行一次decode，所以应对hackerDJ进行两次encode。只进行一次encode，浏览器自动解码后即为hackerDJ,被eregi()拦住，所以要进行二次编码，即对%68%61%63%6B%65%72%44%4A进行url编码。 ① http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%68%61%63%6B%65%72%44%4A ② http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 或者直接对其中的一个字母进行二次编码： h –&gt; %68 –&gt; %2568构造url: index.php?id=%2568ackerDJ Very easy打开链接直接得到如下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 分析：如果$what等于flag,则给出flag。解决：http://123.206.87.240:8002/get/?what=flag 得到flag。 Experiment 1打开链接直接出现PHP代码： 123456789101112131415&lt;?php include \"flag.php\"; highlight_file(__FILE__); if (isset($_GET['money'])) &#123; $money=$_GET['money']; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money)) &#123; echo $flag; echo \"&lt;!--By:daoyuan--&gt;\"; &#125; else echo \"Wrong Answer!\"; &#125; else echo \"Wrong Answer!\";?&gt; 代码分析：第一行:告诉我们flag应该就在flag.php中第二行：highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。 提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。 注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！ 语法：highlight_file(filename,return)filename 必需。规定要显示的文件。return 可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。返回值如果 return 参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。否则，如果成功则返回 TRUE，如果失败则返回 FALSE。If条件：$money的长度&lt;=4；同时&gt;time()；同时不是数组{time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。此处我们直接将其理解为一个很大的数}==PHP中，字符串开头以xex开头，x代表数字。会被转换成科学计数法。 如1e9 == 1×10^9==解决：直接用xex格式如：http://119.23.73.3:5001/web6/?money=10e9 直接得到flag Experiment 2打开链接页面中只有一句话“好像少了点什么”，试着在url后添加index.php~即http://119.23.73.3:5001/web5/index.php~。打开页面发现什么都没有，查看源文件发现果然有PHP文件： 分析代码：9：给出$flag的值为我们最终需要的结果 1moctf&#123;**************&#125; 11：{PHP的isset()函数 一般用来检测变量是否设置格式：bool isset ( mixed var [, mixed var [, …]] )功能：检测变量是否设置返回值：若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE版本：PHP 3, PHP 4, PHP 5更多说明：使用 unset() 释放变量之后，它将不再是 isset()。PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。检测常量是否已设置可使用 defined() 函数。} 1234If条件下对变量$_GET['a']和$_GET['b']赋值，并将其赋值给$a,$b.若$a等于$b则打印Wrong Answer!否则在条件md5($a)==md5($b)下给出$flag，否则打印Wrong Answer！**即此代码的意思时要我们对提供$a,$b使得其值不同，但MD5值相同。** ***弱类型比较——“==”类型转换的规则1、字符串和数字比较，字符串会被转换成数字。 “admin”==0 (true) admin被转换成数字，由于admin是字符串，转换失败，int(admin)=0，所以 比较结果是true。2、混合字符串转换成数字，看字符串的第一个。 “1admin”==1 “2admin”==23、字符串开头以xex开头，x代表数字。会被转换成科学计数法。 1e9 == 1×10^9 注： 12\"admin1\"==1 //false\"admin1\"==0 //true 参考网上资料：当一个字符串当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内则：该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 所以我们可以直接找符合xex格式的MD5原参{MD5 算法自诞生之日起，就有很多人试图证明和发现它的不安全之处，即存在碰撞（在对两个不同的内容使用 MD5算法运算的时候，有可能得到一对相同的结果值）–百科}md5的碰撞，在PHP的数的处理中，类似0开头的字符串会被转换成0，因此有md5碰撞。 MD5值(哈希值)相等的问题可以用哈希值碰撞，也可以用数组绕过，如： 1`username[]=1&amp;password[]=2. 解决：http://119.23.73.3:5001/web5/**?a=QNKCDZO&amp;b=s878926199a** ,直接得到flag。 1md5('**QNKCDZO**')==md5('**s878926199a** ')---&gt;True Experiment 2.1题目给出了php代码： 12345678910111213&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 分析代码：1我们得构造$_GET[‘username’]和$GET[‘password’]的值不相等，同时它们的md5的值相等才能得到flag 因为md5不能处理数组，可以使用数组绕过，md5(数组)会返回FALSE，username[]=1,password[]=2这样弱==下可以实现username!=password,同时会得到FALSE===FALSE使得md5(username)===md5(password)成立。解决：http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 直接得到flag。 Experiment 3打开链接得到：细细品味后发现“链接”下真有一个链接。点开得到php代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123;$v1 = $_GET['v1'];$v2 = $_GET['v2'];$v3 = $_GET['v3'];if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123;if(!strcmp($v3, $flag))&#123;echo $flag;&#125;&#125;&#125;?&gt; 分析代码：v1不等于v2同时两者的MD5值相等&lt;此处既可以用MD5的0e漏洞也可以利用数组绕过&gt;由if(!strcmp(v3,flag))需要v3和flag值相同才返回flag的值 strcmp漏洞int strcmp ( string str1,stringstr2 )str1是第一个字符串，str2是第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 但是如果我们传入非字符串类型的数据的时候，这个函数将发生错误，在5.3之前的php中，显示了报错的警告信息后，将return 0 ! 也就是虽然报了错，但却判定其相等了。 因此，解这道题，就只要传入一个非字符串类型的变量使其报错，又由于前面的否定“！”得到true。解决：http://123.206.31.85:49162/?v1[]=1&amp;v2[]=2&amp;v3[]=1 Experiment 3.2打开链接得到空页，根据给出的php代码： 123456789&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 分析代码： 第一行，flag变量被设置为flag{xxxxx}。这并不是我们要提交的flag，真实运行的后端中的flag变量才是真的flag。 第二行，isset函数判断HTTP GET请求中的参数a是否已设置并且非NULL。strcmp函数将a参数与flag相比较，如果一致，则调用die函数。die函数的作用是打印die函数的参数，并立即停止该php后端的运行。那么我们的目标很明显，就是要让php执行到die函数，显示flag。根据上题strcmp漏洞，我们可以直接利用数组绕过比如用”a[]=”解决：http://123.206.87.240:9009/6.php?a[]= ereg截断打开链接同样是一个空白页面，根据给出的php代码： 1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 分析代码：flag变量被设置为flag，即最终我们需要得到flag变量的内容从而达到真正的flag。isset函数判断HTTP GET请求中的参数password是否已设置并且非NULL ereg()函数 1234567&#123; ereg ( string $pattern , string $string [, array &amp;$regs ] ) : int函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。&#125;ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) !== FALSE由第一个参数正则表达式可知该字符串从头到尾只允许出现字母与数字即a-z、A-Z、0-9. strpos()函数123456&#123; strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int查找字符串在另一字符串中第一次出现的位置。&#125;strpos ($_GET['password'], '--') !== FALSE该字符串必须有“*--*”字符。 这两个条件明显发生冲突，由于ereg()函数存在%00截断，即ereg()读取字符串时，当遇到%00会默认已经读完，不再读取后面的内容，这样我们就可以利用此漏洞在%00后添加“–”从而绕过正则检测。 解决：http://123.206.87.240:9009/19.php?password=12%00--同时，ereg()只能处理字符串，遇到数组做参数返回NULL，条件用强 === （要求两边类型相同），而NULL跟FALSE类型不同,顺利进入下一个条件；strpos()的参数也不能为数组，否则返回NULL，与FALSE类型不同，满足！==条件，故也可以直接传入一个数组。解决：http://123.206.87.240:9009/19.php?password[]=（或http://123.206.87.240:9009/19.php?password[]=1只是一个为空值一个给了个值。） Extract打开链接空白页面，分析给出的php代码： 12345678910&lt;?php$flag='xxx';extract($_GET); if(isset($shiyan))&#123; $content=trim(file_get_contents($flag)); if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; extract()函数{extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉，这就造成了变量覆盖漏洞。} 代码分析：将flag变量设置为xxx；将GET 方法传输进来的值通过extract()函数处理；isset函数判断HTTP GET请求中的参数shiyan是否已设置并且非NULL;if 判断shiyan这个变量和content这个变量是否相等。content 的值是通过读取 flag 变量的值来获取的。如果这个两个变量相等输出 flag 。file_get_contents() — 将整个文件读入一个字符串。trim() — 去除字符串首尾处的空白字符（或者其他字符）。解决：由于我们不知道flag的值是什么？所以我们需要利用extract()函数漏洞，进行变量覆盖，重新给flag变量赋值。只要我们构造的payload使得 $shiyan = $content ，其中 $content 的值又取决于 flag 变量，所以只要 shiyan变量相等于flag变量即可。由于file_get_contents($flag) 中的$flag是一个参数，导致$content的值是空值，所以我们可以构造如下payload：http://123.206.87.240:9009/1.php?shiyan= 这里再引一位大佬的解答：（代码稍有不同）https://zhouxinan.github.io/ 123456789101112&lt;?php$flag='xxx';extract($_GET);if(isset($sixstars)) &#123; $content=trim(file_get_contents($flag)); if ($sixstars==$content) &#123; echo 'flag&#123;xxx&#125;'; &#125; else &#123; echo 'Oh.no'; &#125;&#125;?&gt; 首先，flag变量被设置为’xxx’，一个简单的字符串。接着，后端运行了extract函数，从$_GET数组中将变量导入到当前的符号表。什么意思呢？其实很简单。比如如果我们访问了http://139.224.220.67:23900/dmsj/level2/?sixstars=1，那么`$_GET[&quot;sixstars&quot;]`的值为字符串1。执行`extract($_GET)`;时，就相当于执行了`$sixstars=&#39;1&#39;`。然后，程序将会执行isset($sixstars)。我们看到，为了获取flag，必须执行到echo ‘flag{xxx}’;，所以isset($sixstars)的返回值必须为 TRUE。所以，我们必须通过extract($_GET);将sixstars变量设置为任意值，即使是空字符串也可以。也就是说，即使访问http://139.224.220.67:23900/dmsj/level2/?sixstars=也是可以的。但绝对不能不包含sixstars参数。接着，程序将会执行$content=trim(file_get_contents($flag));。我们分步看。首先会执行file_get_contents($flag)。正常情况下，如果你不通过URL传入flag参数，那么，因为程序的最开始已经执行过$flag=&#39;xxx&#39;;，所以到了这里将会执行file_get_contents(‘xxx’)。file_get_contents函数可以“将整个文件读入一个字符串”。比如如下代码可以将http://www.example.com/网站的源代码读取到homepage变量中并显示出来。 1234&lt;?php$homepage = file_get_contents('http://www.example.com/');echo $homepage;?&gt; 接着，php又会执行trim函数，它将会“去除字符串首尾处的空白字符（或者其他字符）”。最后，php将会执行if ($sixstars==$content)，如果为TRUE，那么将会显示flag。读到这里，你想必已经知道了我们该怎么做：首先，给sixstars变量传入一个值，比如1。然后，给flag变量传入一个我们能控制的网站的地址，并让这个我们能控制的网站的源代码设置为1。由于extract能起到“变量覆盖”的作用，在extract后，flag变量就会被覆盖为我们能控制的网站的地址，而不再是’xxx’，这样当执行到file_get_contents时php后端将会从我们能控制的网站上读取到1，并将其和sixstars变量比较，并返回TRUE，然后就能打印flag。虽然这个方法是可行的，但是今天我要教你一个更简单的方法，那就是php伪协议。我们可以直接给flag变量传入data://text/plain,1。意思是明文1。这样file_get_contents(‘data://text/plain,1’)将会直接返回1，就不需要我们在公网上开一台服务器了。所以，最后我们的payload是：1 http://139.224.220.67:23900/dmsj/level2/?sixstars=1&amp;flag=data://text/plain,1这里再强调一下，给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://singlemindedt.github.io/categories/代码审计/"},{"name":"php","slug":"代码审计/php","permalink":"https://singlemindedt.github.io/categories/代码审计/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://singlemindedt.github.io/tags/php/"}]},{"title":"加密算法","slug":"加密算法","date":"2019-09-01T14:50:25.000Z","updated":"2019-09-01T14:50:25.208Z","comments":true,"path":"2019/09/01/加密算法/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/加密算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"反序列化","slug":"反序列化","date":"2019-09-01T14:49:34.000Z","updated":"2019-09-01T14:49:35.039Z","comments":true,"path":"2019/09/01/反序列化/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/反序列化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"xxe","slug":"xxe","date":"2019-09-01T14:49:06.000Z","updated":"2019-09-01T14:49:06.023Z","comments":true,"path":"2019/09/01/xxe/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/xxe/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"VPS","slug":"VPS","date":"2019-09-01T14:47:52.000Z","updated":"2019-09-01T14:47:52.634Z","comments":true,"path":"2019/09/01/VPS/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/VPS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"小雏鸟的成人式2","slug":"算法作业one","date":"2019-09-01T09:37:45.000Z","updated":"2019-09-05T14:24:01.539Z","comments":true,"path":"2019/09/01/算法作业one/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/算法作业one/","excerpt":"","text":"题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出每行对应输入，给出一个符合题意的整数 样例输入1230 51 112 85 样例输出12351100850000 提示###思路：很容易想到计算方法，其中N=100的情况需要注意，在下面带代码中给出。 题解：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; double D,N;//pow(double,double) double n; //避免损失精度 //int s;//最后由于要得到整数而非科学记数法，故需要强制转换一下 //如：2 100 得到1.01e+006转化之后为1010000 //***也可以直接cout&lt;&lt;int(n)转化输出结果 while(cin&gt;&gt;D&gt;&gt;N) &#123; if(1&lt;=N&amp;&amp;N&lt;100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2) &#123; n=N*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else if(N=100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2)//当N=100用原来的算法会使结果整除次数加1 &#123; n=101*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else continue; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T16:00:00.000Z","updated":"2019-09-05T14:30:35.937Z","comments":true,"path":"2019/08/31/hello-world/","link":"","permalink":"https://singlemindedt.github.io/2019/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://singlemindedt.github.io/tags/Hexo/"}]}]}