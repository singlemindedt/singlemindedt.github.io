{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Smtsec","url":"https://singlemindedt.github.io","root":"/"},"pages":[{"title":"迷路了404","date":"2019-08-31T01:24:31.422Z","updated":"2019-08-31T01:24:18.825Z","comments":true,"path":"404.html","permalink":"https://singlemindedt.github.io/404.html","excerpt":"","text":""},{"title":"about me","date":"2019-08-31T01:12:58.000Z","updated":"2019-08-31T01:17:42.190Z","comments":true,"path":"about/index.html","permalink":"https://singlemindedt.github.io/about/index.html","excerpt":"","text":"是不是我魅力太大，hahaha~"}],"posts":[{"title":"攻防世界之Web新手（7-12）","slug":"攻防世界之Web新手（7-12）","date":"2019-09-05T13:09:03.000Z","updated":"2019-09-05T14:09:35.321Z","comments":true,"path":"2019/09/05/攻防世界之Web新手（7-12）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/05/攻防世界之Web新手（7-12）/","excerpt":"","text":"simple_js题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。打开链接如图： X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123得到下图提示：再加一条Referer:https://www.google.com 得到flag。由于每次添加都要重新输入，这里可以利用Repeater功能：得到：可以在左边直接编辑Request—&gt;右侧得到Response：Response—&gt;Flag! 自己编辑的时候注意Target的格式：去掉请求协议http:// URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。根据弹窗的提示，用户名必须是admin将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) —————————-正常解法———————-用Burp Suite对它进行密码爆破，可以先试着输入username=admin和password=11111,以确定爆破位置。Action—&gt;send to Intruder基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。2、由于username规定用admin；简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。开始爆破：可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。上传木马拿webshell的方法汇总图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件）就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功：选择双击：看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;*实际操作： 试着使用命令连接符，查看目录发现有home目录，看看里面有啥：发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下：得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值尝试post传值：得到flag: simple_php##题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。打开链接：很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url:","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Images","slug":"images","date":"2019-09-04T09:37:45.000Z","updated":"2019-09-05T14:33:05.157Z","comments":true,"path":"2019/09/04/images/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/images/","excerpt":"","text":"Inset demo …","categories":[],"tags":[]},{"title":"攻防世界之Web新手（1-6）","slug":"攻防世界之Web新手（1-6）","date":"2019-09-04T07:11:48.415Z","updated":"2019-09-04T09:49:49.710Z","comments":true,"path":"2019/09/04/攻防世界之Web新手（1-6）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/攻防世界之Web新手（1-6）/","excerpt":"","text":"view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下：试试右键的确不管用了，直接F12，找到flag 另外还可以通过view-source：url查看源代码： 其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？知识补充： 两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc实际操作：打开网址，得到如下要求&lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白；在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txtf1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充：Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php”根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"代码审计","slug":"代码审计ONE","date":"2019-09-03T14:35:18.000Z","updated":"2019-09-04T08:46:22.694Z","comments":true,"path":"2019/09/03/代码审计ONE/","link":"","permalink":"https://singlemindedt.github.io/2019/09/03/代码审计ONE/","excerpt":"","text":"PHP大法（来源：实验吧 解题链接： http://ctf5.shiyanbar.com/DUTCTF/index.php）点开链接只有如上一句话。根据提示 直接访问： index.php.txt （即：http://ctf5.shiyanbar.com/DUTCTF/index.php.txt）得到如下页面：分析代码： 1234567891011121314151617 &lt;?php if(eregi(\"hackerDJ\",$_GET[id])) &#123; //对id进行字符串匹配，若$_GET[id]中有hacker DJ则 //出not allowed!并终止正在执行的进程; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); //urldecode对字符串进行URL解码;将解码后的//$_GET[id]赋值给$_GET[id]; if($_GET[id] == \"hackerDJ\") //若$_GET[id]的值等于hackerDJ，输出Access granted! //并给出flag: *****************&#125; &#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\"; &#125; ?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 12345678$_GET说明通过 URL 参数传递给当前脚本的变量的数组Example #1$_GET范例 &lt;?php echo 'Hello ' . htmlspecialchars($_GET[\"name\"]) . '!'; ?&gt;假设用户访问的是 http://example.com/?name=Hannes以上例程的输出类似于： Hello Hannes! 解题思路：有$_GET[id] 所以应该是可以用 ?id= 来构造URLid变量是一个url解码函数前不包含hackerDJ，url解码函数后为hackerDJ的变量，即id在进入url解码函数前必须是hackerDJ的url编码形式 注意：由于在浏览器输入url后会进行一次decode，这段代码中又进行一次decode，所以应对hackerDJ进行两次encode。只进行一次encode，浏览器自动解码后即为hackerDJ,被eregi()拦住，所以要进行二次编码，即对%68%61%63%6B%65%72%44%4A进行url编码。 ① http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%68%61%63%6B%65%72%44%4A ② http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 或者直接对其中的一个字母进行二次编码： h –&gt; %68 –&gt; %2568构造url: index.php?id=%2568ackerDJ Very easy打开链接直接得到如下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 分析：如果$what等于flag,则给出flag。解决：http://123.206.87.240:8002/get/?what=flag 得到flag。 Experiment 1打开链接直接出现PHP代码： 123456789101112131415&lt;?php include \"flag.php\"; highlight_file(__FILE__); if (isset($_GET['money'])) &#123; $money=$_GET['money']; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money)) &#123; echo $flag; echo \"&lt;!--By:daoyuan--&gt;\"; &#125; else echo \"Wrong Answer!\"; &#125; else echo \"Wrong Answer!\";?&gt; 代码分析：第一行:告诉我们flag应该就在flag.php中第二行：highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。 提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。 注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！ 语法：highlight_file(filename,return)filename 必需。规定要显示的文件。return 可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。返回值如果 return 参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。否则，如果成功则返回 TRUE，如果失败则返回 FALSE。If条件：$money的长度&lt;=4；同时&gt;time()；同时不是数组{time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。此处我们直接将其理解为一个很大的数}==PHP中，字符串开头以xex开头，x代表数字。会被转换成科学计数法。 如1e9 == 1×10^9==解决：直接用xex格式如：http://119.23.73.3:5001/web6/?money=10e9 直接得到flag Experiment 2打开链接页面中只有一句话“好像少了点什么”，试着在url后添加index.php~即http://119.23.73.3:5001/web5/index.php~。打开页面发现什么都没有，查看源文件发现果然有PHP文件： 分析代码：9：给出$flag的值为我们最终需要的结果 1moctf&#123;**************&#125; 11：{PHP的isset()函数 一般用来检测变量是否设置格式：bool isset ( mixed var [, mixed var [, …]] )功能：检测变量是否设置返回值：若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE版本：PHP 3, PHP 4, PHP 5更多说明：使用 unset() 释放变量之后，它将不再是 isset()。PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。检测常量是否已设置可使用 defined() 函数。} 1234If条件下对变量$_GET['a']和$_GET['b']赋值，并将其赋值给$a,$b.若$a等于$b则打印Wrong Answer!否则在条件md5($a)==md5($b)下给出$flag，否则打印Wrong Answer！**即此代码的意思时要我们对提供$a,$b使得其值不同，但MD5值相同。** ***弱类型比较——“==”类型转换的规则1、字符串和数字比较，字符串会被转换成数字。 “admin”==0 (true) admin被转换成数字，由于admin是字符串，转换失败，int(admin)=0，所以 比较结果是true。2、混合字符串转换成数字，看字符串的第一个。 “1admin”==1 “2admin”==23、字符串开头以xex开头，x代表数字。会被转换成科学计数法。 1e9 == 1×10^9 注： 12\"admin1\"==1 //false\"admin1\"==0 //true 参考网上资料：当一个字符串当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内则：该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 所以我们可以直接找符合xex格式的MD5原参{MD5 算法自诞生之日起，就有很多人试图证明和发现它的不安全之处，即存在碰撞（在对两个不同的内容使用 MD5算法运算的时候，有可能得到一对相同的结果值）–百科}md5的碰撞，在PHP的数的处理中，类似0开头的字符串会被转换成0，因此有md5碰撞。 MD5值(哈希值)相等的问题可以用哈希值碰撞，也可以用数组绕过，如： 1`username[]=1&amp;password[]=2. 解决：http://119.23.73.3:5001/web5/**?a=QNKCDZO&amp;b=s878926199a** ,直接得到flag。 1md5('**QNKCDZO**')==md5('**s878926199a** ')---&gt;True Experiment 2.1题目给出了php代码： 12345678910111213&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 分析代码：1我们得构造$_GET[‘username’]和$GET[‘password’]的值不相等，同时它们的md5的值相等才能得到flag 因为md5不能处理数组，可以使用数组绕过，md5(数组)会返回FALSE，username[]=1,password[]=2这样弱==下可以实现username!=password,同时会得到FALSE===FALSE使得md5(username)===md5(password)成立。解决：http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 直接得到flag。 Experiment 3打开链接得到：细细品味后发现“链接”下真有一个链接。点开得到php代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123;$v1 = $_GET['v1'];$v2 = $_GET['v2'];$v3 = $_GET['v3'];if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123;if(!strcmp($v3, $flag))&#123;echo $flag;&#125;&#125;&#125;?&gt; 分析代码：v1不等于v2同时两者的MD5值相等&lt;此处既可以用MD5的0e漏洞也可以利用数组绕过&gt;由if(!strcmp(v3,flag))需要v3和flag值相同才返回flag的值 strcmp漏洞int strcmp ( string str1,stringstr2 )str1是第一个字符串，str2是第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 但是如果我们传入非字符串类型的数据的时候，这个函数将发生错误，在5.3之前的php中，显示了报错的警告信息后，将return 0 ! 也就是虽然报了错，但却判定其相等了。 因此，解这道题，就只要传入一个非字符串类型的变量使其报错，又由于前面的否定“！”得到true。解决：http://123.206.31.85:49162/?v1[]=1&amp;v2[]=2&amp;v3[]=1 Experiment 3.2打开链接得到空页，根据给出的php代码： 123456789&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 分析代码： 第一行，flag变量被设置为flag{xxxxx}。这并不是我们要提交的flag，真实运行的后端中的flag变量才是真的flag。 第二行，isset函数判断HTTP GET请求中的参数a是否已设置并且非NULL。strcmp函数将a参数与flag相比较，如果一致，则调用die函数。die函数的作用是打印die函数的参数，并立即停止该php后端的运行。那么我们的目标很明显，就是要让php执行到die函数，显示flag。根据上题strcmp漏洞，我们可以直接利用数组绕过比如用”a[]=”解决：http://123.206.87.240:9009/6.php?a[]= ereg截断打开链接同样是一个空白页面，根据给出的php代码： 1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 分析代码：flag变量被设置为flag，即最终我们需要得到flag变量的内容从而达到真正的flag。isset函数判断HTTP GET请求中的参数password是否已设置并且非NULL ereg()函数 1234567&#123; ereg ( string $pattern , string $string [, array &amp;$regs ] ) : int函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。&#125;ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) !== FALSE由第一个参数正则表达式可知该字符串从头到尾只允许出现字母与数字即a-z、A-Z、0-9. strpos()函数123456&#123; strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int查找字符串在另一字符串中第一次出现的位置。&#125;strpos ($_GET['password'], '--') !== FALSE该字符串必须有“*--*”字符。 这两个条件明显发生冲突，由于ereg()函数存在%00截断，即ereg()读取字符串时，当遇到%00会默认已经读完，不再读取后面的内容，这样我们就可以利用此漏洞在%00后添加“–”从而绕过正则检测。 解决：http://123.206.87.240:9009/19.php?password=12%00--同时，ereg()只能处理字符串，遇到数组做参数返回NULL，条件用强 === （要求两边类型相同），而NULL跟FALSE类型不同,顺利进入下一个条件；strpos()的参数也不能为数组，否则返回NULL，与FALSE类型不同，满足！==条件，故也可以直接传入一个数组。解决：http://123.206.87.240:9009/19.php?password[]=（或http://123.206.87.240:9009/19.php?password[]=1只是一个为空值一个给了个值。） Extract打开链接空白页面，分析给出的php代码： 12345678910&lt;?php$flag='xxx';extract($_GET); if(isset($shiyan))&#123; $content=trim(file_get_contents($flag)); if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; extract()函数{extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉，这就造成了变量覆盖漏洞。} 代码分析：将flag变量设置为xxx；将GET 方法传输进来的值通过extract()函数处理；isset函数判断HTTP GET请求中的参数shiyan是否已设置并且非NULL;if 判断shiyan这个变量和content这个变量是否相等。content 的值是通过读取 flag 变量的值来获取的。如果这个两个变量相等输出 flag 。file_get_contents() — 将整个文件读入一个字符串。trim() — 去除字符串首尾处的空白字符（或者其他字符）。解决：由于我们不知道flag的值是什么？所以我们需要利用extract()函数漏洞，进行变量覆盖，重新给flag变量赋值。只要我们构造的payload使得 $shiyan = $content ，其中 $content 的值又取决于 flag 变量，所以只要 shiyan变量相等于flag变量即可。由于file_get_contents($flag) 中的$flag是一个参数，导致$content的值是空值，所以我们可以构造如下payload：http://123.206.87.240:9009/1.php?shiyan= 这里再引一位大佬的解答：（代码稍有不同）https://zhouxinan.github.io/ 123456789101112&lt;?php$flag='xxx';extract($_GET);if(isset($sixstars)) &#123; $content=trim(file_get_contents($flag)); if ($sixstars==$content) &#123; echo 'flag&#123;xxx&#125;'; &#125; else &#123; echo 'Oh.no'; &#125;&#125;?&gt; 首先，flag变量被设置为’xxx’，一个简单的字符串。接着，后端运行了extract函数，从$_GET数组中将变量导入到当前的符号表。什么意思呢？其实很简单。比如如果我们访问了http://139.224.220.67:23900/dmsj/level2/?sixstars=1，那么`$_GET[&quot;sixstars&quot;]`的值为字符串1。执行`extract($_GET)`;时，就相当于执行了`$sixstars=&#39;1&#39;`。然后，程序将会执行isset($sixstars)。我们看到，为了获取flag，必须执行到echo ‘flag{xxx}’;，所以isset($sixstars)的返回值必须为 TRUE。所以，我们必须通过extract($_GET);将sixstars变量设置为任意值，即使是空字符串也可以。也就是说，即使访问http://139.224.220.67:23900/dmsj/level2/?sixstars=也是可以的。但绝对不能不包含sixstars参数。接着，程序将会执行$content=trim(file_get_contents($flag));。我们分步看。首先会执行file_get_contents($flag)。正常情况下，如果你不通过URL传入flag参数，那么，因为程序的最开始已经执行过$flag=&#39;xxx&#39;;，所以到了这里将会执行file_get_contents(‘xxx’)。file_get_contents函数可以“将整个文件读入一个字符串”。比如如下代码可以将http://www.example.com/网站的源代码读取到homepage变量中并显示出来。 1234&lt;?php$homepage = file_get_contents('http://www.example.com/');echo $homepage;?&gt; 接着，php又会执行trim函数，它将会“去除字符串首尾处的空白字符（或者其他字符）”。最后，php将会执行if ($sixstars==$content)，如果为TRUE，那么将会显示flag。读到这里，你想必已经知道了我们该怎么做：首先，给sixstars变量传入一个值，比如1。然后，给flag变量传入一个我们能控制的网站的地址，并让这个我们能控制的网站的源代码设置为1。由于extract能起到“变量覆盖”的作用，在extract后，flag变量就会被覆盖为我们能控制的网站的地址，而不再是’xxx’，这样当执行到file_get_contents时php后端将会从我们能控制的网站上读取到1，并将其和sixstars变量比较，并返回TRUE，然后就能打印flag。虽然这个方法是可行的，但是今天我要教你一个更简单的方法，那就是php伪协议。我们可以直接给flag变量传入data://text/plain,1。意思是明文1。这样file_get_contents(‘data://text/plain,1’)将会直接返回1，就不需要我们在公网上开一台服务器了。所以，最后我们的payload是：1 http://139.224.220.67:23900/dmsj/level2/?sixstars=1&amp;flag=data://text/plain,1这里再强调一下，给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://singlemindedt.github.io/categories/代码审计/"},{"name":"php","slug":"代码审计/php","permalink":"https://singlemindedt.github.io/categories/代码审计/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://singlemindedt.github.io/tags/php/"}]},{"title":"加密算法","slug":"加密算法","date":"2019-09-01T14:50:25.000Z","updated":"2019-09-01T14:50:25.208Z","comments":true,"path":"2019/09/01/加密算法/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/加密算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"反序列化","slug":"反序列化","date":"2019-09-01T14:49:34.000Z","updated":"2019-09-01T14:49:35.039Z","comments":true,"path":"2019/09/01/反序列化/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/反序列化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"xxe","slug":"xxe","date":"2019-09-01T14:49:06.000Z","updated":"2019-09-01T14:49:06.023Z","comments":true,"path":"2019/09/01/xxe/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/xxe/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"VPS","slug":"VPS","date":"2019-09-01T14:47:52.000Z","updated":"2019-09-01T14:47:52.634Z","comments":true,"path":"2019/09/01/VPS/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/VPS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"小雏鸟的成人式2","slug":"算法作业one","date":"2019-09-01T09:37:45.000Z","updated":"2019-09-05T14:24:01.539Z","comments":true,"path":"2019/09/01/算法作业one/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/算法作业one/","excerpt":"","text":"题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出每行对应输入，给出一个符合题意的整数 样例输入1230 51 112 85 样例输出12351100850000 提示###思路：很容易想到计算方法，其中N=100的情况需要注意，在下面带代码中给出。 题解：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; double D,N;//pow(double,double) double n; //避免损失精度 //int s;//最后由于要得到整数而非科学记数法，故需要强制转换一下 //如：2 100 得到1.01e+006转化之后为1010000 //***也可以直接cout&lt;&lt;int(n)转化输出结果 while(cin&gt;&gt;D&gt;&gt;N) &#123; if(1&lt;=N&amp;&amp;N&lt;100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2) &#123; n=N*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else if(N=100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2)//当N=100用原来的算法会使结果整除次数加1 &#123; n=101*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else continue; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T16:00:00.000Z","updated":"2019-09-05T14:30:35.937Z","comments":true,"path":"2019/08/31/hello-world/","link":"","permalink":"https://singlemindedt.github.io/2019/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://singlemindedt.github.io/tags/Hexo/"}]}]}